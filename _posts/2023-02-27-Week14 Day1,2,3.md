---
key: /2023/02/27/Week14-Day1,2,3.html
title: TIL - 14주차 코드
tags: spring maven springboot RestfulAPI
---

<br>
# 1. 스프링 부트 : 230227

- 4대 저장소 : session, request
- application = 서블릿 컨텍스트의 형식 명칭
- page = pageContext 명칭


### 1) 파일 전송 설정!

- 파일 전송의 location 설정은 기본 설정으로 하자. theshold 설정도 디스크가 사용하는 메모리량이라서 우리가 설정할 부분이 아니다.

- application.properties 설정! 

```
spring.servlet.multipart.max-file-size=100MB	
#각각의 파일 용량 
spring.servlet.multipart.max-request-size=200MB 
#전체 용량

```

<br>
### 2) 파일 저장하는 방법 

- 이미지는 webapp/image 폴더에 만들자!

- 파일을 저장하기 위해서는 절대 경로만으로 스트림을 만들 수 있다? 다른 경로도 필요하다! 
	- 그 이유는 다른 디렉토리에서 서비스가 동작할 수 있으면 경로가 다 달라지기 때문이다.

- 따라서, urlPath와 물리적 경로인 realPath가 필요하다. 스프링이 대신 해주지 못하고 기존 서블릿 코드를 가져다가 사용하자! 

- 아직 스프링 부트는 webapp 안에만 이미지를 넣을 수 있다. 아직 다른 폴더에 넣을 수 없다. 기술 발전이 되지 않았다. 

---

<br>

- 실습 코드 :
	- 파일을 전송하기 위한 2가지 방법 :

```java
package kr.co.rland.web.controller;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

// FrontController(POJO 클래스)를 만드는 방법! 
// 클래스는 보통 폴더명이 된다.(기능별로 넣자!) 
@Controller
@RequestMapping("/")
public class HomeController {
	
	//업로드는 요청이므로 Post요청이다. 그리고 파일 전송은 view가 필요 없다!
	@PostMapping("upload")
	@ResponseBody		
	public String upload(MultipartFile img, HttpServletRequest request) throws IOException {
		
		// 4대 저장소 : session, request
		// application = 서블릿 컨텍스트의 형식 명칭
		// page = pageContext 명칭
		
		String urlPath = "/image/menu/" + img.getOriginalFilename();
		String realPath = request.getServletContext().getRealPath(urlPath);
		
//		realPath = this.getClass().getResource("").getPath();
//		realPath = this.getClass().getResource("/").getPath();	// classes라는 root부터 시작 
		// realPath는 클래스 파일이 아니라 실제 폴더에서 파일의 위치이다. 
		
		System.out.println(realPath);
		
		
		// 파일을 저장하는 방법 1: 
//		String fileName = img.getOriginalFilename();
//		
//		InputStream fis = img.getInputStream();
//		OutputStream fos = new FileOutputStream(realPath);
//		
//		byte[] buf = new byte[1024];		
//		int size = 1024;					// 버퍼의 데이터를 1024 바이트씩 읽는다.
//		
//											// fis.read()에 의해서 데이터를 1줄씩 읽는다. 
//		while((size = fis.read(buf))!=-1)	// -1의 의미 : 읽는 게 더 이상 없으면 파일을 저장하지 않음. 
//			fos.write(buf, 0, size);	// buf에 0번부터 size까지 버퍼에 저장하여 파일을 생성한다.
//		
//		fis.close();
//		fos.close();
		
		
		// 파일을 저장하는 방법 2 : 
		img.transferTo(new File(realPath));	// 이것도 가능하지만, 직접 수정하거나 출력할 수 없다.
		
		
		// return 되는 것이 바로 문자열로 반환할 때 Body 사용!
		System.out.println(img.getOriginalFilename());
		return realPath;
	}
	
	// 함수 이름은 보통 url이 된다.
	@RequestMapping("index")			
	public String index(Model model, HttpServletResponse response) throws UnsupportedEncodingException {	// 이렇게 하면, Front-controller가 가지고 있는 response를 가져온다.
		
		// String data = "Hello Data";
		
		// 쿠키도 서블릿이라서 어떻게 해야하지? 방법이 없어서 어쩔 수 없이 response를 사용한다. 
		// 쿠키는 한글을 출력 못해서 url 인코더로 인코딩을 해주어야 한다. ㅜ
		
		String data = URLEncoder.encode("cookie 지륭~", "utf-8"); 
		System.out.println(data);
		
		Cookie cookie = new Cookie("my", data);
		response.addCookie(cookie);
		// 쿠키는 모든 url에서 열어 볼 수 있다. 이러한 url은 클라이언트가 요청한 url이다.("/"에서 시작)
		//model은 addAttribute를 해서 데이터를 view단으로 출력해준다. 
		
		model.addAttribute("data", data);
		
		return "/WEB-INF/view/index.jsp";
	}
	

}

```

---

<br><br>
### 2) 2개 이상의 파일을 전송하는 방법 

- HomeController.java

```java
package kr.co.rland.web.controller;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

// FrontController(POJO 클래스)를 만드는 방법! 
// 클래스는 보통 폴더명이 된다.(기능별로 넣자!) 
@Controller
@RequestMapping("/")
public class HomeController {
	
	//업로드는 요청이므로 Post요청이다. 그리고 파일 전송은 view가 필요 없다!
	@PostMapping("upload")
	@ResponseBody		
	public String upload(MultipartFile[] imgs, HttpServletRequest request) throws IOException {
		
		// 4대 저장소 : session, request
		// application = 서블릿 컨텍스트의 형식 명칭
		// page = pageContext 명칭
		
		for(int i=0; i<imgs.length; i++)
		{
			MultipartFile img = imgs[i];
			
			if(img.isEmpty())	// 파일 저장되는 순서 생각해보기(2개 파일 중 순서)
				continue;		// break가 아니라 continue이다.
			
			String urlPath = "/image/menu/" + img.getOriginalFilename();
			String realPath = request.getServletContext().getRealPath(urlPath);
			
	//		realPath = this.getClass().getResource("").getPath();
	//		realPath = this.getClass().getResource("/").getPath();	// classes라는 root부터 시작 
			// realPath는 클래스 파일이 아니라 실제 폴더에서 파일의 위치이다. 
			
			System.out.println(realPath);
			
	
		// 파일을 저장하는 방법 1: 
//		String fileName = img.getOriginalFilename();
//		
//		InputStream fis = img.getInputStream();
//		OutputStream fos = new FileOutputStream(realPath);
//		
//		byte[] buf = new byte[1024];		
//		int size = 1024;					// 버퍼의 데이터를 1024 바이트씩 읽는다.
//		
//											// fis.read()에 의해서 데이터를 1줄씩 읽는다. 
//		while((size = fis.read(buf))!=-1)	// -1의 의미 : 읽는 게 더 이상 없으면 파일을 저장하지 않음. 
//			fos.write(buf, 0, size);	// buf에 0번부터 size까지 버퍼에 저장하여 파일을 생성한다.
//		
//		fis.close();
//		fos.close();
		
		
			// 파일을 저장하는 방법 2 : 
			img.transferTo(new File(realPath));	// 이것도 가능하지만, 직접 수정하거나 출력할 수 없다.
			
			// return 되는 것이 바로 문자열로 반환할 때 Body 사용!
			System.out.println(realPath);
		
		}
		
		return "ok";
	}
	
	// 함수 이름은 보통 url이 된다.
	@RequestMapping("index")			
	public String index(Model model, HttpServletResponse response) throws UnsupportedEncodingException {	// 이렇게 하면, Front-controller가 가지고 있는 response를 가져온다.
		
		// String data = "Hello Data";
		
		// 쿠키도 서블릿이라서 어떻게 해야하지? 방법이 없어서 어쩔 수 없이 response를 사용한다. 
		// 쿠키는 한글을 출력 못해서 url 인코더로 인코딩을 해주어야 한다. ㅜ
		
		String data = URLEncoder.encode("cookie 지륭~", "utf-8"); 
		System.out.println(data);
		
		Cookie cookie = new Cookie("my", data);
		response.addCookie(cookie);
		// 쿠키는 모든 url에서 열어 볼 수 있다. 이러한 url은 클라이언트가 요청한 url이다.("/"에서 시작)
		//model은 addAttribute를 해서 데이터를 view단으로 출력해준다. 
		
		model.addAttribute("data", data);
		
		return "/WEB-INF/view/index.jsp";
	}
	

}

```


---


<br><br>
- reg.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<section>
		<h1>메뉴 등록 페이지 </h1>
		<form method="post">
			<fieldset>
				<legend>메뉴 입력 필드</legend>
				<div>
					<label>제목 : </label>
					<input type="text" name="title">
				</div>
				<div>
					<input type="submit" value="등록">
				</div>
			</fieldset>
		</form>
	</section>
	
	
	<section>
		<h1>파일 입력 필드</h1>
		<form action="/upload" method="post" enctype="multipart/form-data">
			<fieldset>
				<legend>이미지: </legend>
				<div>
					<label>이미지 : </label>
					<input type="file" name="imgs">
				</div>
				<div>
					<label>이미지 : </label>
					<input type="file" name="imgs">
				</div>
				<div>
					<input type="submit" value="등록">
				</div>
			</fieldset>
		</form>
	</section>
</body>
</html>
```

---


<br><br>
### 3) MariaDB와 Spring 연동시키기

- MySQL은 무료가 아닌 무료이다. 서비스가 재판매가 불가능하다. 평가판 정도가 가능하다.

- 그래서, MariaDB를 사용한다.

- MySQL을 설치해서 java에서 연결을 mariaDB로 사용하자.

- mariaDB를 연결하고 연결이 잘되었는지 JUnit Test를 해보자 
	- Run As에서 JUnit으로 실행해보자! 

---

<br>
- 실습 코드 :

- 

<br>

<details>
<summary>MenuRepository.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.repository;

import java.util.List;

import kr.co.rland.web.entity.Menu;

public interface MenuRepository {
	List<Menu> findAll();
}

```

</div>
</details>


<br>

<details>
<summary>JdbcMenuRepository.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.repository.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

public class JdbcMenuRepository implements MenuRepository {

	@Override
	public List<Menu> findAll() {
		String sql = String.format("select id, name, price, regDate, categoryId from menu");
		
		List<Menu> list = new ArrayList<>();

		try {
			Class.forName("org.mariadb.jdbc.Driver");
			String url = "jdbc:mariadb://db.newlecture.com:3306/rlanddb";
			Connection con = DriverManager.getConnection(url, "rland", "20220823");

			Statement st = con.createStatement();
			ResultSet rs = st.executeQuery(sql);

			// 필터링, 집계, 정렬
			while (rs.next()) // 서버의 커서를 한칸 내리고 그 위치의 레코드를 옮겨 오는 것. -> 레코드 하나가 저장되는 공간은?
			{
				long id = rs.getInt("id");
				String name = rs.getString("name");
				int price = rs.getInt("price");
				Date regDate = rs.getDate("regDate");
				int categoryId = rs.getInt("categoryId");
				
				Menu menu = new Menu(id, name, price, regDate, categoryId, 1);
				list.add(menu);
			}
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return list;
	}

}

```

</div>
</details>

--- 

<br>

<details>
<summary>Menu.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.entity;

import java.util.Date;

public class Menu {
	private long id;
	private String name;
	private int price;
	private Date regDate;
	private int categoryId;
	private long regMemberId;
	
	
	public Menu() {
	}
	
	
	public Menu(long id, String name, int price, Date regDate, int categoryId, long regMemberId) {
		this.id = id;
		this.name = name;
		this.price = price;
		this.regDate = regDate;
		this.categoryId = categoryId;
		this.regMemberId = regMemberId;
	}
	
	//insert용
	
	public Menu(String name, int price, int categoryId) {
		this.name = name;
		this.price = price;
		this.categoryId = categoryId;
	}


	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}


	public String getName() {
		return name;
	}


	public void setName(String name) {
		this.name = name;
	}


	public int getPrice() {
		return price;
	}


	public void setPrice(int price) {
		this.price = price;
	}


	public Date getRegDate() {
		return regDate;
	}


	public void setRegDate(Date regDate) {
		this.regDate = regDate;
	}


	public int getCategoryId() {
		return categoryId;
	}


	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}


	public long getRegMemberId() {
		return regMemberId;
	}


	public void setRegMemberId(long regMemberId) {
		this.regMemberId = regMemberId;
	}


	@Override
	public String toString() {
		return "Menu [id=" + id + ", name=" + name + ", price=" + price + ", regDate=" + regDate + ", categoryId="
				+ categoryId + ", regMemberId=" + regMemberId + "]";
	}
	
	
	
}

```

</div>
</details>


---

<br>

- JUnit Test 방법 :  

<br>

<details>
<summary>JdbcMenuRepository.java</summary>
<div markdown="1">
	
```java
package kr.co.rland.web.repository.jdbc;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;

import org.junit.jupiter.api.Test;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

class JdbcMenuRepositoryTest {

	@Test
	void testFindAll() {
		MenuRepository repository = new JdbcMenuRepository();
		
		// 이렇게 써주던가 assert 계열 메서드의 매크로를 사용하자! 
//		if(repositoty.findAll()==null)	
		
		List<Menu> list = repository.findAll();
		
		System.out.println(list.size());
		
	}

}

```

</div>
</details>


---


<br><br>

# 2. 230228
