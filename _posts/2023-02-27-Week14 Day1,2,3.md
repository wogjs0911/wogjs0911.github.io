---
key: /2023/02/27/Week14-Day1,2,3.html
title: TIL - 14주차 코드
tags: spring maven springboot RestfulAPI
---

<br>
# 1. 스프링 부트 : 230227

- 4대 저장소 : session, request
- application = 서블릿 컨텍스트의 형식 명칭
- page = pageContext 명칭


### 1) 파일 전송 설정!

- 파일 전송의 location 설정은 기본 설정으로 하자. theshold 설정도 디스크가 사용하는 메모리량이라서 우리가 설정할 부분이 아니다.

- application.properties 설정! 

```
spring.servlet.multipart.max-file-size=100MB	
#각각의 파일 용량 
spring.servlet.multipart.max-request-size=200MB 
#전체 용량

```

<br>
### 2) 파일 저장하는 방법 

- 이미지는 webapp/image 폴더에 만들자!

- 파일을 저장하기 위해서는 절대 경로만으로 스트림을 만들 수 있다? 다른 경로도 필요하다! 
	- 그 이유는 다른 디렉토리에서 서비스가 동작할 수 있으면 경로가 다 달라지기 때문이다.

- 따라서, urlPath와 물리적 경로인 realPath가 필요하다. 스프링이 대신 해주지 못하고 기존 서블릿 코드를 가져다가 사용하자! 

- 아직 스프링 부트는 webapp 안에만 이미지를 넣을 수 있다. 아직 다른 폴더에 넣을 수 없다. 기술 발전이 되지 않았다. 

---

<br>

- 실습 코드 :
	- 파일을 전송하기 위한 2가지 방법 :

```java
package kr.co.rland.web.controller;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

// FrontController(POJO 클래스)를 만드는 방법! 
// 클래스는 보통 폴더명이 된다.(기능별로 넣자!) 
@Controller
@RequestMapping("/")
public class HomeController {
	
	//업로드는 요청이므로 Post요청이다. 그리고 파일 전송은 view가 필요 없다!
	@PostMapping("upload")
	@ResponseBody		
	public String upload(MultipartFile img, HttpServletRequest request) throws IOException {
		
		// 4대 저장소 : session, request
		// application = 서블릿 컨텍스트의 형식 명칭
		// page = pageContext 명칭
		
		String urlPath = "/image/menu/" + img.getOriginalFilename();
		String realPath = request.getServletContext().getRealPath(urlPath);
		
//		realPath = this.getClass().getResource("").getPath();
//		realPath = this.getClass().getResource("/").getPath();	// classes라는 root부터 시작 
		// realPath는 클래스 파일이 아니라 실제 폴더에서 파일의 위치이다. 
		
		System.out.println(realPath);
		
		
		// 파일을 저장하는 방법 1: 
//		String fileName = img.getOriginalFilename();
//		
//		InputStream fis = img.getInputStream();
//		OutputStream fos = new FileOutputStream(realPath);
//		
//		byte[] buf = new byte[1024];		
//		int size = 1024;					// 버퍼의 데이터를 1024 바이트씩 읽는다.
//		
//											// fis.read()에 의해서 데이터를 1줄씩 읽는다. 
//		while((size = fis.read(buf))!=-1)	// -1의 의미 : 읽는 게 더 이상 없으면 파일을 저장하지 않음. 
//			fos.write(buf, 0, size);	// buf에 0번부터 size까지 버퍼에 저장하여 파일을 생성한다.
//		
//		fis.close();
//		fos.close();
		
		
		// 파일을 저장하는 방법 2 : 
		img.transferTo(new File(realPath));	// 이것도 가능하지만, 직접 수정하거나 출력할 수 없다.
		
		
		// return 되는 것이 바로 문자열로 반환할 때 Body 사용!
		System.out.println(img.getOriginalFilename());
		return realPath;
	}
	
	// 함수 이름은 보통 url이 된다.
	@RequestMapping("index")			
	public String index(Model model, HttpServletResponse response) throws UnsupportedEncodingException {	// 이렇게 하면, Front-controller가 가지고 있는 response를 가져온다.
		
		// String data = "Hello Data";
		
		// 쿠키도 서블릿이라서 어떻게 해야하지? 방법이 없어서 어쩔 수 없이 response를 사용한다. 
		// 쿠키는 한글을 출력 못해서 url 인코더로 인코딩을 해주어야 한다. ㅜ
		
		String data = URLEncoder.encode("cookie 지륭~", "utf-8"); 
		System.out.println(data);
		
		Cookie cookie = new Cookie("my", data);
		response.addCookie(cookie);
		// 쿠키는 모든 url에서 열어 볼 수 있다. 이러한 url은 클라이언트가 요청한 url이다.("/"에서 시작)
		//model은 addAttribute를 해서 데이터를 view단으로 출력해준다. 
		
		model.addAttribute("data", data);
		
		return "/WEB-INF/view/index.jsp";
	}
	

}

```

---

<br><br>
### 2) 2개 이상의 파일을 전송하는 방법 

- HomeController.java

```java
package kr.co.rland.web.controller;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

// FrontController(POJO 클래스)를 만드는 방법! 
// 클래스는 보통 폴더명이 된다.(기능별로 넣자!) 
@Controller
@RequestMapping("/")
public class HomeController {
	
	//업로드는 요청이므로 Post요청이다. 그리고 파일 전송은 view가 필요 없다!
	@PostMapping("upload")
	@ResponseBody		
	public String upload(MultipartFile[] imgs, HttpServletRequest request) throws IOException {
		
		// 4대 저장소 : session, request
		// application = 서블릿 컨텍스트의 형식 명칭
		// page = pageContext 명칭
		
		for(int i=0; i<imgs.length; i++)
		{
			MultipartFile img = imgs[i];
			
			if(img.isEmpty())	// 파일 저장되는 순서 생각해보기(2개 파일 중 순서)
				continue;		// break가 아니라 continue이다.
			
			String urlPath = "/image/menu/" + img.getOriginalFilename();
			String realPath = request.getServletContext().getRealPath(urlPath);
			
	//		realPath = this.getClass().getResource("").getPath();
	//		realPath = this.getClass().getResource("/").getPath();	// classes라는 root부터 시작 
			// realPath는 클래스 파일이 아니라 실제 폴더에서 파일의 위치이다. 
			
			System.out.println(realPath);
			
	
		// 파일을 저장하는 방법 1: 
//		String fileName = img.getOriginalFilename();
//		
//		InputStream fis = img.getInputStream();
//		OutputStream fos = new FileOutputStream(realPath);
//		
//		byte[] buf = new byte[1024];		
//		int size = 1024;					// 버퍼의 데이터를 1024 바이트씩 읽는다.
//		
//											// fis.read()에 의해서 데이터를 1줄씩 읽는다. 
//		while((size = fis.read(buf))!=-1)	// -1의 의미 : 읽는 게 더 이상 없으면 파일을 저장하지 않음. 
//			fos.write(buf, 0, size);	// buf에 0번부터 size까지 버퍼에 저장하여 파일을 생성한다.
//		
//		fis.close();
//		fos.close();
		
		
			// 파일을 저장하는 방법 2 : 
			img.transferTo(new File(realPath));	// 이것도 가능하지만, 직접 수정하거나 출력할 수 없다.
			
			// return 되는 것이 바로 문자열로 반환할 때 Body 사용!
			System.out.println(realPath);
		
		}
		
		return "ok";
	}
	
	// 함수 이름은 보통 url이 된다.
	@RequestMapping("index")			
	public String index(Model model, HttpServletResponse response) throws UnsupportedEncodingException {	// 이렇게 하면, Front-controller가 가지고 있는 response를 가져온다.
		
		// String data = "Hello Data";
		
		// 쿠키도 서블릿이라서 어떻게 해야하지? 방법이 없어서 어쩔 수 없이 response를 사용한다. 
		// 쿠키는 한글을 출력 못해서 url 인코더로 인코딩을 해주어야 한다. ㅜ
		
		String data = URLEncoder.encode("cookie 지륭~", "utf-8"); 
		System.out.println(data);
		
		Cookie cookie = new Cookie("my", data);
		response.addCookie(cookie);
		// 쿠키는 모든 url에서 열어 볼 수 있다. 이러한 url은 클라이언트가 요청한 url이다.("/"에서 시작)
		//model은 addAttribute를 해서 데이터를 view단으로 출력해준다. 
		
		model.addAttribute("data", data);
		
		return "/WEB-INF/view/index.jsp";
	}
	

}

```


---


<br><br>
- reg.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<section>
		<h1>메뉴 등록 페이지 </h1>
		<form method="post">
			<fieldset>
				<legend>메뉴 입력 필드</legend>
				<div>
					<label>제목 : </label>
					<input type="text" name="title">
				</div>
				<div>
					<input type="submit" value="등록">
				</div>
			</fieldset>
		</form>
	</section>
	
	
	<section>
		<h1>파일 입력 필드</h1>
		<form action="/upload" method="post" enctype="multipart/form-data">
			<fieldset>
				<legend>이미지: </legend>
				<div>
					<label>이미지 : </label>
					<input type="file" name="imgs">
				</div>
				<div>
					<label>이미지 : </label>
					<input type="file" name="imgs">
				</div>
				<div>
					<input type="submit" value="등록">
				</div>
			</fieldset>
		</form>
	</section>
</body>
</html>
```

---


<br><br>
### 3) MariaDB와 Spring 연동시키기

- MySQL은 무료가 아닌 무료이다. 서비스가 재판매가 불가능하다. 평가판 정도가 가능하다.

- 그래서, MariaDB를 사용한다.

- MySQL을 설치해서 java에서 연결을 mariaDB로 사용하자.

- mariaDB를 연결하고 연결이 잘되었는지 JUnit Test를 해보자 
	- Run As에서 JUnit으로 실행해보자! 

---

<br>
- 실습 코드 요약 :


<br>

<details>
<summary>MenuRepository.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.repository;

import java.util.List;

import kr.co.rland.web.entity.Menu;

public interface MenuRepository {
	List<Menu> findAll();
}

```

</div>
</details>


<br>

<details>
<summary>JdbcMenuRepository.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.repository.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

public class JdbcMenuRepository implements MenuRepository {

	@Override
	public List<Menu> findAll() {
		String sql = String.format("select id, name, price, regDate, categoryId from menu");
		
		List<Menu> list = new ArrayList<>();

		try {
			Class.forName("org.mariadb.jdbc.Driver");
			String url = "jdbc:mariadb://db.newlecture.com:3306/rlanddb";
			Connection con = DriverManager.getConnection(url, "rland", "20220823");

			Statement st = con.createStatement();
			ResultSet rs = st.executeQuery(sql);

			// 필터링, 집계, 정렬
			while (rs.next()) // 서버의 커서를 한칸 내리고 그 위치의 레코드를 옮겨 오는 것. -> 레코드 하나가 저장되는 공간은?
			{
				long id = rs.getInt("id");
				String name = rs.getString("name");
				int price = rs.getInt("price");
				Date regDate = rs.getDate("regDate");
				int categoryId = rs.getInt("categoryId");
				
				Menu menu = new Menu(id, name, price, regDate, categoryId, 1);
				list.add(menu);
			}
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return list;
	}

}

```

</div>
</details>


<br>

<details>
<summary>Menu.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.entity;

import java.util.Date;

public class Menu {
	private long id;
	private String name;
	private int price;
	private Date regDate;
	private int categoryId;
	private long regMemberId;
	
	
	public Menu() {
	}
	
	
	public Menu(long id, String name, int price, Date regDate, int categoryId, long regMemberId) {
		this.id = id;
		this.name = name;
		this.price = price;
		this.regDate = regDate;
		this.categoryId = categoryId;
		this.regMemberId = regMemberId;
	}
	
	//insert용
	
	public Menu(String name, int price, int categoryId) {
		this.name = name;
		this.price = price;
		this.categoryId = categoryId;
	}


	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}


	public String getName() {
		return name;
	}


	public void setName(String name) {
		this.name = name;
	}


	public int getPrice() {
		return price;
	}


	public void setPrice(int price) {
		this.price = price;
	}


	public Date getRegDate() {
		return regDate;
	}


	public void setRegDate(Date regDate) {
		this.regDate = regDate;
	}


	public int getCategoryId() {
		return categoryId;
	}


	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}


	public long getRegMemberId() {
		return regMemberId;
	}


	public void setRegMemberId(long regMemberId) {
		this.regMemberId = regMemberId;
	}


	@Override
	public String toString() {
		return "Menu [id=" + id + ", name=" + name + ", price=" + price + ", regDate=" + regDate + ", categoryId="
				+ categoryId + ", regMemberId=" + regMemberId + "]";
	}
	
	
	
}

```

</div>
</details>


---

<br>

- JUnit Test 방법 :  

<br>

<details>
<summary>JdbcMenuRepository.java</summary>
<div markdown="1">
	
```java
package kr.co.rland.web.repository.jdbc;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;

import org.junit.jupiter.api.Test;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

class JdbcMenuRepositoryTest {

	@Test
	void testFindAll() {
		MenuRepository repository = new JdbcMenuRepository();
		
		// 이렇게 써주던가 assert 계열 메서드의 매크로를 사용하자! 
//		if(repositoty.findAll()==null)	
		
		List<Menu> list = repository.findAll();
		
		System.out.println(list.size());
		
	}

}

```

</div>
</details>


---

<br><br>
# 2. Spring DI - XML : 230228

- 서비스 레이어(코드를 레이어로 나눈 것)의 문제점 : 트랜잭션 처리가 힘들다. 

### 1) 트랜잭션 : 

- 논리적인 업무 단위이다.

- 물리적인 업무단위는 insert, update, delete를 의미한다. 

- 예를 들어, 계좌 이체를 물리적으로 update를 2번해야 한다. 이것을 한번에 처리해야 하므로 하나의 업무로 봐서 '트랜잭션'이라고 한다. 

- 즉, 한 번에 실행해야 할 업무 단위이다. 논리적인 명령 단위이다.

- 우리는 트랜잭션이 깨지면 처리를 해주어야 한다. 하지만, 비즈니스를 3-layer로 나누면 트랜잭션이 깨지면 처리하기 힘들다.

- 나중에 AOP 방법론으로 트랜잭션 처리가 가능하다. 


---

<br><br>

### 2) 오라클의 JDBC Template :

- 먼저, 우리는 스프링을 쓰지않고 DB와 연결하기 위해서 오라클의 JDBC Template를 이용한다.
- DB를 이용하기 위해서 사용하는 연결 정보인 dataSource를 과거에는 스프링을 이용하지 않고도 이용할 수 있었다.

<br>
- 오라클의 JDBC Template는 query 메서드를 이용하면서 query 메서드 한 줄로 아래에 있는 JDBC 기본 코드의 rs.next를 이용한 긴 while문을 대신할 수 있었다.
- 아래 예시 코드로는 JUnit test만 가능하고 톰캣을 이용한 서버는 아직 이용이 불가능하다. 


<br>

<details>
<summary>MenuRepository.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.repository;

import java.util.List;

import kr.co.rland.web.entity.Menu;

public interface MenuRepository {
	List<Menu> findAll();
}

```

</div>
</details>

<br>

<details>
<summary>JdbcMenuRepository.java</summary>
<div markdown="1">


```java

package kr.co.rland.web.repository.jdbc;

import java.util.List;

import javax.sql.DataSource;

import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

// @Component // @Component는 IOC 컨테이너에서 새로운 빈 객체를 만들어 준다. 
public class JdbcMenuRepository implements MenuRepository {

	@Override
	public List<Menu> findAll() {
		
		
		String sql = "select id, name, price, regDate, categoryId from menu";

		DataSourceBuilder dataSourceBuilder = DataSourceBuilder.create();
		dataSourceBuilder.driverClassName("org.mariadb.jdbc.Driver");
		dataSourceBuilder.url("jdbc:mariadb://db.newlecture.com:3306/rlanddb");
		dataSourceBuilder.username("rland");
		dataSourceBuilder.password("20220823");

		DataSource dataSource = dataSourceBuilder.build();

		JdbcTemplate template = new JdbcTemplate(dataSource);		
		List<Menu> list = template.query(sql, new BeanPropertyRowMapper(Menu.class)); // 메서드의 종류가 많다는 것은 좋은 신호이다.
		// query 메서드를 이용하면서 query 메서드 한 줄로 아래에 있는 JDBC 기본 코드의 rs.next를 이용한 긴 while문을 대신할 수 있었다.
		
		return list;
	}

	
	
//	@Override
//	public List<Menu> findAll() {
//		String sql = String.format("select id, name, price, regDate, categoryId from menu");
//		
//		List<Menu> list = new ArrayList<>();
//
//		try {
//			Class.forName("org.mariadb.jdbc.Driver");
//			String url = "jdbc:mariadb://db.newlecture.com:3306/rlanddb";
//			Connection con = DriverManager.getConnection(url, "rland", "20220823");
//
//			Statement st = con.createStatement();
//			ResultSet rs = st.executeQuery(sql);
//
//			// 필터링, 집계, 정렬
//			while (rs.next()) // 서버의 커서를 한칸 내리고 그 위치의 레코드를 옮겨 오는 것. -> 레코드 하나가 저장되는 공간은?
//			{
//				long id = rs.getInt("id");
//				String name = rs.getString("name");
//				int price = rs.getInt("price");
//				Date regDate = rs.getDate("regDate");
//				int categoryId = rs.getInt("categoryId");
//				
//				Menu menu = new Menu(id, name, price, regDate, categoryId, 1);
//				list.add(menu);
//			}
//			con.close();
//		} catch (Exception e) {
//			e.printStackTrace();
//		}
//		return list;
//	}

}


```

</div>
</details>


<br>

<details>
<summary>JdbcRepositoryTest.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.repository.jdbc;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;

import org.junit.jupiter.api.Test;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

class JdbcMenuRepositoryTest {

	@Test
	void testFindAll() {
		MenuRepository repository = new JdbcMenuRepository();
		
		// 이렇게 써주던가 assert 계열 메서드의 매크로를 사용하자! 
//		if(repositoty.findAll()==null)	
		
		List<Menu> list = repository.findAll();
		
		System.out.println(list.size());
		
	}

}

```

</div>
</details>


---

<br><br>
### 3) Spring DI 개념 : 230228

<br>

#### a. DI 개념 : 

<br>
- IOC 컨테이너 : 보통, 흐름을 말한다. 객체를 담았다가 뺄 때, 다른 것을 담았다가 뺄수도 있고 아닐 수도 있다. 즉, 객체에 소스를 껴서 뺄 수도 있다.

<br>
- 부품(Dependency = 의존성 = 데이터 소스)과 제품(템플릿?), 결합(Injection = 주입)

<br>
- 작은 부품들이 조립되어 큰 부품으로 만들어져 간다. 이것을 "Inversion of Control"(제어의 역전이다.)라고 말한다. 코딩이 되어가는 순서이다.
	- 이것과 반대로 일체형 제품은 큰 부품에서 점차 작은 부품으로 만들어진다. 일반적인 우리가 만드는 프로그래밍이 실행되는 순서이다.

<br>
- 우리는 조립을 해서 꺼내 쓸 수 있어야 한다. 

<br>
- 관계 : Composition 관계, Setter 결합 관계

<br>
- Dependency + Injection : 부품(`new B();`) + 결합(`setB();`)

---

<br>

#### b. Bean 개념 : 

- 자바에서 Bean 객체를 자바 객체라고 불렀었다.

<br>
- 어노테이션이 Bean 객체(콩자루)에 담겨지는 역할을 해준다! 추가로 라이브러리(mariaDB 등등)를 추가하자마자도 담긴다. 
	- 스프링 부트에 새로운 데이터 베이스가 라이브러리에 담겨질 때, 기본 설정이 담겨져 있다. 하지만, 우리가 설정을 바꾸고 싶으면 application.properties에서 추가 설정을 해주어야 한다.(우리 DB로 바꿀 때!)  

<br>
- 특정 패키지가 있는데 그것이 package명이다.

<br>
- DI의 지시서로 작성하는 방법 : XML 코드, 어노테이션 방법

---

<br>

#### c. Spring에 DI를 XML로 이용하는 방법 - Application Context : 


- 객체 지향에서 객체를 결합해주고 생성해주는 것이 필요하다. 

- 생성해주는 코드를 내 자바 코드에 넣는 것이 아니라 외부코드에서 생성해서 결합한다.

<br>
- "IOC 컨테이너가 사용하는 Context"를 "Application Context"라고 한다. 서블릿 컨텍스트는 "어플리케이션 저장소"이며 "Application Context"와는 완전 다르다. 

- Context : 작업을 하다가 다음에 계속 이어갈 수 있도록 담아두는 공간, "도구함"이라고 한다**

<br>
- ClassPathXmlApplicationContext : xml 파일이 클래스 파일과 동일 경로에 있는 경우이며 ClassPathXmlApplicationContext 이외의 다른 ApplicationContext는 다른 경로에 xml 파일을 생성하자! 
	- ClassPathXmlApplicationContext : root가 해당 개발환경이다.
	- FileSystemXmlApplicationContext : C드라이브나 등등에 위치
	- XmlWebApplicationContext : Web에 위치해있다. url 이용한다.
	- AnnotationConfigApplicationContext : Annotation으로 스캔하는 방법으로 위치해 있다.

<br>
- IOC 컨테이너가 Application 컨텍스트를 읽어서 bean 태그로 빈(컨테이너)을 생성해서 getBean을 통해서 Bean을 꺼내서 읽을 수 있다. 


<br>
- XML를 이용한 Spring DI 실습 코드 1 : 

```xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
	
	<bean class="kr.co.rland.web.repository.jdbc.JdbcMenuRepository">
	</bean>

</beans>

```

---

<br>
- XML를 이용한 Spring DI 실습 코드 2 :
	- 이 부분이 DI에서 가장 중요하다! 

```xml
<!--  	여기서 name은 아래 DefaultMenuService의 name과 연관 -->
 	<bean name="repository" class="kr.co.rland.web.repository.mybatis.MbMenuRepository" />
	
	<!-- name에는 setRepository의 ()와 set을 날려버리고 소문자로 바꿔서 넣어주고 
	// 우리가 자바 코드에서 실제로 쓰는 것은 참조형이라서 ref에 repository를 넣어준다. -->
	<bean class="kr.co.rland.web.service.DefaultMenuService">
		<property name="repository" ref="repository" />
	</bean>
```


---

<br><br>

#### d. XML을 이용한 DI의 실습 코드(중요!) : 

- xml로 DI를 하기 위해서는 Application Context 종류에 따라서 알맞은 경로에 xml 파일을 만들어준다.
- 각 계층(레이어)들을 결합해주기 위해서 빈 객체와 setter를 만들어서 결합해준다.
- 또한, 연결하고 싶은 계층(레이어)에는 setter가 있어야 xml의 bean 태그에서 property 속성을 이용하여 다른 계층(레이어)들과 결합시킬 수 있다. 
- bean 태그의 property가 실제로 동작하기 위해서는 연결하고 싶은 계층의 객체에서 setter가 있어야 property 태그가 동작한다.

<br>

<details>
<summary>application.properties</summary>
<div markdown="1">

```properties

spring.servlet.multipart.max-file-size=100MB	
#각각의 파일 용량 
spring.servlet.multipart.max-request-size=200MB 
#전체 용량

spring.datasource.url=jdbc:mariadb://db.newlecture.com:3306/rlanddb
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver
spring.datasource.username=rland
spring.datasource.password=20220823

```

</div>
</details>


<br>

<details>
<summary>Program.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.di;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.service.MenuService;

public class Program {

	
	 public static void main(String args[]) {
		 ApplicationContext context = new ClassPathXmlApplicationContext("kr/co/rland/web/di/context.xml");
		 
//		 MenuRepository menuRepository = context.getBean(MenuRepository.class);
//		 List<Menu> list = menuRepository.findAll();

		 MenuService service = context.getBean(MenuService.class);
		 List<Menu> list = service.getList();
		 
		 
		 System.out.println(list);
	 }
}


```


</div>
</details>


<br>

<details>
<summary>MenuService.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.service;

import java.util.List;

import kr.co.rland.web.entity.Menu;

public interface MenuService {
	
	// 서비스 계층에서는 사용자 요청을 이름 그대로 그대로 만들어라!!
	List<Menu> getList();	
}

```


</div>
</details>


<br>

<details>
<summary>DefaultMenuService.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.service;

import java.util.List;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

public class DefaultMenuService implements MenuService {
	
	
	private MenuRepository repository;
	

	// 객체를 만들어서 결합해준다! 
	// setter가 있어야 xml에서 bean 태그에서 property 속성을 이용할 수 있다. 
	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	@Override
	public List<Menu> getList() {
		return repository.findAll();
	}

}

```

</div>
</details>


<br>

<details>
<summary>context.xml</summary>
<div markdown="1">

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
	
<!-- 	<bean class="kr.co.rland.web.repository.jdbc.JdbcMenuRepository">
	</bean>
 -->
 
<!--  	여기서 name은 아래 DefaultMenuService의 name과 연관 -->
 	<bean name="repository" class="kr.co.rland.web.repository.mybatis.MbMenuRepository" />
	
	<!-- name에는 setRepository의 ()와 set을 날려버리고 소문자로 바꿔서 넣어주고 
	// 우리가 자바 코드에서 실제로 쓰는 것은 참조형이라서 ref에 repository를 넣어준다. -->
	<bean class="kr.co.rland.web.service.DefaultMenuService">
		<property name="repository" ref="repository" />
	</bean>

</beans>
```

</div>
</details>


<br>

<details>
<summary>Menu.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.entity;

import java.util.Date;

public class Menu {
	private long id;
	private String name;
	private int price;
	private Date regDate;
	private int categoryId;
	private long regMemberId;
	
	
	public Menu() {
	}
	
	
	public Menu(long id, String name, int price, Date regDate, int categoryId, long regMemberId) {
		this.id = id;
		this.name = name;
		this.price = price;
		this.regDate = regDate;
		this.categoryId = categoryId;
		this.regMemberId = regMemberId;
	}
	
	//insert용
	
	public Menu(String name, int price, int categoryId) {
		this.name = name;
		this.price = price;
		this.categoryId = categoryId;
	}


	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}


	public String getName() {
		return name;
	}


	public void setName(String name) {
		this.name = name;
	}


	public int getPrice() {
		return price;
	}


	public void setPrice(int price) {
		this.price = price;
	}


	public Date getRegDate() {
		return regDate;
	}


	public void setRegDate(Date regDate) {
		this.regDate = regDate;
	}


	public int getCategoryId() {
		return categoryId;
	}


	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}


	public long getRegMemberId() {
		return regMemberId;
	}


	public void setRegMemberId(long regMemberId) {
		this.regMemberId = regMemberId;
	}


	@Override
	public String toString() {
		return "Menu [id=" + id + ", name=" + name + ", price=" + price + ", regDate=" + regDate + ", categoryId="
				+ categoryId + ", regMemberId=" + regMemberId + "]";
	}
	
	
	
}

```

</div>
</details>


#### e. 어노테이션을 이용한 Spring DI 정리(간단히)

- `@Component`는 IOC 컨테이너에서 새로운 빈 객체를 만들어 준다.
	- 보통 컨트롤러나 구현된 서비스 객체나 구현된 DAO에 붙는다.

<br>
- `@Autowired`는 이렇게 생성된 빈 객체를 다른 빈 객체와 연결시켜준다.  
	- 보통 붙이고 싶은 객체 선언부나 생성자에 붙고 기본 생성자가 있을때는 setter에 붙는다.

---


<br><br>

# 3. Spring DI - Annotation : 230302



















