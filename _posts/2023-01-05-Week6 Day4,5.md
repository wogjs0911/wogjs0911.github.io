---
key: /2023/01/05/Week6-Day4,5.html
title: Week6 Day 4,5
tags: javascript canvas
---


# 1. JS (배열 뽀개기 ,Collection : Set, Map) [23.01.05] 


### 1) Array Destructring(배열 뽀개기) 


<br>
```javascript
   
    let kors =[1,2,3];   
    let[kor1,kor2,kor3] = kors;     //신기하네. let에 바로 붙여쓰네
    console.log(kor1);


    // 에러발생 : 이미 지역 변수가 있어서** 
    let kors2 = [2,3,4];
    // let[kor1,kor2,kor3] = kors2;   // 이렇게 쓰면 에러가 발생한다. 선언을 2개 해버려서..
    [kor1,kor2,kor3] = kors2;         // 따라서, 선언해주지 않는다.
    console.log(kor1);


    let std1 = {name:"dragon", phone:'010'};
    // let {name, phone} = std1;   // 에러발생!
    // {name, phone} = std1;       // 에러발생! 괄호를 묶어줘야 한다.(parenths 에러)

    ({name, phone} = std1);   // 에러를 해결하기 위해서 전체에 괄호를 묶어준다.
                              // JS를 ";"안 쓰고 줄바꾸기 위해서 완전한 문장이여야 한다. 이 문장은 불안정하다! 

    let a, b;                 // 배열을 이런식으로 넣어 줄수도 있다.
    [a, b] = kors2;           // 뽀개기된 kor2를 다시 배열([a, b])에 넣어 줄수 있다.      
    console.log(a,b);               

    a = 20;
    b = 30;
    console.log(a);
    [a,b] = [b,a];                  // 자리바꾸기.. 이게 되네...
    console.log(a);

    let korss = [10, 20, 30];
    let [kor4, kor5] = korss;
    console.log(kor4);
    console.log(kor5);

    let[,,kor6] =korss;             // 앞에는 뭐가 들어감?
    console.log(kor6);

    let numbers = [1,2,3,4,5,6,7,8,9,10];
    let [n1,n2,rest] = numbers;
    console.log(rest);              // 배열의 나머지를 요소를 출력하려면 나머지 연산자가 필요하다!! 


    let numberss = [1,2,3,4,5,6,7,8,9,10];
    let [n11,n22,...rrest] = numbers;
    console.log(rrest);                     // 나머지 연산자(...)를 사용하기, 순서도 마지막에 배치해야 한다.

```

---


<br><br>
### 2) ES6 JS의 Set 콜렉션

<br>
- Iterator : 
	- 일괄적으로 뽑아낼 때, Iterator로 뽑아낸다
	- of를 사용할 수 있으면 이터레이터이다.(반복적으로 값을 뽑아낼 때)

<br>
- Set 특징 : 
	- key가 따로 구현하지 않는다, 단독적으로 특정한 값을 꺼낼 수 없다, 
	- key가 충돌하지않아서 중복되는 값이 존재하지 않는다.
	- set.add()로 Set 콜렉션에 값을 더 한다. 	
	
<br>
```javascript

    let set = new Set();
    set.add(5);             // add로 Set에 데이터를 대입해준다.
    set.add("5");           // set은 데이터를 배열에 담는다.***
    set.add(2);
    set.add(5);

    // ** size 이용, 크기를 출력하면, 중복제거된 상태로 값이 출력
    console.log(set.size);                          // 3이 출력

    console.log(`size : ${set.size}`);

    // ** for of 이용
    for(let n of set) {  // set의 값을 하나씩 뽑아낸다.
        console.log(n);
        set.has(5)
    }

    // ** has 이용
    set.has(5)          // 5를 갖고 있는지 boolean형으로 반환 

```

---

<br>
- forEach 구문!! vs for of와 비교하기(vs for in)

<br>
```javascript
    
    // ** 
    set.forEach((v)=>{
        console.log(v);       // **** forEach로 각각의 값을 꺼내서 뽑아 쓸 때, 사용했다.
    })                                              

    set.forEach((v)=>{
        console.log(`value: ${v}`);   // forEach로 각각의 값을 직접 꺼내서 사용했다.
    })                                // for of는 Set에서 값을 뽑아낸다.
                                      // forEach는 예전 방식이라서 이런식으로도 사용한다.
                                      // 요즘에는 값을 뽑아내기 위해서 for of를 이용한다.
    // for in 문 사용!
    for(let k in set)
        console.log(k);              // 그냥 key 값은 안 나온다.(Set이라서 key가 없다.)
    
        console.log("----------------------------------------------------"); 
    
    set.forEach((v,k) => {
        console.log(`key:${k}, value:${v}`);    // key와 value 모두 같은 값으로 출력(forEach)
    });

    // ***WeekSet : 중복이 제거되었을때 확인하기 위해 사용한다.(Set에 담지 않는다.)

```

---

<br>
- Map : key, value 이용하기(이제 Object를 이용하지 않는다**)
	- 이터레이터 사용가능
	- Object는 키 값으로 문자열만 가질 수 있지만, Map은 키로 모든 데이터 타입을 가질 수 있다. Map은 순서를 보장한다.

<br>
- Map 함수 모음 **
	- keys : key들만 확인
	- values : value들만 확인
	- entries : key, value 모두 확인
	- size : 크기 확인
	- `@@` 태그 : 심볼이라서 인터페이스가 제공되지 않아서 약속에 해당하는 것
		- ex) `@@species`, `@@toStringTag`

<br>		
```javascript

    let map = new Map();
    map.set("id", 1);
    map.set("title","map이란?");

    console.log("\nforeach---------------------");
    map.forEach(function(v,k){
        console.log(`key:${k}, value:${v}`);
    });

    console.log("/foreach---------------------");

    let notice = new Map();             // 속성을 묶어서 사용할 때, 사용하며 변수에 담을 수 있다.
    notice.set("id",1);                 // 묶어서 한 번만 사용할 때, 임시형 데이터 집합을 사용할 때, Map을 사용한다.
    notice.set("title","map is ...");
    notice.set("writer", "newlec");

    console.log(notice.get("title"));   // 데이터 1개만 가져올 때, get으로 받아온다. 

    notice.forEach((v,k)=>{
        console.log(`key:${k}, value:${v}`);
    });

    for(let key of notice.keys())
        console.log(`key:${key}`);    // Set으로 꺼내진다.

    for(let v of notice.values())
        console.log(`value:${v}`);

    // for(let entry of notice.entries()){
    //     console.log()                           // 이것도 틀렸다.
    //     console.log(`key: ${entry.key}`);       // 이건 올바르지 않는 방식이다.
    //  }
    for(let [k,v] of notice.entries())            // notice.entries()가 iterator이다. notice도 iterator를 갖고 있다.*****
                                                  // entries는 iterator라서 map 타입으로 key-set을 하느냐? set 계열의 collection하느냐 이다.
        console.log(`key: ${k}, value: ${v}`);    // key: ~ , value : ~ 이런 형식으로 출력된다.

    // forEach를 안 쓰고 for of를 사용하는 이유? ES5에서 예전에 사용하던 방식이며 화살표 함수와 같이 함수를 사용해야하므로 복잡하다.  
    
```

---

<br>
- iterator 추가 개념**

```javascript
    /// **** 
    for(let [,v] of notice.entries())   // notice.entries()가 iterator이다. notice도 iterator를 갖고 있다.*****
                                        // entries는 iterator라서 map 타입으로 key-set을 하느냐? set 계열의 collection하느냐 이다.
        console.log(`value: ${v}`);     // value만 출력!!!!

    for(let [k,] of notice.entries())   // notice.entries()가 iterator이다. notice도 iterator를 갖고 있다.*****
                                        // entries는 iterator라서 map 타입으로 key-set을 하느냐? set 계열의 collection하느냐 이다.
        console.log(`key: ${k}`);       // key만 출력!!!!

    
        
    for(let n of notice)            // notice.entries()가 iterator이다. notice도 iterator를 갖고 있다.*****
                                    // entries는 iterator라서 map 타입으로 key-set을 하느냐? set 계열의 collection하느냐 이다.
        console.log(`n: ${n[1]}`);  // map의 1번째 데이터를 가져와서 출력한다.
    
```

<br>
- Object를 Map으로 바꿀 수 있는가?(map 함수 이용하기)

```javascript

    let exam3 = {
        kor:10,
        eng:20,
        math:30
    };

    // *** 에러 발생
    // for(let v of exam3)     // iterable 에러 발생
    //     console.log(v);     // 원래는 entry()에서 가져와야하는데 아니라서 에러가 발생
    //                         // 따라서, key와 value를 갖고 있는 데이터 타입을 만들어서 거기서 가져와야 한다.

    // 그래서, 나중에 Object의 static 메서드를 살펴보기****(mdn static methord 검색하기)
    for(let [k,v] of Object.entries(exam3))
        console.log(`key: ${k}, value: ${v}`);
```

---

- forEach 개념(map 함수와 비교하기 `!=` Map 컬렉션)

<br>
```javascript

    let list = [
        {id:1, title:"jsp is...", writerId:"newlec"},
        {id:2, title:"servlet is...", writerId:"newlec"},
        {id:3, title:"javascript is...", writerId:"newlec"},
        {id:4, title:"spring is...", writerId:"newlec"}
    ]

    list.forEach((n)=>{});  // forEach의 원래 개념

    // *** map 함수 개념 (Map 콜렉션이 아니다!****) : 매핑시켜주는 것!!
    // map 함수는 변환할 때, 좋은 도구이다.
    // list라는 변수의 배열 데이터 타입을 n이라는 Object 타입으로 변경해준다.
    // 화살표 함수에 의해 list라는 배열 타입의 변수를 map 함수에 의해 n이라는 Object 타입으로 변경하고
    // n에 담아서 return으로 n의 속성을 반환한다. 
    let ar = list.map((n)=> {return `<span>${n.title}</span>`});
        console.log(ar);

```

---

<br><br>
### 2) Game project

- this.dom.onclick = this.clickHandler.bind(this)의 부분 공부하기

```javascript
// game-canvs.js는 사용자 입력과 출력을 담당한다.(중요!!) *****

class GameCanvas {        // 클래스로 변경  

    constructor(){                                          // **** 중요한 개념 : 
        this.dom = document.querySelector(".game-canvas");  // 여기서 this는 GameCanvas의 new된 결과이다.
                                                            // dom이 canvas이다. canvas가 this의 멤버로 들어온 것이다.
                                                            // 원래 java에서는 canvas가 canvas를 갖는 것이 이상하다. 
                                                            // 그래서, JS는 틀로 쓸 수 있는 것이 아니다.(프레임워크가 아니였다.)

                                                            // 앞으로는 this의 dom 기능을 이용한다.
    
        /** @type {CanvasRenderingContext2D} */ 
        
        this.ctx = this.dom.getContext('2d');   // var ctx가 아니라 this.ctx이다.(Boy의 ctx이므로)         
        
        this.boy = new Boy(100, 100);

        this.gameover = false;      // setTime을 위한 상태값!!****, 게임 오버는 아니고 애니메이션만 
                                    // 멈추게 해야 한다. 즉, 멈추면 상태값이 전부 날아가는 것이 
                                    // 아니라 정지인 상태이다.(배경과 적들은 움직임)

        this.pause = false;         // 그래서, 게임이 끝나는 것이 아니라 일시정지가 되어야 한다.
        


        // **** 다른 애가 불러내서 위임되는 함수라고 부르며 "call back function"이라고 부른다. 
        // 사용자가 클릭해달라고 위임했기 때문이다. call back function은 지금 실행하는 것이 아니라 나중에 실행된다.(위임해야지 나중에 전화할 수 있기 때문이다.(나중에 실행))
        // 전화하는 애가 주체가 된다. 
        // dom이 다시 호출해준다? 
        // this.dom.onclick = this.clickHandler;                   // ()처럼 함수를 호출한 결과 값 넣지 말기

        this.dom.onclick = this.clickHandler.bind(this);          // **** .bind() 처리하면서 .bind(this)의 this는 이벤트 핸들러를 위한 객체를 불러온다. 원래 this는 gamecanvas이다.
    }                                                            
                                                                  // **** 내장 객체의 함수와 새로만들어 지는 객체의 함수를 비교할 것.
                                                                  // clickHandler는 사용자 입력에 의한 이벤트 핸들러이기 때문에
                                                                  //  window에서 가져와야 해서 .bind(this)를 뒤에 붙여준다.
    

            // 이렇게 사용하면 위의 코드와 비교해서 dom은 이전의 생성자에서 넘겨받아서 this가 dom이 아니다.
            //console.log(this)


    run(){
        if(this.pause)
            return;

        // 60 프레임으로 화면을 다시 그리는 코드!!
        this.update();
        this.draw();

        // // 게임 만들 때, 심박동을 위해서 setTimeOut, setInterval, AnimationFrame 심박동을 우리가 맞출 수 없다.(조정이 불가능)
        // // setTimeOut - 1회성, setInterval - 반복성, AnimationFrame - 프레임 1초에 60회로 고정
        // window.setTimeout(function(){
        //     console.log("time out");    
        // },1000);


        // // this를 알게 하기 위해서 호출하는 주체를 봐야 한다.
        // window.setTimeout(function(){
        //     this.run().bind(this);      // 여기서 함수를 호출하는 것이 window라고 앞에 적혀 있어서    
        // },1000);                        // 그래서 우리는 여기 있는 run을 실행하기 위해서 bind를 사용한다!!

        // // ************ ES6 함수 정의 방법 : Arrow Function ************
        // // 자기 this가 없으니까 밖의 this를 사용한다. (자기만의 영역이 없다. 지역화가 없다.)
        // // 자기만의 this가 없어서 bind를 사용하지 않는다.****  
        // window.setTimeout(()=>{
        //     this.run();    
        // },1000);

        window.setTimeout(()=>{                 // 알람 맞추는 것과 같다.(60 프레임에 맞추어서 = 1000/60 = 17)
            this.run();    
        },17);

        // 여기까지 하면, 무한히 반복한다. 멈추고 싶으면? 이 안에서 멈추는 도구가 필요하다. 그래서 상태변수가 필요하다.

    }

        // canvas는 UI이고 UI에 의해서 꼭두각시처럼 컨트롤된다.

    update(){   // update는 단위 계수마다 잘게 쪼개서 움직여야 한다.
                // 시간에 국한에서 잘게 짜르려면 frame을 나누어야 한다. 
                // 이동하는 속도가 일정하려면, 

        this.boy.update();              // 이동하고 
    }
    
    draw(){
        this.boy.draw(this.ctx);        // 다시 그리고
    
    }

    pause(){
        
    }
    
    // ------------------------------- event handler***** --------------------------------
    // 이벤트가 발생했다!! 사용자 입력에 의해서 이벤트가 발생 // 사건의 구체적인 정보를 알아야내 한다.(어떤 위치에 마우스를 클릭했는지, 어떤 키보드를 눌렀는지)

    clickHandler(e){         // 클릭하면, 타이머가 멈춘다!!
        //this.pause = true; // 같은 함수 내부라서 함수 호출 시, 
                             // 함수를 사용하는 것이 아니라 값을 입력해준다.

        // this.boy.move(2);    // 마우스로 move하는 것은 옳지 않고 방향키로 나중에 구현할 것
                                // 마우스는 사용자 입력이다.
        
        // ** 상태 변수를 이용                        
        this.boy.moveTo(e.x,e.y);   // 이동할 때, 대각선 길이를 잘게 쪼개는데 가로 세로는 그 값이 얼마였든지간에 비율로 대각선 길이로 나눈다.
                                    // 나중에 배우자! 이벤트 함수 : screen x, event x, osell x


        // 화면 지우기
    
        this.boy.draw(this.ctx);    // 함수 호출자는 dom이다. 하지만, 우리는 this가 GameCanvas였으면 좋겠다. 서로 역할이 엇갈림.
                                    // 그래서 우리는 보따리를 쌓아 줘야한다.(위에서 bind로 묶어줌.) *******
    
    
        console.log(this);      // 위의 dom이 앞에서 위임받아서 dom이 아니라 이전 생성자이다.
        }
            
}


```

---



