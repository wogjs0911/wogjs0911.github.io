---
key: /2023/07/18/CodeTest3.html
title: Test - Programmers2
tags: java
---

# 1. Lv.2

- 33문제 풀기 : 
	- 정답률 높은 순서
	- 약 3만명 이상 푼 문제부터 풀고 Kakao 문제는 거의 다 풀기 
	- 문제 당, 최대 2시간 고민 
	
<br>

### 1) [최댓값과 최솟값](https://school.programmers.co.kr/learn/courses/30/lessons/12939)

- compareTo는 문자열 정렬 시, 사용! ** 

```java

import java.util.*;

class Solution {
    public String solution(String s) {
        String[] sp = s.split(" ");
        String answer = "";
        int[] num = new int[sp.length];
        
        for(int i = 0; i < sp.length; i++){
            num[i] = Integer.parseInt(sp[i]);
        }
        
        Arrays.sort(num);
        
        for(int i = 0; i < num.length; i++){
            answer = num[0] + " " + num[sp.length-1];
        }
       
        // ** compareTo는 문자열 정렬시, 사용! ** 
        // Arrays.sort(sp, (o1,o2) -> (o1).compareTo(o2));
    
        // for(int i = 0; i < sp.length; i++){
        //     answer = sp[0] + " " + sp[sp.length-1];
        // }
       
        return answer;
    }
}

```

---

<br><br>

### 2) [JadenCase 문자열 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12951)

- 테케 8번만 실패, 연속된 공백 어떻게 없앨까? 
	- 다시 풀기! 

```java
import java.util.*;

class Solution {
    public String solution(String s) {
        String[] sp = s.split(" ");
        String answer = "";
        List<String> ls = new ArrayList<>();
        
        for(int i = 0; i < sp.length; i++){
            ls.add(sp[i]);
        }
        
        for(int i = 0; i < sp.length; i++){
            if(ls.get(i).equals(" "))
                ls.remove(i--);
                
            String[] s1 = ls.get(i).split("");
            
            s1[0] = s1[0].toUpperCase();
            
             for(int j = 0; j < s1.length; j++){
                if(j != 0)
                    s1[j] = s1[j].toLowerCase();
            
                answer += s1[j];
             }
            
            if(i != sp.length - 1)
                answer += " ";
        }
        return answer;
    }
}
```



---

<br><br>

### 3) [올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)

- 첫 번째 코드 :
	- 테스트 전부 통과하지만, 시간 초과
	- 수정하기

```java
class Solution {
    boolean solution(String s) {
        
        String[] sp = s.split("");
        boolean count1 = true;
        
        boolean answer = true;
        
        for(int i = 0; i < sp.length; i++){
            if(sp[i].equals("("))
                count1 = true;
            
            else if(sp[i].equals(")"))
                count1 = false;
        }
        
        if(count1 == false)
            answer = true;
        else
            answer = false;
        

        return answer;
    }
}
```

---

- 두 번째 코드 :
	- 반환 타입이 boolean이라서 false로 반환하기!
	- return 0보다는 return false를 더 많이 사용할 것!

```java
import java.util.*;

class Solution {
    boolean solution(String s) {
        
        // String[] sp = s.split("");
        boolean check = true;
        boolean answer = true;
        int cnt = 0;
        
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '('){
                check = true;
                cnt++;
            }

            else if(s.charAt(i) == ')'){
                check = false;
                cnt--;
            }
            
            // 반환 타입이 boolean이라서 false로 반환하기!
            if(cnt < 0)
                return false;
            
        }
        
        if(cnt != 0)
            answer = false;
        else
            answer = true;
        

        return answer;
    }
}
```

---

<br><br>

### 4) [최솟값 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12941)

- 첫번째 풀이 : 수정하기. 절반만 맞았다. 

```java

import java.util.*;


class Solution
{
    public int solution(int[] A, int[] B)
    {
        int answer = 0;
        List<Integer> list1 = new ArrayList<Integer>();    
        List<Integer> list2 = new ArrayList<Integer>();    
        
        for(int i = 0; i < A.length; i++){
            list1.add(A[i]);    
        }
        Collections.sort(list1);
        
        for(int i = 0; i < B.length; i++){
            list2.add(B[i]);
        }
        Collections.sort(list2);
        
        for(int i = 0; i < list1.size(); i++){
            for(int j = list2.size()-1; j >= 0; j--){
                int temp = list1.get(i) * list2.get(j);
                answer += temp;
            }
        }
        return answer;
    }
}
```

---

<br>

- 두번째 풀이 : 탐색할 때, 어떻게 동작할지 동작 과정 생각하기!
	- 중요!

```java
import java.util.*;


class Solution
{
    public int solution(int[] A, int[] B)
    {
        int answer = 0;
        List<Integer> list1 = new ArrayList<Integer>();    
        List<Integer> list2 = new ArrayList<Integer>();    
        
        for(int i = 0; i < A.length; i++){
            list1.add(A[i]);    
        }
        Collections.sort(list1);
        
        for(int i = 0; i < B.length; i++){
            list2.add(B[i]);
        }
        Collections.sort(list2);
        
        int j = list2.size()-1;
        
        for(int i = 0; i < list1.size(); i++){
            for(; j >= 0; j--){
                int temp = list1.get(i) * list2.get(j);
                answer += temp;
                break;
            }
            j--;
 
        }
        return answer;
    }
}
```

---

<br><br>

### 5) [피보나치 수**](https://school.programmers.co.kr/learn/courses/30/lessons/12945)

- 첫번째 풀이 : 테케 절반만 통과함. 수정하기!

```java
class Solution {
    public int solution(int n) {
        int answer = 0;
        int[] temp = new int[n+1];
        
        temp[0] = 0;
        temp[1] = 1;
        
        for(int i = 0; i < temp.length-2; i++){   
            temp[i+2] = temp[i] + temp[i+1];
            answer = temp[i+2];
        }
        answer = answer % 1234567;
        
        return answer;
    }
}

```


<br>

- 두 번째 풀이 : 
	- DP 개념 이용! 중요!**

```java
class Solution {
    public int solution(int n) {
        int answer = 0;
        int[] temp = new int[n+1];
        
        temp[0] = 0;
        temp[1] = 1;
        
        // 더 쉬운 풀이! : DP 개념 이용!
        for(int i = 2; i < temp.length; i++){   
            temp[i] = (temp[i-1] + temp[i-2]) % 1234567;
        }
         
        return temp[n];
    }
}
```

---

<br><br>

### 6) [카펫**](https://school.programmers.co.kr/learn/courses/30/lessons/42842?language=java)

- 다시 풀기 : 생각하는 것이 까다롭다.

<br>

- 첫 번째 풀이 : 다시 풀기! 76점 수준
	- 중간에 계산이 안맞는 경우가 있다. 이전 조합을 사용해야 할듯('-1' 하기) 
	- 예) 가로/ 세로 : 6/4 -> 8/3 
	- 따라서, (가로길이 - 2) * (세로길이 - 2) == yellow 조건 고려하기!
		- yellow 계산이 안 맞을 수도 

```java
import java.util.*;

class Solution {
    public int[] solution(int brown, int yellow) {
        
        int sum = brown + yellow;
        List<Integer> list = new ArrayList<>();
        int[] answer = new int[2];
        
        for(int i = 0; i < sum; i++){
            if(sum % (i+1) == 0){
                list.add(i+1);
            }
        }
        
        for(int i = 0; i < 2; i++){
            if(list.size() % 2 != 0)
                answer[i] += list.get(list.size()/2);
            else{
                    answer[i] += list.get(list.size()/2-i);
                }
        }
        
              
        return answer;
    }
}
```


---

<br>

- 두 번째 풀이 : 
	- 등호 조건 주의, 그림을 직접 그려보면서 패턴을 정의해야 한다.

```java
import java.util.*;

class Solution {
    public int[] solution(int brown, int yellow) {
        
        int sum = brown + yellow;
        int[] answer = new int[2];
        
        for(int i = 3; i < sum; i++){
            int j = sum / i;
            
            if((sum % i == 0) && j >= 3){
                int col = Math.max(i, j);
                int row = Math.min(i, j);
                
                if(yellow == ((col -2) * (row -2))){
                    answer[0] = col;
                    answer[1] = row;
                }
            }
        }
        
              
        return answer;
    }
}
```



---

<br><br>

### 7) [구명보트**](https://school.programmers.co.kr/learn/courses/30/lessons/42885#)


- 첫 번째 풀이 : 다시 풀기! 테케 2개 중 1개만 통과

```java

import java.util.*;

class Solution {
    public int solution(int[] people, int limit) {
        
        int answer = 0;
        int temp = limit;
        int sub = 0;
        Arrays.sort(people);
        
        for(int i = people.length-1; i >= 0; i--){
            sub = temp / people[i];  // 50 / 50 = 1
            
            for(int j = 0; j < people.length-1-i; j++){
                if(((sub-1) * people[j]) == people[j]){
                    answer++;
                    break;
                }
                
                sub = ((sub-1) * people[j]) % people[j];
                
                if(sub == 0){
                    answer++;
                    break;
                }
            }
            
        }
        return answer;
    }
}
```


---

<br>

- 두 번째 풀이** : 
	- 투 포인트로 찍어서 문제 풀이해보기!(그리디이긴 하지만 투포인터 이용) 
	- sum하고 limit 차이점이 중요!

```java
import java.util.*;

class Solution {
    public int solution(int[] people, int limit) {
        
        int answer = 0;
        int sum = 0;
        int min = 0;
        
        Arrays.sort(people);
        
        for(int max = people.length-1; max >= min; max--){
            sum = people[max] + people[min];
            if(sum <= limit){
                min++;
            }
            answer++;
        }
        return answer;
    }
}
```


---

<br><br>

### 8) [H-Index*](https://school.programmers.co.kr/learn/courses/30/lessons/42747)


- 첫 번째 풀이 : 테케는 통과지만 실행 시, 모든 테스트에서 에러 발생 


```java
import java.util.*;

class Solution {
    public int solution(int[] citations) {
        int answer = 0;
        int[] temp = new int[citations.length];
        int[] count = new int[citations.length];
        
        Arrays.sort(citations);        
        
        for(int i = 0; i < citations.length; i++) {
            temp[i] = citations[citations.length - i - 1];
        }
        
        // 순회하면서 특정 값 비교하여 카운트하고 카운트가 전체 개수의 절반 이상일 때, 정답!
        for(int i = 0; i < citations.length; i++) {
            for(int j = 0; j < citations.length; j++) {
                if(citations[j] >= temp[i]) {
                    count[i]++;
                }
            }
        }
        
        for(int i = 0; i < count.length; i++) {
            if(count[i] > (count.length/2)){
                answer = temp[i]; 
                break;
            }
        }
        
        return answer;
    }
}
```

<br>
- 두 번째 풀이 : 문제 설명이 부족하지만, 예를 들어, [7,7,7,7,3]인 경우에 
	- H-Index는 4가 출력되어야하므로 citations에 포함되지 않는 경우도 고려해야 한다.
	- 기존 코드에서 조건문만 수정하기. 항상 정답이 citations나 temp에 있는 것이 아니다!

```java
import java.util.*;

class Solution {
    public int solution(int[] citations) {
        int answer = 0;
        int[] temp = new int[citations.length];
        int[] count = new int[citations.length];
        
        Arrays.sort(citations);        
        
        for(int i = 0; i < citations.length; i++) {
            temp[i] = citations[citations.length - i - 1];
        }
        
        // 순회하면서 특정 값 비교하여 카운트하고 카운트가 전체 개수의 절반 이상일 때, 정답!
        for(int i = 0; i < citations.length; i++) {
            for(int j = 0; j < citations.length; j++) {
                if(citations[j] >= temp[i]) {
                    count[i]++;
                }
            }
        }
        
        // 항상 정답이 citations나 temp에 있는 것이 아니다!
        for(int i = 0; i < count.length; i++) {
            if(temp[i] >= count[i]){
                answer = count[i]; 
            }
        }
        
        return answer;
    }
}
```
---

<br><br>

### 9) [1차 - 캐시](https://school.programmers.co.kr/learn/courses/30/lessons/17680)

- 첫 번째 풀이 : 어렵다.. LRU 알고리즘 구현하는 방법? 

```java
import java.util.*;

class Solution {
    public int solution(int cacheSize, String[] cities) {
        int answer = 0;
        
        // LinkedList 사용하거나 Queue 사용할 듯 
        List<String> city = new ArrayList<>();
        int temp = 0; 
        
        for(int i = 0; i < cities.length; i++){
            
            
            if(i % 3 == cacheSize-1){
                if(city.contains(cities[i])){
                    temp = i;
                    answer = answer + 5;
                    city.remove(0);
                }
            }
            city.add(cities[i]);
            answer++;
        }
        
        return answer;
    }
}
```

---

<br>

- 두 번째 풀이 : 

```java

```


---

<br><br>

### 10) [의상**](https://school.programmers.co.kr/learn/courses/30/lessons/42578?language=java)

- 첫 번째 풀이 : 완전탐색 불가능

```java
import java.util.*;

class Solution {
    public int solution(String[][] clothes) {
        int answer = 0;
        int count = 0;
        Map<String, String> hashMap = new HashMap<String, String>();
        
        for(int i = 0; i < clothes.length; i++){
            hashMap.put(clothes[i][0], clothes[i][1]);
        }
        for(int i = 0; i < hashMap.size(); i++){
            for(int j = 0; j < hashMap.size(); j++){
                if(hashMap.get(clothes[i][0]) != "face"){
                    if(hashMap.get(clothes[i][0]) != clothes[j][1]){
                        count++;
                        break;
                    }
                }
                else{
                    break;
                }
            }
            break;
        }
        System.out.println(count);
        for(int i = 0; i < hashMap.size(); i++){
            for(int j = 0; j < hashMap.size(); j++){
                if(count == 0){
                    if(hashMap.get(clothes[i][0]) == clothes[i][1]){
                        answer++;
                    }
                }
                else{
                    if(hashMap.get(clothes[i][0]) != "face"){
                        if(hashMap.get(clothes[i][0]) == clothes[j][1]){
                            answer += Math.pow(hashMap.size()- count , (hashMap.size() - count));
                        }
                        else{
                            answer++;
                        }
                    }
                }
            }
        }
        
        return answer;
    }
}
```

---

<br>
- 두 번째 풀이** : stream API 공부하기!!
	- stream API : test.stream().reduce(1, (a,b) -> a*b)
		- stream의 reduce는 초기값을 '1'로 설정할 수 있고 스트림의 모든 요소를 반복적으로 처리할 수 있다.
		- 옷 종류에 관한 경우의 수를 정리해서 Map 형식으로 다시 매핑해서 카운팅한다.
		- 이 경우에는 옷을 안입는 경우의 수를 모두 하나씩 더하고 나서 마지막에 모두 안 입는 경우를 1개 뺀다.(적어도 한가지 정도는 입어야하니까)
		- 이펙티브 자바 공부하기!!**

```java
import java.util.*;

class Solution {
    public int solution(String[][] clothes) {
        int answer = 0;
        Map<String, Integer> hashMap = new HashMap<String, Integer>();
        
        for(int i = 0; i<clothes.length; i++){
            hashMap.put(clothes[i][1], hashMap.getOrDefault(clothes[i][1],1) + 1);
        }
        
        Collection<Integer> test = hashMap.values();
        answer = test.stream().reduce(1, (a,b) -> a*b) - 1;
        // (a, b)를 "(a+1) * (b+1) - 1" 로 풀기 
        // 이것은 옷을 안입는 경우의 수를 모두 하나씩 더하고 나서 마지막에 모두 안입는 경우를 1개 뺀다.
        // 적어도 한가지 정도는 입어야하니까
         
        return answer;
    }
}
```



---

<br><br>

### 11) [기능개발**](https://school.programmers.co.kr/learn/courses/30/lessons/42586?language=java)

- 첫 번째 풀이 : 테케 모두 통과하지만, 런타임 에러 발생!
	- Iterator의 iterator.hasNext() 사용에서 런타임 에러 발생한듯!

```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        
        int[] temp = new int[speeds.length];
        
        Queue<Integer> queue1 = new LinkedList<Integer>();
        Queue<Integer> queue2 = new LinkedList<Integer>();
        
        for(int prog : progresses){
            queue1.add(100 - prog);
        }
        for(int i = 0; i < speeds.length; i++){
       
            int temp2 = queue1.poll();
            int temp3 = temp2 / speeds[i];
            
            if(temp2 % speeds[i] != 0){
                queue2.add(temp3+1);
            }
            else{
                queue2.add(temp3);
            }
            
        }
        
        int count = 1;
        // 주의** : Queue는 poll하면 remove되기 때문에 for문에서 index가 사라진다.
        // 그래서 Iterator 이용하기!!
        
            Iterator iter = queue2.iterator();
            Iterator iter2 = queue2.iterator();
        
            int temp4 = (int) iter.next();
            int i = 0;
            int count2 = 1;
        
            int temp6 = (int) iter2.next();
        
            while(iter2.hasNext()){
                int temp7 = (int) iter2.next();
                
                if(temp7 > temp6){
                    count2++;
                }
            }
        
            int[] answer = new int[count2];
        
            while(iter.hasNext()){
               
               int temp5 = (int) iter.next();
                
                if(temp4 > temp5){
                    count++;
                }
                else{
                    temp4 = temp5;
                    System.out.println(temp4);
                    answer[i] = count;
                    i++;
                    count = 1;
                    
                    if(!iter.hasNext()){
                      answer[i] = 1;
                    }
                }
                
                if(!iter.hasNext()){
                    answer[i] = count;
                }
                
            }
            
        
        return answer;
    }
}
```

---

<br><br>
- 두 번째 풀이 ; Iterator 빼고 Queue로만 다시 풀기
	- 위와 로직이 같지만, queue의 peek(), poll() 이용하기!


```java

import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {

        ArrayList<Integer> list = new ArrayList<>();
        Queue<Integer> q = new LinkedList<>();

        for (int i = 0; i < progresses.length; i++) {
            if ((100 - progresses[i]) % speeds[i] == 0) {
                q.add((100 - progresses[i]) / speeds[i]);
            } else {
                q.add((100 - progresses[i]) / speeds[i] + 1);
            }
        }

        int x = q.poll();
        int count = 1;
        while (!q.isEmpty()) {
            if (x >= q.peek()) {
                count++;
                q.poll();
            } else {
                list.add(count);
                count = 1;
                x = q.poll();
            }
        }
        list.add(count);

        int[] answer = new int[list.size()];
        for (int i = 0; i < answer.length; i++) {
            answer[i] = list.get(i);
        }


        return answer;
    }
}
```