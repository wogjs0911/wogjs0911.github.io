---
key: /2023/02/11/Operating-System.html
title: CS - 운영체제
tags: OS
---

# 1. Intro

### 1) 요약 :
- 운영체제 개요
- 컴퓨터 시스템의 구조
- 프로세스 관리
- CPU 스케줄링
- 병행 제어
- 데드락
- 메모리 관리
- 가상 메모리
- 파일 시스템
- 입출력 시스템
- 디스크 관리

---

<br>
### 2) 운영체제란 무엇인가?

#### a. 운영체제란? :
- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층


#### b. 하드웨어와의 인터페이스
- 사용자 및 각종 소프트웨어와의 인터페이스 : 컴퓨터를 편리하게 사용할수 있는 환경을 제공한다.

#### c. 운영체제의 목표
- 운영체제는 동시사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공한다.
- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대신 해준다. 
- 컴퓨터 시스템의 자원을 효율적으로 관리 → 자원관리자
- 프로세서, 기억장치, 입출력 장치 등의 효율적 관리해준다.


---

<br><br>
# 2. Introduction to Operating Systems

### 1)  운영체제란 무엇인가?

#### a. 운영체제란?

- 협의의 운영체제(커널) - 대부분의 전공자 입장에서 개념
	- 운영체제의 핵심 부분으로 메모리에 상주하는 부분

- 광의의 운영체제 :
	- 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념

<br>
#### b. 운영체제의 목적
- 컴퓨터 시스템을 편리하게 사용할 수 있게 해준다.
- 운영체제는 동시 사용자/ 프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환경을 제공(실제로는 아니다.)
- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
- 컴퓨터 시스템의 자원을 효율적으로 관리
- 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
- 사용자간의 형평성 있는 자원 분배
- 주어진 자원으로 최대한의 성능 도출
- 사용자 및 운영체제 자신의 보호
- 프로세스, 파일, 메시지 등을 관리

---

<br><br>
### 2) 운영체제의 분류

#### a. 동시작업 가능여부에 따른 분류

- 단일 작업(single tasking)
	- 한번에 하나의 작업만 처리
	- MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음

- 다중 작업(multi tasking)
	- 동시에 두개 이상의 작업 처리
	- UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

<br>
#### b. 사용자의 수에 따른 분류

- 단일 사용자(single user)
	- MS-DOS, MS Windows

- 다중 사용자(multi user)
	- UNIX, NT server

<br>
#### c. 처리 방식에 따른 분류

- 일괄 처리(Batch Processing)
	- 작업 요청의 일정량을 모아서 한꺼번에 처리
	- 작업이 완전 종료될 때까지 기다려야함
	- ex) Punch Card(천공카드) 처리 시스템

 <br>
- 시분할(Time Sharing)
	- 여러 작업을 수행할 때 컴퓨터 처리능력을 일정한 시간 단위로 분할하여 사용
	- 일괄 처리 시스템에 비해 짧은 응답시간을 가짐(e.g UNIX)
	- Interactive한 방식
	- 정확한 대기시간이 정해져 있지는 않음
	- ex) 일반적으로 우리가 사용하는 OS들(iOS, Window, Android)

<br>
- 실시간(Realtime OS)
	- 보통 특수한 목적을 가진 시스템에서 사용된다.
	- 정해진 시간 안에 어떠한 일이 반드시 종료됨이(Deadline 보장) 보장되어야 하는 실시간 시스템을 위한 OS
	- ex) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로봇 제어

<br>
- 실시간 시스템의 개념 확장
	- Hard Realtime System(경성 실시간 시스템) - 위의 예에 해당되는 시스템들
	- Soft Realtime System(연성 실시간 시스템) - 중단되도 중대한 문제가 발생하지 않는 영상 재생프로그램과 같은 시스템에도 적용가능
		- 요즘 운영체제는 대부분 다중작업, 사용자를 지원하고, 시분할 방식이다.

---

<br><br>
### 3) 몇가지 용어

- Multitasking
	- 여러 작업이 동시에 실행되는 것 처럼 보이는 것

- Multiprogramming
	- 메모리에 여러 프로그램이 동시에 올라가 있음을 강조

- Time sharing
	- CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조

- Multiprocess
	- 여러 작업이 동시에 수행될 수 있다는 의미

- 위 4개의 용어들은 비슷한 의미로 혼용된다.

<br>
- Multiprocessor
	- Multiprocessor는 하나의 컴퓨터에 CPU가 여러개 붙어있음을 의미하는 것이기에 위 용어들과는 구분이 필요(e.g. 고성능 컴퓨터)


---

<br><br>
### 4) 운영체제의 예

<br>
- UNIX
	- 대형 컴퓨터를 위한 운영체제로 시작
	- 코드의 대부분이 C언어로 작성(운영체제, 시스템소프트웨어를 만들기 위해 C언어가 만들어짐)
	- 높은 이식성(Portability) → 전혀 다른 기계어로 작동하는 컴퓨터로 옮길 수 있음
	- 최소한의 커널 구조
	- 복잡한 시스템에 맞게 확장 용이
	- 소스코드 공개(학술적으로 사용하기 용이)**
	- 프로그램 개발에 용이

<br>
- 다양한 버전으로 발전 : 
	- System V, FreeBSD(버클리), SunOS, Solaris
	- Linux(공개 소프트웨어) - 대형 컴퓨터를 위한 것이라고는 하기 어렵다. 여러 환경에서 사용할 수 있게 해주었다. e.g. Android

---

<br>
- DOS(Disk Operating System)
	- 개인용 컴퓨터를 위한 운영체제로 시작
	- MS에서 1981년 IBM PC를 위해 개발
	- 단일 사용자용 운영체제, 메모리 관리능력의 한계(주 기억장치: 640KB)
	- 하지만, 발전속도가 빨라져서 다른 방법이 필요했다. 

<br>
- MS Windows
	- MS사의 다중작업용 GUI 기반 운영체제
	- Plug and Play, 네트워크 환경 강화
	- 불안정성(초창기)
	- 풍부한 지원 소프트웨어
	- Handheld device를 위한 OS
	- PalmOS, Pocket PC(WinCE), Tiny OS

---

<br><br>
### 5) 운영체제의 구조**

- CPU
	- CPU 스케쥴링: 누구한테 CPU를 줄까?의 논리이다. 
	- 먼저 온 사람에게 먼저 권한을 주는 것은 굉장히 비효율적인 논리도 있다. 
	- 결론적인 논리는 CPU를 짧게 시간을 나누어 부분적으로 사용한다.

- 메모리
	- 메모리 관리: 한정된 메모리를 어떻게 분배하지?
	- Working Set 모델? : 집중되는 모델에게 집중해주고 나머지는 디스크를 쫒아 내버린다. 업무가 끝나면 쫒아낸 모델을 다시 불러온다. 
	- 과거의 메모리 관련 데이터와 비교해서 관리하는 경우도 있다.(미래를 예측하는 방법, 친구가 도둑인가?하는 판단)

- 디스크
	- 파일 관리: 디스크에 파일을 어떻게 보관하지?
	- 디스크도 스케쥴링도 필요하다. 헤드가 있어서 먼저들어온것이 먼저 업무를 처리하지 않는다.
	- 어떻게 헤드를 가장 덜 움직이면서 빠르게 효율적으로 업무 처리를 하는 것이 관건이다. 

- 입/출력장치(I/O 디바이스)
	- 입출력 관리: 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고받게 하지?
	- 이것이 속도가 굉장히 느리기 때문에 인터런트를 통해서 관리를 하고 있다.
	- CPU가 방해받지 않도록 인터럽트를 걸어서 업무 처리해준다.

- 프로세스 관리 :
	- 프로세스의 생성과 삭제
	- 자원 할당 및 반환
	- 프로세스 간 협력

- 그 외
	- 보호 시스템
	- 네트워킹
	- 명령어 해석기(command line interpreter)


---

<br><br>
### 6) 운영체제 과목의 수강 태도
- 내가 '운영체제'라고 생각하고 수업을 듣기!
- OS사용자 관점이 아니라 OS 개발자 관점에서 수강해야 함
- 대부분의 알고리즘은 OS프로그램 자체의 내용
- 인간의 신체가 뇌의 통제를 받듯 컴퓨터 하드웨어는 운영체제의 통제를 받으며 그 운영체제는 사람이 프로그래밍 하는 것이다.
- 내가 운영체제라고 생각하고 할 일이 무엇인지를 생각해 보면 이번 배울 내용이 무엇인지 명확히 알 수 있다.

---

<br><br>
# 3. System Structure & Program Execution 1

<br>
### 1) 컴퓨터 시스템 구조

- CPU가 매 클럭 사이클마다 메모리에 있는 기계어(4바이트정도의 인스트럭션)를 하나씩 처리
- CPU는 프로그램 카운터가 가리키고 있는 메모리주소를 계속 읽는역할만 함
- 하드디스크는 보조기억장치면서 I/O 디바이스의 역할도 동시에 수행한다.
- 보통 CPU는 메모리랑만 이야기하지만 I/O랑 이야기할수도(이때 사용되는게 device controller)

<br>
#### a. Mode Bit - 이 프로그램이 운영체제인지 어떤사용자프로그램인지?
- Register - 메모리보다 빠른 공간
- Interrupt line - CPU가 라인 하나를 실행할 때마다 Interrupt가 있는지를 체크
- timer - 특정 프로그램의 CPU의 독점을 막는 역할(시간이 끝나면 interrupt를 검 - CPU가 인스터럭션을 실행하다가 interrupt line을 점검해서 interrupt가 있을때)

- 사용자 프로그램이 I/O 와 직접 소통할수는 없다. 운영체제를 통해서 해야함
 
<br>
#### b. Mode bit
- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode bit을 통해 하드웨어적으로 두가지 모드의 operation 지원

<br>
- 1 사용자 모드: 사용자 프로그램 수행
- 0 모니터 모드: OS 코드 수행
	- 보안을 해칠 수 있는 중요한 명령어는 모니터모드에서만 수행 가능한 ‘특권명령'으로 규정 → Instruction set을 나눠놓았다?
	- Interrupt나 Exception 발생 시 하드웨어가 mode bit을 0으로 바꿈
	- 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅


---

<br><br>
### 2) Timer
- 사용자 프로그램에게 CPU 제어권을 넘긴 후, 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
- 타이머는 매 클럭 틱 때마다 1씩 감소
- 타이머 값이 0이 되면 타이머 인터럽트 발생
- CPU를 특정 프로그램이 독점하는 것으로부터 보호 → 타이머는 time sharing을 구현하기 위해 널리 이용됨 → 타이머는 현재 시간을 계산하기 위해서도 사용

---

<br><br>
### 3) Device Controller
- 메인 메모리는 CPU만 접근하고 / 디바이스 컨트롤러는 로컬 버퍼만 접근

<br>
#### a. I/O device controller
- 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
- 제어 정보를 위해 control register, status register를 가짐(CPU가 일을 명령하기 위해)
- local buffer를 가짐 (일종의 data register) (메모리의 데이터를 버퍼에 담은다음에 화면에 출력하거나 저장)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림 비교해봅시다.

<br>
#### b. device driver (장치 구동기)
- 하드웨어에 접근하기 위해 설치해야함 
- 실제 디바이스가 실행하는 인스트럭션인 펌웨어 와는 구분되어야함
- OS코드 중 각 장치별 처리루틴 → software
- 하드웨어에 접근하기 위해 설치해야함

<br>
#### c. device controller(장치 제어기)
- 각 장치를 통제하는 일종의 작은 CPU → hardware
 
---

<br><br>
### 4) DMA(direct memory access)
- 메인 메모리에 직접 접근할수 있음
- 동시에 CPU와 메모리에 접근할때를 조율하기 위해서 memory controller
- 목적: I/O가 너무 많은 intrrupt를 발생시킬 수 있기에 중간중간 발생하는 Local buffer의 내용을 복사해서 한번에 메모리에 올려서 CPU로 알려줌.

<br>
#### a. 입출력(I/O)의 수행
- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 I/O를 하는가?

---

<br><br>
### 5) 시스템 콜(System Call)

- 사용자 프로그램은 운영체제에게 I/O 요청
- 프로그램이 직접 소프트웨어적으로 인터럽트(트랩)를 요청 → 운영체제로 제어권 넘어감
- trap을 사용하여 인터럽트 벡터의 특정위치로 이동
- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
- 올바른 I/O 요청인지 확인 후 I/O 수행
- I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

<br>
#### a. Interrupt(인터럽트)
- 인터럽트 당한 시점의 레지스터와 Program Counter를 Save 한 후 CPU의 제어를 인터럽트 처리 루틴에게 넘긴다.
- CPU는 매 클럭마다 인터럽트 들어온게 있는지를 확인함

<br>
#### b. 광의의 인터럽트
- (협의의)Interrupt : 하드웨어가 발생시킨 인터럽트(타이머, I/O 컨트롤러)
	- Trap(소프트웨어 인터럽트)
	- Exception: 프로그램이 오류를 범한 경우
	- System Call: 프로그램이 커널 함수를 호출하는 경우

<br>
#### c. 인터럽트 관련 용어
- 벡터(인터럽트 처리루틴의 주소를 갖고 있음) → 인터럽트 처리 루틴 → 인터럽트 처리

- 인터럽트 벡터 : 
	- 해당 인터럽트의 처리 루틴 주소를 가지고 있음
	- 각 인터럽트에 해당되는 작업을 어느 커널함수에서 해야하는지를 나타내는 테이블 같은 개념

<br>
#### d. 인터럽트 처리 루틴(Interrupt Service Routine, 인터럽트 핸들러)
- 해당 인터럽트를 처리하는 커널 함수

---
 
<br><br>
### 6) System Call
- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것(Trap)
