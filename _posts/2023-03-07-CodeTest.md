---
key: /2023/03/07/CodeTest.html
title: CodingTest - Baekjoon
tags: java
---

# 1. Baekjoon 배열 1 : 230307

- 배열 개념 이용

<br>
### 1) 11720번

<br>
#### 1) parseInt() 메소드를 사용하여 Java에서 char 배열을 int로 변환할 수 있습니다. 
- 이 메서드는 String 객체를 가져와 정수 값을 반환합니다. 
- 이 메서드는 Integer 클래스에 속하므로 정수로 변환하는 데 사용할 수 있습니다. 

<br>
#### 2) parseInt() 메소드와 valueOf() 메소드를 사용하여 Java에서 char 배열을 int로 변환할 수 있습니다. 
- parseInt() 메서드는 valueOf() 메서드가 반환하는 String 객체를 가져와 정수 값을 반환합니다. 
- 이 메서드는 Integer 클래스에 속하므로 정수로 변환하는 데 사용할 수 있습니다.

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Day1TestArray11720_230307 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11720번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		
		String sNum = br.readLine();
		
		char[] cNum = sNum.toCharArray();
		
		int sum = 0;
		
		for(int i=0; i<N; i++) 
			sum += Integer.parseInt(String.valueOf(cNum[i]));	
			// char 배열을 정수를 만드는 방법이 sum += cNum[i] - ’0’;도 가능하다!
		
		
		System.out.println(sum);
	 
	}

}

```

---

<br>
### 2) 1546_1

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray1546_1_230307 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1546번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		
		
		int n = Integer.parseInt(br.readLine());
		int sum = 0;
		
		for(int i=0; i<n; i++) {

			StringTokenizer st = new StringTokenizer(br.readLine());	// split 
			int s =Integer.parseInt(st.nextToken());
			
			for(int j=0; j<s; j++) {
				int data = Integer.parseInt(st.nextToken());
				sb.append(data).append('\n');
			}
			
//			for(int j=0; j<n; j++) {
//				sum += s; 
//				sb.append(sum).append('\n');
//			
//			}

		}
	
		System.out.println(sb);
	}

}

```

---

<br><br>
# 2. Baekjoon 배열, 구간합 : 230308

- 구간 합, 이차 배열

<br>
### 1) 1546_2번

<br>
- 출력문 : StringBuilder sb = new StringBuilder();		
<br>
- split 역할 : StringTokenizer st = new StringTokenizer(br.readLine());	
	- split 역할이고 구분인자도 넣을 수 있다. 기본 구분인자는 " "이다.


```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray1546_2_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1546번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		
		
		int n = Integer.parseInt(br.readLine());
		int sum = 0;
		int[] s1 = new int[n];
		float avg = 0;
		int max = 0;
		
		StringTokenizer st = new StringTokenizer(br.readLine());	
		// split 역할이고 구분인자도 넣을 수 있다. 기본 구분인자는 " "이다.
		
		for(int i=0; i<n; i++) {
			int s = Integer.parseInt(st.nextToken()); 
			s1[i] = s;
		}
		
		 
		for(int i=0; i<s1.length; i++) {
			if(s1[i]>max)
				max = s1[i];
				
			sum += s1[i]; 
		}
		avg = sum*100/ max/n;
		sb.append(avg);
		System.out.println(avg);
	}

}

```

---

<br>
### 2) 11659_1번

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray11659_1_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11659번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
//		int index1 = 0; 
//		int index2 = 0;
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		long[] count = new long[num1];
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
		
		// 5 4 3 2 1 받을 때 처리 
		for(int i=0; i < num1; i++) {	
			count[i] = Integer.parseInt(st2.nextToken());	// 5 4 3 2 1 
			
		}
				
		
		// index를 토큰으로 입력받기 
		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
		// 구간 합 : i~j 구간 = s[j] - s[i-1]
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
			int sum = 0;
			int index1 = Integer.parseInt(st3.nextToken());
			int index2 = Integer.parseInt(st3.nextToken()); 
			
			for(int k=index1-1; k<index2; k++) {
				sum += count[k];
			}
			
			sb.append(sum).append('\n');
			
			
		}
		System.out.println(sb);
		//}

	}
}

```

---

<br>
### 3) 11659_2번

<br>
- 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
- 구간 합 : i~j 구간 = s[j] - s[i-1]

```java

package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray11659_2_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11660번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();

		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		long[] count = new long[num1];
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
		
		// 5 4 3 2 1 받을 때 처리 
		for(int i=0; i < num1; i++) {	
			count[i] = Integer.parseInt(st2.nextToken());	// 5 4 3 2 1 
		}
				
		// index를 토큰으로 입력받기 
		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
		// 구간 합 : i~j 구간 = s[j] - s[i-1]
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
			int sum = 0;
			int index1 = Integer.parseInt(st3.nextToken());
			int index2 = Integer.parseInt(st3.nextToken()); 
			
			for(int k=index1-1; k<index2; k++) {
				sum += count[k];
			}
			
			sb.append(sum).append('\n');	
			
		}
		System.out.println(sb);

	}
}

```

---

<br>
### 4) 11660번

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray11660_1_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11660번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 4 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		int[][] S = new int[num1+1][num1+1];
		int[][] A = new int[num1+1][num1+1];

		
		// 크기별 배열의 원소 매핑 
		for(int k=1; k<num1; k++) {
			StringTokenizer st2 = new StringTokenizer(br.readLine());	
			
			for(int i=1; i<num1; i++) {
				A[k][i] = Integer.parseInt(st2.nextToken());
			}
		}
		
		// 구간합 생성
		// 2차원 배열 구간합 생각해보기!!
		for(int k=1; k<num1; k++) {
			
			// 여기서 또 st를 생성해서 초기화 안해도 된다!!
			// StringTokenizer st2 = new StringTokenizer(br.readLine());	
			for(int i=1; i<num1; i++) {
				S[k][i] = S[k][i-1]-S[k-1][i-1] +S[k-1][i]+A[k][i];
			}
		}
			
		// 질의별 좌표 && 2차원 배열의 구간별 합
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	
			int x1 = Integer.parseInt(st3.nextToken());
			int y1 = Integer.parseInt(st3.nextToken());
			int x2 = Integer.parseInt(st3.nextToken());
			int y2 = Integer.parseInt(st3.nextToken());
			int sum = S[x2][y2] - S[x2][y1-1] + S[x1-1][y1-1]- S[x1-1][y2];
			sb.append(sum).append('\n');	
		}	
		System.out.println(sb);
//		
//		
//		
//		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
//		
//		// 합 배열 처리
//		for(int i=1; i < num1+1; i++) {	
//			S[i] = S[i-1] + Integer.parseInt(st2.nextToken());	
//		}
//			
//		// index를 토큰으로 입력받기 
//		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
//		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
//		// 구간 합 : i~j 구간 = s[j] - s[i-1]
//		for(int j=0; j<num2; j++) {
//			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
//			int sum = 0;
//			int index1 = Integer.parseInt(st3.nextToken());
//			int index2 = Integer.parseInt(st3.nextToken()); 
//			
//			sum += S[index2] - S[index1-1];
//			
//		}
		

	}
}


```



---

<br><br>
# 3. Baekjoon 구간합, 투포인터 : 230309

<br>
### 1) 10986번

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray10986_1_230309 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 10986번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
	
		int[] A = new int[num1+1];	// 기본 배열
		int[] S = new int[num1+1];	// 합 배열 
		int[] C = new int[num2];	// 같은 나머지의 인덱스를 카운트하는 배열
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	
		// 1 2 3 1 2	// 1 3 6 7 9	// 1 0 0 1 0 
		
		// 기본 배열 매핑 
		for(int i=1; i<num1; i++) {
			A[i] = Integer.parseInt(st2.nextToken());
		}
		
		// 합 배열의 원소 매핑 
		for(int i=1; i<num1; i++) {			
				S[i] = S[i-1]+ A[i];
		}
		
		// 변수 주의!! 생각해보기!!
		int remain = 0;
		int answer = 0;
		
		// 나머지가 같은 수 별로 count 더하기
		for(int j=0; j<num1; j++) {
			remain = S[j]%num2;
			
			if(remain == 0) {
				C[remain]++;
				answer++;
			}
			else if(remain == 1) {
				C[remain]++;
			}
		}	
		
		// 2개를 뽑는 모든 경우의 수 : 순열/조합에서 조합 공식(Combination)
		for(int j=0; j<num2; j++) {
			answer += (C[j]*(C[j] -1 ) / 2);
		}	
		
		sb.append(answer).append('\n');	
		System.out.println(sb);

	}
}

```

---

<br>
### 2) 투포인터 1 : 2018변

- 2개의 포인터로알고리즘의 시간복잡도를 최적화한다.
- ex) 어떠한자연수 N은 몇 개의 연속된 자연수의 합 문제

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray2018_1_230309 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 2018번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// StringTokenizer st1 = new StringTokenizer(br.readLine());	// 15
		
		int num1 = Integer.parseInt(br.readLine());	// 15
		
		int count = 1;
		int sum = 1;
		int start = 1;
		int end = 1;
		
		while(end != num1 ) {
			if(sum == num1) {
				count++;
				end++;
				sum = sum + end;
			}
			
			// sum 값을 변동시키고 인자 변동 
			else if(sum>num1) {
				sum = sum-start;
				start++;
			}
			else if(sum< num1) {
				sum=sum+end;
				end++;
			}
		}
		
		sb.append(count).append('\n');	
		System.out.println(sb);

	}
}

```


---

<br>
### 3) 투포인터 2 : 1940변

```java


```


---

<br><br>

# 4. 그리디, DFS : 230315

### 1) 그리디 알고리즘 

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class TestGreedy11047_1_230315 {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
	// 11047번
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	StringBuilder sb = new StringBuilder();
	
	
	
	StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
	
	int num1 = Integer.parseInt(st1.nextToken());	// 10
	int num2 = Integer.parseInt(st1.nextToken());	// 4200 
	
	
	int[] A = new int[num1];
	int count = 0;
	
	for(int i=0; i<num1; i++) {
		// 10개 입력
		A[i] = Integer.parseInt(br.readLine());
	
	}
	
	for(int i=num1-1; i>=0; i--) {
		// 10개 입력
		// 여기 조건식 중요!! 생각 다시!! 
		if(A[i] <= num2) {	
			count += num2 / A[i];
			num2 = num2 % A[i];
		}
	}
	
	sb.append(count);
	
	System.out.println(sb);
	
	}
}

``` 

---

<br><br>
### 2) DFS

- 나중에 한번 더 풀기

<br>
- 문제 잘 읽기
	- 문제의 변수 범위 주의

<br>
- DFS 개념 다시 생각
	- 로직 : 그 노드에 방문 했는지 안했는지 체크

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class TestDFS11724_1_230315 {
	
	// 선언 중요! 
	static ArrayList<Integer>[] A;
	static boolean visited[];

	public static void main(String[] args) throws IOException {
		// 11724번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st1.nextToken()); 
		int m = Integer.parseInt(st1.nextToken());
		
		// 초기화 : 노드의 개수로 배열 초기화! 
		// 왜 n+1개 일까? 문제에서 노드의 개수가 1개부터 시작하라고 했기 때문이다.
		A = new ArrayList[n+1];	
		visited = new boolean[n+1];
		
		// ArrayList에 초기화하기 
		// 왜 1부터 시작? 위의 배열을 (n+1)개로 초기화해서 
		for(int i=1; i < n+1; i++) {
			A[i] = new ArrayList<Integer>();
		}
		
		for(int i=0; i < m; i++) {
			StringTokenizer st2 = new StringTokenizer(br.readLine());
			int num1 = Integer.parseInt(st2.nextToken()); 
			int num2 = Integer.parseInt(st2.nextToken());
			
			// 노드와 에지의 관계라서 List를 이용해서 인접 값을 add로 저장만 할 것 
			A[num1].add(num2);
			A[num2].add(num1);
		}
		
		int count = 0;
		
		// 한 번도 방문을 안 했으면, count 해줄 것 
		// visited 배열의 원소 개수 주의!!
		for(int i=1; i < n+1; i++) {
			if(!visited[i]) {
				count++;
				DFS(i);
			}
		}
		
		sb.append(count);
		System.out.println(sb);
	}
	
	// 방문하는 것을 체크해주는 DFS!! 중요!!
	private static void DFS(int v) {
		
		// 한 번이라도 방문했으면 return; 위의 코드와 상반된다.
		if(visited[v])
			return;
		
		// 처음으로 False 였다면, true로 바꿔 주기 !! 
		visited[v] = true;
		
		// 그래도 false라면 DFS 다시 실행!! true 될때까지 무한 반복 
 		for(int i : A[v]) {
			if(visited[i] == false)
			DFS(i);
		}
		
	}

}



```


---

<br><br>

### 3) BFS : 230318

- ArrayList라서 정렬하는 방법을 Collections의 sort 메서드 이용!
- Queue 자료형 쓰는 방법(LinkedList으로 설계된 Queue이다.)
- 나머지 위치 방문하는 방법 중요!!

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TestDFS1260_1_230318 {
	
	static ArrayList<Integer>[] A;
	static boolean visited[];
	
	public static void main(String[] args) throws IOException {
		// 1260번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st1.nextToken()); // 노드 개수
		int m = Integer.parseInt(st1.nextToken()); // 에지 개수
		int start = Integer.parseInt(st1.nextToken()); // 시작점
		
		A = new ArrayList[n+1];
		
		for(int i=1; i<n+1; i++) {
			A[i] = new ArrayList<Integer>();	
			// List라서 총 3단계로 나누어 초기화(전역변수로 선언, 개수설정, 타입설정)
		}
		
		for(int i=0; i<m; i++) {
			
			StringTokenizer st2 = new StringTokenizer(br.readLine());
			
			int s = Integer.parseInt(st2.nextToken()); // 노드 
			int e = Integer.parseInt(st2.nextToken()); // 에지
			
			A[s].add(e);	// 서로 연결(데이터 저장하는 것)
			A[e].add(s);
		}
		
		// 이게 아니라 그냥 ArrayList가 Collections이라서
		// Collections의 정렬 메서드 이용!!! 엄청 편하다.
		for(int i=1; i<n+1; i++) {
//			if(A[i] > A[i+1]) {
//				ArrayList<Integer> temp = A[i];
//				A[i] = A[i+1];
//				A[i+1] = temp;
//			}
			Collections.sort(A[i]);
		}
		
		visited = new boolean[n+1];
		
		DFS(start);	// 문제가 순서 출력이라서 여기서 다 끝내야 한다.
		
		System.out.println();
		
		visited = new boolean[n+1];
		
		BFS(start);		
		
	}


	private static void DFS(int d) {
		
		// 결과값이 순서 출력이라서 바로 출력하기!!
		System.out.print(d + " ");
		
		visited[d] = true;
		
		// false이면 true가 될 때까지 반복 
		// 위에서 출력되어서 start 위치 빼고 완전 탐색(나머지 위치 방문)
		for(int i : A[d]) {
			if(visited[i] == false)
				DFS(i);	// 재귀함수로서 여기서 출력을 다 끝내야 한다.
		}
	}
	
	private static void BFS(int b) {
		
		// b는 BFS하는 탐색의 시작값이다. 
		Queue<Integer> queue = new LinkedList<Integer>();
		queue.add(b);
		
		visited[b] = true;
		
		while(!queue.isEmpty()) {
			
			// queue의 poll이 stack에서 pop과 같다.
			int result = queue.poll();
			System.out.print(result + " ");
			
			// 여기서 for-each문 중요!! 
			// 위에서 poll되어서 start 위치 빼고 완전 탐색(나머지 위치 방문)
			for(int i : A[b]) {
				if(!visited[i]) {
					visited[i] = true;
					queue.add(i);
				}
			}
		}
	}

}


```
 



---

<br><br>

### 4) 이진 탐색 : 230318

- 이번에는 Collections가 아니라 Array이라서 Arrays로 정렬!!
- 나는 미리 배열의 값으로 바꿔서 비교하는 것이 편하다. 
- 이진 탐색 로직 거의 암기하기!!

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Test2BS1920_1_230318 {
	
	public static void main(String[] args) throws IOException {
		// 1920번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		int num1 = Integer.parseInt(br.readLine());
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		int[] arr = new int[num1];
		int select = 0;
		
		
		for(int i =0; i < num1; i++) {
			arr[i] = Integer.parseInt(st1.nextToken()); 
		}
		
		// 이번에는 Collections가 아니라 Array이라서 Arrays로 정렬!!
		Arrays.sort(arr);
		
		// ==================================================
		
		int num2 = Integer.parseInt(br.readLine()); 
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());
		
		for(int i=0; i<num2; i++) {
			select = Integer.parseInt(st2.nextToken()); 
			boolean result = false;	// boolean 형 중요!! 판단용!
			
			int start = arr[0];
			int end = arr[num1-1];
			
			// while 문 중요!! 로직!! 거의 암기임..
			while(start <= end) {
				int mid = (start+end) / 2;
				
				if(mid > select) {
					end = mid - 1;
				}
				else if (mid < select) {
					start = mid + 1;
				}
				else {
					result = true;
					break;
				}
			}
			
			// 정답 출력용!
			if(result) {
				sb.append(1+"\n");
			}
			
			else {
				sb.append(0+"\n");
			}
			
		}
		
		System.out.println(sb);
		
		
	}

}


```


---

<br>
### 5) DP 개념 : 230318

<br>
#### a. DP의 구현 방식 : 
- 큰 문제를 작은 문제로 나누기 
- 작은 문제들이 반복적으로 나타나서 이 작은 문제들의 결과값은 항상 동일
- 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장되며 추후 재사용에는 이 DP 테이블을 이용한다.
- 동적 계획법은 톱-다운 or 바텀-업 방식으로 구현 가능 

<br>
#### b. 톱-다운 방식으로 구현 
- 이해하기 쉽다. 가독성이 좋다.
- 메모이제이션: 구한 값을 바로 리턴하지 않고 DP 테이블에 저장한 후 리턴하도록 로직을 구현
	- 재귀 함수 같다.

<br>
#### c. 바텀-업 방식으로 구현
- 작은 문제에서 큰 문제로 확장해나가서 반복문이 사용된다.
- 톱-다운 보다 더 안전한 방식이다. 톱-다운은 재귀함수의 깊이가 깊어지면 런타임 에러가 발생할 수 있다.
 
---

<br>
### 6) DP 문제 1(중요!!) : 230318
- 다시 풀기!! 반복하기

<br>
#### a. bottom-up 문제 풀이 

##### a) `d[i] = d[i-1] + 1` 풀이 : 
- `d[i] = d[i-1] + 1` : d[i]는 숫자 i가 1이 되는데 걸리는 최소한의 연산 횟수를 저장해야 합니다. 
- i에서 1을 빼면 i-1이 되므로, d[i-1]+1을 함으로써, d[i-1] (i-1이 1이 되는데 필요한 최소한의 연산) + 1 (i에서 1을 빼서 i-1이 되는데 필요한 연산 횟수 1회)로 초기화합니다. 

<br>
- 예를 들어, d[3] = d[2] + 1 이라고하면, 3에서 1을 빼는 1회 연산을 통해 2가 되므로, d[2] + 1은 3에서 1을 빼서 2가 되고, d[2] (2에서 1이 되는데 필요한 최소 연산 횟수)를 더해준 것입니다. 

<br>

##### b) `if(i % 2 == 0) D[i]= Math.min(D[i], D[i/2] + 1);` 풀이 : 
- d[i]는 위에서 초기화한 d[i-1] + 1 값이 들어있습니다. 이것과 d[i/2]+1을 비교해 최솟값을 d[i]에 넣습니다. 
- d[i/2]의 의미는 i가 2로 나누어 떨어진다고 조건문에서 확인했으니, i를 2로 나눈 값이 1이 되는데 걸리는 최소한의 연산 횟수를 의미합니다. 
- 즉, d[i/2] + 1은 i를 2로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수 + i를 2로 나누는 연산횟수 1회입니다.


<br>

##### c) `if(i % 3 == 0) D[i]= Math.min(D[i], D[i/3] + 1);` 풀이 : 

- `if(i % 3 == 0) D[i]= Math.min(D[i], D[i/3] + 1);` : i가 3으로 나누어 떨어질 때, d[i]와 d[i/3]+1 중 최솟값을 d[i]에 저장합니다.
- 현재 d[i]는 d[i-1]+1과 i가 2로 나누어 떨어지는 경우, d[i/2]+1 중 최솟값이 들어있습니다. 
- 여기에 i가 3으로 나누어 떨어지는 경우 d[i/3]+1과도 값을 비교해 최솟값을 d[i]에 넣습니다.(중첩의 중첩이다.)

<br>

##### d) 결론 :
- 이렇게 for문을 반복하면 d[x]에는 x가 1이 되는데 필요한 연산의 최소 횟수가 들어갑니다.


<br>

##### e) 코드 : 
 
```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TestDP1463_1_230318 {
	
	static int num1;
	static int[] D;	// 최소 연산 횟수
	
	public static void main(String[] args) throws IOException {
		// 1463번
		// 이거도 어렵다.
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		num1 = Integer.parseInt(br.readLine());
		
		int count = 0;
		
		// 점화식이라서 num1 + 1개가 필요!
		D = new int[num1 + 1];
		D[1] = 0;
		
		// 2부터 num1까지 반복한다.**
		// 이게 왜 적절한 횟수를 찾는 문제인가?
		// 빼기 말고는 나누어 떨어지면 동작하기 때문이다. 
		for(int i = 2; i< num1+1; i++) {
			
			D[i] = D[i-1] + 1;
			// 점화식 개념** : 
			// d[3] = d[2]+1 이라고하면, 3에서 1을 빼는 1회 연산을 통해 2가 되므로, 
			// d[2] + 1은 3에서 1을 빼서 2가 되고, d[2](2에서 1이 되는데 필요한 최소 연산 횟수)를 더해준 것입니다. 
		
			if(i % 2 == 0) 
	 			D[i]= Math.min(D[i], D[i/2]+1);
			
	 		if(i % 3 == 0) 
	 			D[i]= Math.min(D[i], D[i/3]+1);
	 		
	 	
		}
		
		System.out.println(D[num1]);
	}

}


```











