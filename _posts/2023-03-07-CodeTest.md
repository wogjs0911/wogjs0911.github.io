---
key: /2023/03/07/CodeTest.html
title: CodingTest - Baekjoon
tags: java
---

# 1. Baekjoon 배열 1 : 230307

- 배열 개념 이용

<br>
### 1) 11720번

- 문제 : 숫자의 합 구하기

<br>
#### 1) parseInt() 메소드를 사용하여 Java에서 char 배열을 int로 변환할 수 있습니다. 
- 이 메서드는 String 객체를 가져와 정수 값을 반환합니다. 
- 이 메서드는 Integer 클래스에 속하므로 정수로 변환하는 데 사용할 수 있습니다. 

<br>
#### 2) parseInt() 메소드와 valueOf() 메소드를 사용하여 Java에서 char 배열을 int로 변환할 수 있습니다. 
- parseInt() 메서드는 valueOf() 메서드가 반환하는 String 객체를 가져와 정수 값을 반환합니다. 
- 이 메서드는 Integer 클래스에 속하므로 정수로 변환하는 데 사용할 수 있습니다.

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Day1TestArray11720_230307 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11720번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		
		String sNum = br.readLine();
		
		char[] cNum = sNum.toCharArray();
		
		int sum = 0;
		
		for(int i=0; i<N; i++) 
			sum += Integer.parseInt(String.valueOf(cNum[i]));	
			// char 배열을 정수를 만드는 방법이 sum += cNum[i] - ’0’;도 가능하다!
		
		
		System.out.println(sum);
	 
	}

}

```

---

<br>
### 2) 1546_1

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray1546_1_230307 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1546번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		
		
		int n = Integer.parseInt(br.readLine());
		int sum = 0;
		
		for(int i=0; i<n; i++) {

			StringTokenizer st = new StringTokenizer(br.readLine());	// split 
			int s =Integer.parseInt(st.nextToken());
			
			for(int j=0; j<s; j++) {
				int data = Integer.parseInt(st.nextToken());
				sb.append(data).append('\n');
			}
			
//			for(int j=0; j<n; j++) {
//				sum += s; 
//				sb.append(sum).append('\n');
//			
//			}

		}
	
		System.out.println(sb);
	}

}

```

---

<br><br>
# 2. Baekjoon 배열, 구간합 : 230308

- 구간 합, 이차 배열

<br>
### 1) 1546_2번

- 문제 : 평균 구하기

<br>
- 출력문 : StringBuilder sb = new StringBuilder();		
<br>
- split 역할 : StringTokenizer st = new StringTokenizer(br.readLine());	
	- split 역할이고 구분인자도 넣을 수 있다. 기본 구분인자는 " "이다.


```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray1546_2_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1546번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		
		
		int n = Integer.parseInt(br.readLine());
		int sum = 0;
		int[] s1 = new int[n];
		float avg = 0;
		int max = 0;
		
		StringTokenizer st = new StringTokenizer(br.readLine());	
		// split 역할이고 구분인자도 넣을 수 있다. 기본 구분인자는 " "이다.
		
		for(int i=0; i<n; i++) {
			int s = Integer.parseInt(st.nextToken()); 
			s1[i] = s;
		}
		
		 
		for(int i=0; i<s1.length; i++) {
			if(s1[i]>max)
				max = s1[i];
				
			sum += s1[i]; 
		}
		avg = sum*100/ max/n;
		sb.append(avg);
		System.out.println(avg);
	}

}

```

---

<br>
### 2) 11659_1번

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray11659_1_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11659번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
//		int index1 = 0; 
//		int index2 = 0;
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		long[] count = new long[num1];
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
		
		// 5 4 3 2 1 받을 때 처리 
		for(int i=0; i < num1; i++) {	
			count[i] = Integer.parseInt(st2.nextToken());	// 5 4 3 2 1 
			
		}
				
		
		// index를 토큰으로 입력받기 
		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
		// 구간 합 : i~j 구간 = s[j] - s[i-1]
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
			int sum = 0;
			int index1 = Integer.parseInt(st3.nextToken());
			int index2 = Integer.parseInt(st3.nextToken()); 
			
			for(int k=index1-1; k<index2; k++) {
				sum += count[k];
			}
			
			sb.append(sum).append('\n');
			
			
		}
		System.out.println(sb);
		//}

	}
}

```

---

<br>
### 3) 11659_2번

- 문제 : 구간 합 구하기


<br>
- 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
- 구간 합 : i~j 구간 = s[j] - s[i-1]

```java

package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray11659_2_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11660번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();

		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		long[] count = new long[num1];
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
		
		// 5 4 3 2 1 받을 때 처리 
		for(int i=0; i < num1; i++) {	
			count[i] = Integer.parseInt(st2.nextToken());	// 5 4 3 2 1 
		}
				
		// index를 토큰으로 입력받기 
		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
		// 구간 합 : i~j 구간 = s[j] - s[i-1]
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
			int sum = 0;
			int index1 = Integer.parseInt(st3.nextToken());
			int index2 = Integer.parseInt(st3.nextToken()); 
			
			for(int k=index1-1; k<index2; k++) {
				sum += count[k];
			}
			
			sb.append(sum).append('\n');	
			
		}
		System.out.println(sb);

	}
}

```

---

<br>
### 4) 11660번

- 문제 : 구간 합 구하기 2

<br>

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray11660_1_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11660번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 4 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		int[][] S = new int[num1+1][num1+1];
		int[][] A = new int[num1+1][num1+1];

		
		// 크기별 배열의 원소 매핑 
		for(int k=1; k<num1; k++) {
			StringTokenizer st2 = new StringTokenizer(br.readLine());	
			
			for(int i=1; i<num1; i++) {
				A[k][i] = Integer.parseInt(st2.nextToken());
			}
		}
		
		// 구간합 생성
		// 2차원 배열 구간합 생각해보기!!
		for(int k=1; k<num1; k++) {
			
			// 여기서 또 st를 생성해서 초기화 안해도 된다!!
			// StringTokenizer st2 = new StringTokenizer(br.readLine());	
			for(int i=1; i<num1; i++) {
				S[k][i] = S[k][i-1]-S[k-1][i-1] +S[k-1][i]+A[k][i];
			}
		}
			
		// 질의별 좌표 && 2차원 배열의 구간별 합
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	
			int x1 = Integer.parseInt(st3.nextToken());
			int y1 = Integer.parseInt(st3.nextToken());
			int x2 = Integer.parseInt(st3.nextToken());
			int y2 = Integer.parseInt(st3.nextToken());
			int sum = S[x2][y2] - S[x2][y1-1] + S[x1-1][y1-1]- S[x1-1][y2];
			sb.append(sum).append('\n');	
		}	
		System.out.println(sb);
//		
//		
//		
//		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
//		
//		// 합 배열 처리
//		for(int i=1; i < num1+1; i++) {	
//			S[i] = S[i-1] + Integer.parseInt(st2.nextToken());	
//		}
//			
//		// index를 토큰으로 입력받기 
//		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
//		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
//		// 구간 합 : i~j 구간 = s[j] - s[i-1]
//		for(int j=0; j<num2; j++) {
//			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
//			int sum = 0;
//			int index1 = Integer.parseInt(st3.nextToken());
//			int index2 = Integer.parseInt(st3.nextToken()); 
//			
//			sum += S[index2] - S[index1-1];
//			
//		}
		

	}
}


```



---

<br><br>
# 3. Baekjoon 구간합, 투포인터 : 230309

<br>
### 1) 10986번

- 문제 : 나머지 합 구하기

<br>

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray10986_1_230309 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 10986번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
	
		int[] A = new int[num1+1];	// 기본 배열
		int[] S = new int[num1+1];	// 합 배열 
		int[] C = new int[num2];	// 같은 나머지의 인덱스를 카운트하는 배열
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	
		// 1 2 3 1 2	// 1 3 6 7 9	// 1 0 0 1 0 
		
		// 기본 배열 매핑 
		for(int i=1; i<num1; i++) {
			A[i] = Integer.parseInt(st2.nextToken());
		}
		
		// 합 배열의 원소 매핑 
		for(int i=1; i<num1; i++) {			
				S[i] = S[i-1]+ A[i];
		}
		
		// 변수 주의!! 생각해보기!!
		int remain = 0;
		int answer = 0;
		
		// 나머지가 같은 수 별로 count 더하기
		for(int j=0; j<num1; j++) {
			remain = S[j]%num2;
			
			if(remain == 0) {
				C[remain]++;
				answer++;
			}
			else if(remain == 1) {
				C[remain]++;
			}
		}	
		
		// 2개를 뽑는 모든 경우의 수 : 순열/조합에서 조합 공식(Combination)
		for(int j=0; j<num2; j++) {
			answer += (C[j]*(C[j] -1 ) / 2);
		}	
		
		sb.append(answer).append('\n');	
		System.out.println(sb);

	}
}

```

---

<br>
### 2) 투포인터 1 : 2018변

- 문제 : 연속된 자연수의 합 구하기

<br>
- 2개의 포인터로 알고리즘의 시간복잡도를 최적화한다.

<br>
- 중요 : 이 문제는 입력 값이 1개라서 start와 end의 위치가 같아서 생각을 더 해보기.. 뒷 문제와 비교할 것.

<br>
- ex) 어떠한자연수 N은 몇 개의 연속된 자연수의 합 문제

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray2018_1_230309 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 2018번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// StringTokenizer st1 = new StringTokenizer(br.readLine());	// 15
		
		int num1 = Integer.parseInt(br.readLine());	// 15
		
		int count = 1;
		int sum = 1;
		int start = 1;
		int end = 1;
		
		while(end != num1 ) {
			if(sum == num1) {
				count++;
				end++;
				sum = sum + end;
			}
			
			// sum 값을 변동시키고 인자 변동 
			else if(sum>num1) {
				sum = sum-start;
				start++;
			}
			else if(sum< num1) {
				sum=sum+end;
				end++;
			}
		}
		
		sb.append(count).append('\n');	
		System.out.println(sb);

	}
}

```


---

<br>
### 3) 투포인터 2(다시) : 1940변

- 문제 : 주몽의 명령

<br>
- 중요 : 이 문제는 입력 값이 여러 개라서 start와 end의 위치가 같지 않고 완전 반대 방향 양끝에 있다. 
	- 생각을 더 해보기.. 앞 문제와 비교할 것.

<br>
- 번호의 합이 M보다 크므로 큰 번호 index를 내린다.
- 번호의 합이 M보다 작으므로 작은 번호 index를 올린다.
- 번호의 합이 M이랑 같으면, 앙쪽 포인터를 모두 이동시키고(서로 멀어지게) count를 증가시킨다.

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Day1TestArray1940_1_230309 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1940번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		int num1 = Integer.parseInt(br.readLine());	// 6
		int num2 = Integer.parseInt(br.readLine());	// 9 
		
		int[] A = new int[num1];
		StringTokenizer st = new StringTokenizer(br.readLine());	// 2 7 4 1 5 3
		
		// 기본 배열 매핑 
		for(int i=1; i<num1; i++) {
			A[i] = Integer.parseInt(st.nextToken());
		}
		
		// 정렬 중요!!
		Arrays.sort(A);
		
		
		int start =0;
		int end = num1-1;
		int count =0;
		
		// 이런 식으로도 풀 수 있다.
		while(start < end) {
			if(A[start]+A[end] < num2) {
				start++;
				
			}
			else if(A[start]+A[end] > num2) {
				end--;
			}
			else {
				count++;
				start++;
				end--;
			}
		}
		
		sb.append(count).append('\n');	
		System.out.println(sb);

	}
}


```


---

<br><br>

# 4. 그리디, DFS : 230315

### 1) 그리디 : 11047번

- 230315
- 동전 개수의 최솟값 구하기

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class TestGreedy11047_1_230315 {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
	// 11047번
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	StringBuilder sb = new StringBuilder();
	
	
	
	StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
	
	int num1 = Integer.parseInt(st1.nextToken());	// 10
	int num2 = Integer.parseInt(st1.nextToken());	// 4200 
	
	
	int[] A = new int[num1];
	int count = 0;
	
	for(int i=0; i<num1; i++) {
		// 10개 입력
		A[i] = Integer.parseInt(br.readLine());
	
	}
	
	for(int i=num1-1; i>=0; i--) {
		// 10개 입력
		// 여기 조건식 중요!! 생각 다시!! 
		if(A[i] <= num2) {	
			count += num2 / A[i];
			num2 = num2 % A[i];
		}
	}
	
	sb.append(count);
	
	System.out.println(sb);
	
	}
}

``` 

---

<br><br>
### 2) DFS : 11724번
- 230315
- 문제 : 연결 요소의 개수 구하기 
- 나중에 한번 더 풀기

<br>
- 문제 잘 읽기
	- 문제의 변수 범위 주의

<br>
- DFS 개념 다시 생각
	- 로직 : 그 노드에 방문 했는지 안했는지 체크

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class TestDFS11724_1_230315 {
	
	// 선언 중요! 
	static ArrayList<Integer>[] A;
	static boolean visited[];

	public static void main(String[] args) throws IOException {
		// 11724번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st1.nextToken()); 
		int m = Integer.parseInt(st1.nextToken());
		
		// 초기화 : 노드의 개수로 배열 초기화! 
		// 왜 n+1개 일까? 문제에서 노드의 개수가 1개부터 시작하라고 했기 때문이다.
		A = new ArrayList[n+1];	
		visited = new boolean[n+1];
		
		// ArrayList에 초기화하기 
		// 왜 1부터 시작? 위의 배열을 (n+1)개로 초기화해서 
		for(int i=1; i < n+1; i++) {
			A[i] = new ArrayList<Integer>();
		}
		
		for(int i=0; i < m; i++) {
			StringTokenizer st2 = new StringTokenizer(br.readLine());
			int num1 = Integer.parseInt(st2.nextToken()); 
			int num2 = Integer.parseInt(st2.nextToken());
			
			// 노드와 에지의 관계라서 List를 이용해서 인접 값을 add로 저장만 할 것 
			A[num1].add(num2);
			A[num2].add(num1);
		}
		
		int count = 0;
		
		// 한 번도 방문을 안 했으면, count 해줄 것 
		// visited 배열의 원소 개수 주의!!
		for(int i=1; i < n+1; i++) {
			if(!visited[i]) {
				count++;
				DFS(i);
			}
		}
		
		sb.append(count);
		System.out.println(sb);
	}
	
	// 방문하는 것을 체크해주는 DFS!! 중요!!
	private static void DFS(int v) {
		
		// 한 번이라도 방문했으면 return; 위의 코드와 상반된다.
		if(visited[v])
			return;
		
		// 처음으로 False 였다면, true로 바꿔 주기 !! 
		visited[v] = true;
		
		// 그래도 false라면 DFS 다시 실행!! true 될때까지 무한 반복 
 		for(int i : A[v]) {
			if(visited[i] == false)
			DFS(i);
		}
		
	}

}



```


---

<br><br>

### 3) BFS : 1260번

- 230318
- 문제 : DFS와 BFS 프로그램 
- ArrayList라서 정렬하는 방법을 Collections의 sort 메서드 이용!
- Queue 자료형 쓰는 방법(LinkedList으로 설계된 Queue이다.)
- 나머지 위치 방문하는 방법 중요!!

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TestDFS1260_1_230318 {
	
	static ArrayList<Integer>[] A;
	static boolean visited[];
	
	public static void main(String[] args) throws IOException {
		// 1260번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st1.nextToken()); // 노드 개수
		int m = Integer.parseInt(st1.nextToken()); // 에지 개수
		int start = Integer.parseInt(st1.nextToken()); // 시작점
		
		A = new ArrayList[n+1];
		
		for(int i=1; i<n+1; i++) {
			A[i] = new ArrayList<Integer>();	
			// List라서 총 3단계로 나누어 초기화(전역변수로 선언, 개수설정, 타입설정)
		}
		
		for(int i=0; i<m; i++) {
			
			StringTokenizer st2 = new StringTokenizer(br.readLine());
			
			int s = Integer.parseInt(st2.nextToken()); // 노드 
			int e = Integer.parseInt(st2.nextToken()); // 에지
			
			A[s].add(e);	// 서로 연결(데이터 저장하는 것)
			A[e].add(s);
		}
		
		// 이게 아니라 그냥 ArrayList가 Collections이라서
		// Collections의 정렬 메서드 이용!!! 엄청 편하다.
		for(int i=1; i<n+1; i++) {
//			if(A[i] > A[i+1]) {
//				ArrayList<Integer> temp = A[i];
//				A[i] = A[i+1];
//				A[i+1] = temp;
//			}
			Collections.sort(A[i]);
		}
		
		visited = new boolean[n+1];
		
		DFS(start);	// 문제가 순서 출력이라서 여기서 다 끝내야 한다.
		
		System.out.println();
		
		visited = new boolean[n+1];
		
		BFS(start);		
		
	}


	private static void DFS(int d) {
		
		// 결과값이 순서 출력이라서 바로 출력하기!!
		System.out.print(d + " ");
		
		visited[d] = true;
		
		// false이면 true가 될 때까지 반복 
		// 위에서 출력되어서 start 위치 빼고 완전 탐색(나머지 위치 방문)
		for(int i : A[d]) {
			if(visited[i] == false)
				DFS(i);	// 재귀함수로서 여기서 출력을 다 끝내야 한다.
		}
	}
	
	private static void BFS(int b) {
		
		// b는 BFS하는 탐색의 시작값이다. 
		Queue<Integer> queue = new LinkedList<Integer>();
		queue.add(b);
		
		visited[b] = true;
		
		while(!queue.isEmpty()) {
			
			// queue의 poll이 stack에서 pop과 같다.
			int result = queue.poll();
			System.out.print(result + " ");
			
			// 여기서 for-each문 중요!! 
			// 위에서 poll되어서 start 위치 빼고 완전 탐색(나머지 위치 방문)
			for(int i : A[b]) {
				if(!visited[i]) {
					visited[i] = true;
					queue.add(i);
				}
			}
		}
	}

}


```
 



---

<br><br>

### 4) 이진 탐색 : 1920번 
- 230318
- 문제 : 원하는 정수 찾기
- 이번에는 Collections가 아니라 Array이라서 Arrays로 정렬!!
- 나는 미리 배열의 값으로 바꿔서 비교하는 것이 편하다. 
- 이진 탐색 로직 거의 암기하기!!

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Test2BS1920_1_230318 {
	
	public static void main(String[] args) throws IOException {
		// 1920번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		int num1 = Integer.parseInt(br.readLine());
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		int[] arr = new int[num1];
		int select = 0;
		
		
		for(int i =0; i < num1; i++) {
			arr[i] = Integer.parseInt(st1.nextToken()); 
		}
		
		// 이번에는 Collections가 아니라 Array이라서 Arrays로 정렬!!
		Arrays.sort(arr);
		
		// ==================================================
		
		int num2 = Integer.parseInt(br.readLine()); 
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());
		
		for(int i=0; i<num2; i++) {
			select = Integer.parseInt(st2.nextToken()); 
			boolean result = false;	// boolean 형 중요!! 판단용!
			
			int start = arr[0];
			int end = arr[num1-1];
			
			// while 문 중요!! 로직!! 거의 암기임..
			while(start <= end) {
				int mid = (start+end) / 2;
				
				if(mid > select) {
					end = mid - 1;
				}
				else if (mid < select) {
					start = mid + 1;
				}
				else {
					result = true;
					break;
				}
			}
			
			// 정답 출력용!
			if(result) {
				sb.append(1+"\n");
			}
			
			else {
				sb.append(0+"\n");
			}
			
		}
		
		System.out.println(sb);
		
		
	}

}


```


---

<br><br>
# 5. DP : 230318

### 1) DP 개념

- 난이도 상 중의 상이다.

<br>

#### a. DP의 구현 방식 : 
- 큰 문제를 작은 문제로 나누기 
- 작은 문제들이 반복적으로 나타나서 이 작은 문제들의 결과값은 항상 동일
- 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장되며 추후 재사용에는 이 DP 테이블을 이용한다.
- 동적 계획법은 톱-다운 or 바텀-업 방식으로 구현 가능 

<br>

#### b. 톱-다운 방식으로 구현 
- 이해하기 쉽다. 가독성이 좋다.
- 메모이제이션: 구한 값을 바로 리턴하지 않고 DP 테이블에 저장한 후 리턴하도록 로직을 구현
	- 재귀 함수 같다.

<br>

#### c. 바텀-업 방식으로 구현
- 작은 문제에서 큰 문제로 확장해나가서 반복문이 사용된다.
- 톱-다운 보다 더 안전한 방식이다. 톱-다운은 재귀함수의 깊이가 깊어지면 런타임 에러가 발생할 수 있다.
 
---

<br>

### 2) DP 문제 1(중요!!) : 1463번

- 230318
- 문제 : 정수를 1로 만들기
- 다시 풀기!! 반복하기
- Top-down 방식으로도 풀기 : 어렵다. 

<br>
- 점화식 정하기(핵심) :
	- `D[i]` : i에서 1로 만드는 데 걸리는 최소 연산 횟수

<br>

#### a. bottom-up 문제 풀이 

##### a) `d[i] = d[i-1] + 1` 풀이 : 
- `d[i] = d[i-1] + 1` : d[i]는 숫자 i가 1이 되는데 걸리는 최소한의 연산 횟수를 저장해야 합니다. 
- i에서 1을 빼면 i-1이 되므로, d[i-1]+1을 함으로써, d[i-1] (i-1이 1이 되는데 필요한 최소한의 연산) + 1 (i에서 1을 빼서 i-1이 되는데 필요한 연산 횟수 1회)로 초기화합니다. 

<br>
- 예를 들어, d[3] = d[2] + 1 이라고하면, 3에서 1을 빼는 1회 연산을 통해 2가 되므로, d[2] + 1은 3에서 1을 빼서 2가 되고, d[2] (2에서 1이 되는데 필요한 최소 연산 횟수)를 더해준 것입니다. 

<br>

##### b) `if(i % 2 == 0) D[i]= Math.min(D[i], D[i/2] + 1);` 풀이 : 
- d[i]는 위에서 초기화한 d[i-1] + 1 값이 들어있습니다. 이것과 d[i/2]+1을 비교해 최솟값을 d[i]에 넣습니다. 
- d[i/2]의 의미는 i가 2로 나누어 떨어진다고 조건문에서 확인했으니, i를 2로 나눈 값이 1이 되는데 걸리는 최소한의 연산 횟수를 의미합니다. 
- 즉, d[i/2] + 1은 i를 2로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수 + i를 2로 나누는 연산횟수 1회입니다.


<br>

##### c) `if(i % 3 == 0) D[i]= Math.min(D[i], D[i/3] + 1);` 풀이 : 

- `if(i % 3 == 0) D[i]= Math.min(D[i], D[i/3] + 1);` : i가 3으로 나누어 떨어질 때, d[i]와 d[i/3]+1 중 최솟값을 d[i]에 저장합니다.
- 현재 d[i]는 d[i-1]+1과 i가 2로 나누어 떨어지는 경우, d[i/2]+1 중 최솟값이 들어있습니다. 
- 여기에 i가 3으로 나누어 떨어지는 경우 d[i/3]+1과도 값을 비교해 최솟값을 d[i]에 넣습니다.(중첩의 중첩이다.)

<br>

##### d) 결론 :

- 이렇게 for문을 반복하면 d[x]에는 x가 1이 되는데 필요한 연산의 최소 횟수가 들어갑니다.


<br>

##### e) 코드 : 
 
```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TestDP1463_1_230318 {
	
	static int num1;
	static int[] D;	// 최소 연산 횟수
	
	public static void main(String[] args) throws IOException {
		// 1463번
		// 이거도 어렵다.
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		num1 = Integer.parseInt(br.readLine());
		
		int count = 0;
		
		// 점화식이라서 num1 + 1개가 필요!
		D = new int[num1 + 1];
		D[1] = 0;
		
		// 2부터 num1까지 반복한다.**
		// 이게 왜 적절한 횟수를 찾는 문제인가?
		// 빼기 말고는 나누어 떨어지면 동작하기 때문이다. 
		for(int i = 2; i< num1+1; i++) {
			
			D[i] = D[i-1] + 1;
			// 점화식 개념** : 
			// d[3] = d[2]+1 이라고하면, 3에서 1을 빼는 1회 연산을 통해 2가 되므로, 
			// d[2] + 1은 3에서 1을 빼서 2가 되고, d[2](2에서 1이 되는데 필요한 최소 연산 횟수)를 더해준 것입니다. 
		
			if(i % 2 == 0) 
	 			D[i]= Math.min(D[i], D[i/2]+1);
			
	 		if(i % 3 == 0) 
	 			D[i]= Math.min(D[i], D[i/3]+1);
	 		
	 	
		}
		
		System.out.println(D[num1]);
	}

}


```


---

<br>

### 3) DP 문제 2 : 14501번

- 230318
- 문제 : 퇴사 준비하기

<br>
- 점화식 정하기(중요!!)
- `D[i]` : i번째 날부터 퇴사날까지 벌 수 있는 최대 수입

<br>
- D 배열의 개수 초기화가 N+2인 이유
	- 인덱스가 "1"부터 시작하기 때문이고 N+1일부터 퇴사처리되고 그 다음날에 임금을 받기 때문이다. 
	- t와 p는 n-1까지 있지만, dp는 n까지 있습니다.
	- 1일 차에 1일짜리 일을 한다면 2일 차에 돈을 받기 때문입니다.

<br>
- 최대 이익 판단 코드 부분 :
	- 앞의 코드에서 D[i]가 D[i + 1]되기 때문에 D[i + 1]와 비교한다.
	- D[i+T[i]] = 현재 날짜부터 그 만큼의 상담 시간들 = "진짜 마감일"
	- P[i] + D[i+T[i]] = 금액 + 현재 날짜부터 그 만큼의 상담 시간들로서 "최대 이익 판단"


```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TestDP14501_1_230318 {
	
	static int N;
	static int D[];
	static int T[];
	static int P[];
	
	public static void main(String[] args) throws IOException {
		// 14501번
		// 이거도 어렵다.
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		N = Integer.parseInt(br.readLine());
		
		D = new int[N+2];	// D[i]는 i날째 부터 최대로 벌어들이는 최대 수입
		T = new int[N+1];
		P = new int[N+1];
		
		// 점화식이라서 1부터 시작
		for(int i=1; i<N+1; i++) {
			StringTokenizer st1 = new StringTokenizer(br.readLine());
			
			T[i] = Integer.parseInt(st1.nextToken()); 
			P[i] = Integer.parseInt(st1.nextToken()); 
		
		}
		
		// 역으로 날짜 계산
		for(int i = N; i > 0; i--) {
			
			if(i+T[i] > N+1) {		
				// 퇴사일이 안 끝난다..
				// 퇴사 날짜인 N+1보다 i(현재 일자)+T[i](상담 일수)가 더 큰 경우
				// 상담을 할 수 없어서 +0원 이다.
				
				D[i] = D[i + 1];	
				
			} else {				
				// 퇴사일 안에 끝나는 경우, 상담을 추가로 할 수 있기 때문에
				// 최대 수입이 + 된다.
				// 앞의 코드에서 D[i]가 D[i + 1]되기 때문에 D[i + 1]와 비교한다.
				// D[i+T[i]] = 현재 날짜부터 그 만큼의 상담 시간들 = 진짜 마감일
				// P[i] + D[i+T[i]] = 금액 + 현재 날짜부터 그 만큼의 상담 시간들의 최대 이익 판단
				
				D[i] = Math.max(D[i+1], P[i] + D[i+T[i]]);
			}


		}
		
		System.out.println(D[1]); 	// 첫 날부터 시작할 때, 최대 이익!
		
		
	}
}


```


---

<br>

### 4) DP 문제 3 : 2193번

- 230319
- 문제 : 이친수 구하기

<br>
- 여전히 점화식 짜는 것이 어렵다. 연습 더 할 것. 이게 핵심이다. 주어로 잡는 것 
- `D[i][0]` : i 길이에서 끝이 0으로 끝나는 이친수의 개수 
- `D[i][1]` : i 길이에서 끝이 1로 끝나는 이친수의 개수


<br>

#### a. 첫 번째 풀이 방법 :
- n번째 자리에 0이 올 땐 n-1의 숫자가 0 또는 1 상관이 없으므로 D[n-1]만큼 정답에 더하고
- n번째 자리에 1이 올 땐 n-1의 자리에 무조건 0이 와야하기 때문에 D[n-1]에서 0이 올때를 생각해서2
- D[n-1]가 있는 상태에서 D[n-2]를 정답에 더하면 된다.
- 따라서, 점화식은 D[n] = D[n-1] + D[n-2]이다.

<br>

#### b. 두 번째 풀이 방법 :
- 나는 이게 더 이해하기 쉽다.

```java
package com.wogjs0911.codetest.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TestDP2193_1_230319 {
	
	static int N;
	static long[][] D;	// 최소 연산 횟수
	
	public static void main(String[] args) throws IOException {
		// 2193번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		N = Integer.parseInt(br.readLine());
		
		// 초기화 주의!! 무조건 0아니면 1만 들어가서 2개만 할당해도 된다.
		// D = new int[N+1][N+1]; 이게 아니다.
		// long 형인 이유도 중요!!
		D = new long[N+1][2];
		
		// 끝나는 숫자
		D[1][1] = 1; 
		D[1][0] = 0;
		
		// 연속되는 값 처리 방법(이전 값을 계속 더해지는 점화식으로 비교!!)
		for(int i = 2; i < N+1; i++) {
			D[i][0] = D[i - 1][1] + D[i - 1][0];
			D[i][1] = D[i - 1][0];
		}
		
		sb.append(D[N][0] + D[N][1]);
		
		System.out.println(sb);
	}

}


```


<br>
#### c. 주의 할 것

- D배열을 int로 선언해줘서 N이 크면 값이 int형으로 담을 수 있는 수보다 컸기 때문이였다. 문제에서 90자리까지 들어 갈 수 있었기 때문이다.
- 암튼 제출하기 전에 혼자 N에 들어갈 수 있는 수들 중 가장 작은 수와 가장 큰 수는 기본적으로 검사해보고 제출하는 버릇을 들여야 겠다.


---

<br>

### 5) DP 문제 4 : 11726번
- 230319
- 문제 : 2*N 타일 채우기
- 바텀-업 방식의 점화식은 작은 문제들을 모아서 찾아가는 과정이므로 여러 번 생각해보자!

<br>
- D[N] : 길이 N으로 만들 수 있는 타일의 경우의 수
	- 이런 식으로 점화식을 정의 내리는 것이 중요하다!

```java
package com.wogjs0911.codetest.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TestDP11726_1_230319 {
	
	public static void main(String[] args) throws IOException {
		// 2193번
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		int N = Integer.parseInt(br.readLine());
		
		int[] D = new int[N+3];
		
		// 점화식이라서 항상 초기값 필수!!
		D[1] = 1;
		D[2] = 2;
		
		// 이렇게 점화식 생각하는게 어렵다..
		// 그래도 작은문제를 찾아가는 과정이라서 익숙해져가고 있다.
		for(int i = 3; i<N+3; i++) {
			D[i] = D[i-1] + D[i-2];
			D[i] = D[i] % 10007;	// 이건 문제의 조건이다.
		}
		
		System.out.println(D[N]);
	}

}


```


---

<br>

### 6) 그리디 문제2 : 1715번

- 230319
- 문제 : 카드 정렬하기

<br>
- 우선순위 큐는 자동 정렬이 되어서 순서가 뒤바뀌어도 작은 카드 묶음 2개를 쉽게 뽑을 수 있다.
- 우선순위 큐를 사용하는 방법과 최소 횟수를 위해서 while문에 반복되어도 누적해져서 더 해진다!!

<br>

```java
package com.wogjs0911.codetest.greedy;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class TestGreedy1715_1_230319 {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		// 1715번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		int N = Integer.parseInt(br.readLine());
		
		Queue<Integer> queue = new PriorityQueue<>();
		
		// 우선순위 큐는 자동 정렬이 되어서 순서가 뒤바뀌어도
		// 작은 카드 묶음 2개를 쉽게 뽑을 수 있다.
		for(int i = 0; i < N; i++) {
			
			int data= Integer.parseInt(br.readLine());
			queue.add(data);
		}
		
		int card1 = 0;
		int card2 = 0;
		int sum = 0;
		
		while(queue.size() != 1) {
			card1= queue.remove();
			card2 = queue.remove();
			
			// while문에 반복되어도 누적해져서 더 해진다!!
			sum += card1 + card2;
			queue.add(sum);
		}
		
		System.out.println(sum);
	}
}

```


---

<br>

### 7) 그리디 문제3 : 1744번
- 230322
- 아직 우선순위 큐라는 자료구조가 익숙하지 않다.

```java
package com.wogjs0911.codetest.greedy;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Queue;

public class TestGreedy1744_1_230320 {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1744번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		int N = Integer.parseInt(br.readLine());	// 9 
		
		// 정렬을 위해 우선 순위 
		// 우선 순위 큐를 역정렬하기 위해서는 Collections.reverseOrder()를 생성자(())에 넣어준다.
		// 양수 큐는 내림차순한다. 
		Queue<Integer> pqplus = new PriorityQueue<>(Collections.reverseOrder()); 
		Queue<Integer> pqminus = new PriorityQueue<>(); 
		
		int num = 0;
		int zerocount = 0;
		int onecount = 0;
		int sum = 0;
		
		// 입력 값이 정수라서 범위로 나누기!!
		for(int i =0; i < N; i++) {
			num = Integer.parseInt(br.readLine());
			
			if(num >= 2) {
				pqplus.add(num);
			}
			else if(num < 0) {
				pqminus.add(num);
			}
			
			else if(num == 0) {
				zerocount++;
			}
			else if(num == 1) {
				onecount++;
			}
		}
		
		int card1 = 0;
		int card2 = 0;
		
		// 양수 큐에서 나온거 로직 돌리기(가장 중요!!)
		// 문제에서 더하는 부분 다시 보기!!
		while(pqplus.size() >= 2) {
			card1 = pqplus.remove();
			card2 = pqplus.remove();
			sum += card1 * card2;
			
		}
		
		if(pqplus.size() == 1) {
			sum += pqplus.remove();
		}
		
		int minus1 = 0;
		int minus2 = 0;
		
		while(pqminus.size() >= 2) {
			minus1 = pqminus.remove();
			minus2 = pqminus.remove();
			sum += minus1 * minus2;
			
		}
		
		if(pqminus.size() == 1) {
			
			if(zerocount == 0) {
				sum += pqminus.remove();
			}
		}
		
		sum += onecount * 1;
		
		sb.append(sum);
		
		System.out.println(sb);
		
		
	}
}

```


---

<br>

### 8) 그리디 문제4 : 1931번
- 230323
- 아직 우선순위 큐라는 자료구조가 익숙하지 않다.

```java

```

















