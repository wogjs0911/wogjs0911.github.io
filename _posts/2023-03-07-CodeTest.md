---
key: /2023/03/07/CodeTest.html
title: CodingTest - Baekjoon
tags: java
---

# 1. Baekjoon 배열 1 : 230307

- 배열 개념 이용

<br>
### 1) 11720번

<br>
#### 1) parseInt() 메소드를 사용하여 Java에서 char 배열을 int로 변환할 수 있습니다. 
- 이 메서드는 String 객체를 가져와 정수 값을 반환합니다. 
- 이 메서드는 Integer 클래스에 속하므로 정수로 변환하는 데 사용할 수 있습니다. 

<br>
#### 2) parseInt() 메소드와 valueOf() 메소드를 사용하여 Java에서 char 배열을 int로 변환할 수 있습니다. 
- parseInt() 메서드는 valueOf() 메서드가 반환하는 String 객체를 가져와 정수 값을 반환합니다. 
- 이 메서드는 Integer 클래스에 속하므로 정수로 변환하는 데 사용할 수 있습니다.

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Day1TestArray11720_230307 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11720번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		
		String sNum = br.readLine();
		
		char[] cNum = sNum.toCharArray();
		
		int sum = 0;
		
		for(int i=0; i<N; i++) 
			sum += Integer.parseInt(String.valueOf(cNum[i]));	
			// char 배열을 정수를 만드는 방법이 sum += cNum[i] - ’0’;도 가능하다!
		
		
		System.out.println(sum);
	 
	}

}

```

---

<br>
### 2) 1546_1

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray1546_1_230307 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1546번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		
		
		int n = Integer.parseInt(br.readLine());
		int sum = 0;
		
		for(int i=0; i<n; i++) {

			StringTokenizer st = new StringTokenizer(br.readLine());	// split 
			int s =Integer.parseInt(st.nextToken());
			
			for(int j=0; j<s; j++) {
				int data = Integer.parseInt(st.nextToken());
				sb.append(data).append('\n');
			}
			
//			for(int j=0; j<n; j++) {
//				sum += s; 
//				sb.append(sum).append('\n');
//			
//			}

		}
	
		System.out.println(sb);
	}

}

```

---

<br><br>
# 2. Baekjoon 배열, 구간합 : 230308

- 구간 합, 이차 배열

<br>
### 1) 1546_2번

<br>
- 출력문 : StringBuilder sb = new StringBuilder();		
<br>
- split 역할 : StringTokenizer st = new StringTokenizer(br.readLine());	
	- split 역할이고 구분인자도 넣을 수 있다. 기본 구분인자는 " "이다.


```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray1546_2_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 1546번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		
		
		int n = Integer.parseInt(br.readLine());
		int sum = 0;
		int[] s1 = new int[n];
		float avg = 0;
		int max = 0;
		
		StringTokenizer st = new StringTokenizer(br.readLine());	
		// split 역할이고 구분인자도 넣을 수 있다. 기본 구분인자는 " "이다.
		
		for(int i=0; i<n; i++) {
			int s = Integer.parseInt(st.nextToken()); 
			s1[i] = s;
		}
		
		 
		for(int i=0; i<s1.length; i++) {
			if(s1[i]>max)
				max = s1[i];
				
			sum += s1[i]; 
		}
		avg = sum*100/ max/n;
		sb.append(avg);
		System.out.println(avg);
	}

}

```

---

<br>
### 2) 11659_1번

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray11659_1_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11659번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
//		int index1 = 0; 
//		int index2 = 0;
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		long[] count = new long[num1];
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
		
		// 5 4 3 2 1 받을 때 처리 
		for(int i=0; i < num1; i++) {	
			count[i] = Integer.parseInt(st2.nextToken());	// 5 4 3 2 1 
			
		}
				
		
		// index를 토큰으로 입력받기 
		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
		// 구간 합 : i~j 구간 = s[j] - s[i-1]
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
			int sum = 0;
			int index1 = Integer.parseInt(st3.nextToken());
			int index2 = Integer.parseInt(st3.nextToken()); 
			
			for(int k=index1-1; k<index2; k++) {
				sum += count[k];
			}
			
			sb.append(sum).append('\n');
			
			
		}
		System.out.println(sb);
		//}

	}
}

```

---

<br>
### 3) 11659_2번

<br>
- 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
- 구간 합 : i~j 구간 = s[j] - s[i-1]

```java

package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Day1TestArray11659_2_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11660번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();

		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		long[] count = new long[num1];
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
		
		// 5 4 3 2 1 받을 때 처리 
		for(int i=0; i < num1; i++) {	
			count[i] = Integer.parseInt(st2.nextToken());	// 5 4 3 2 1 
		}
				
		// index를 토큰으로 입력받기 
		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
		// 구간 합 : i~j 구간 = s[j] - s[i-1]
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
			int sum = 0;
			int index1 = Integer.parseInt(st3.nextToken());
			int index2 = Integer.parseInt(st3.nextToken()); 
			
			for(int k=index1-1; k<index2; k++) {
				sum += count[k];
			}
			
			sb.append(sum).append('\n');	
			
		}
		System.out.println(sb);

	}
}

```

---

<br>
### 4) 11660번

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray11660_1_230308 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 11660번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 4 
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
		
		int[][] S = new int[num1+1][num1+1];
		int[][] A = new int[num1+1][num1+1];

		
		// 크기별 배열의 원소 매핑 
		for(int k=1; k<num1; k++) {
			StringTokenizer st2 = new StringTokenizer(br.readLine());	
			
			for(int i=1; i<num1; i++) {
				A[k][i] = Integer.parseInt(st2.nextToken());
			}
		}
		
		// 구간합 생성
		// 2차원 배열 구간합 생각해보기!!
		for(int k=1; k<num1; k++) {
			
			// 여기서 또 st를 생성해서 초기화 안해도 된다!!
			// StringTokenizer st2 = new StringTokenizer(br.readLine());	
			for(int i=1; i<num1; i++) {
				S[k][i] = S[k][i-1]-S[k-1][i-1] +S[k-1][i]+A[k][i];
			}
		}
			
		// 질의별 좌표 && 2차원 배열의 구간별 합
		for(int j=0; j<num2; j++) {
			StringTokenizer st3 = new StringTokenizer(br.readLine());	
			int x1 = Integer.parseInt(st3.nextToken());
			int y1 = Integer.parseInt(st3.nextToken());
			int x2 = Integer.parseInt(st3.nextToken());
			int y2 = Integer.parseInt(st3.nextToken());
			int sum = S[x2][y2] - S[x2][y1-1] + S[x1-1][y1-1]- S[x1-1][y2];
			sb.append(sum).append('\n');	
		}	
		System.out.println(sb);
//		
//		
//		
//		StringTokenizer st2 = new StringTokenizer(br.readLine());	// 5 4 3 2 1
//		
//		// 합 배열 처리
//		for(int i=1; i < num1+1; i++) {	
//			S[i] = S[i-1] + Integer.parseInt(st2.nextToken());	
//		}
//			
//		// index를 토큰으로 입력받기 
//		// 이렇게하는게 아니라 index를 받아서 점화식 이용하기!
//		// 합 배열 : s[i] = s[i-1] + A[i] -> A가 원래 배열, S가 합 배열(S[0]은 '0'이다. ) 
//		// 구간 합 : i~j 구간 = s[j] - s[i-1]
//		for(int j=0; j<num2; j++) {
//			StringTokenizer st3 = new StringTokenizer(br.readLine());	// index
//			int sum = 0;
//			int index1 = Integer.parseInt(st3.nextToken());
//			int index2 = Integer.parseInt(st3.nextToken()); 
//			
//			sum += S[index2] - S[index1-1];
//			
//		}
		

	}
}


```



---

<br><br>
# 3. Baekjoon 구간합, 투포인터 : 230309

<br>
### 1) 10986번

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray10986_1_230309 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 10986번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
		
		int num1 = Integer.parseInt(st1.nextToken());	// 5
		int num2 = Integer.parseInt(st1.nextToken());	// 3 
	
		int[] A = new int[num1+1];	// 기본 배열
		int[] S = new int[num1+1];	// 합 배열 
		int[] C = new int[num2];	// 같은 나머지의 인덱스를 카운트하는 배열
		
		StringTokenizer st2 = new StringTokenizer(br.readLine());	
		// 1 2 3 1 2	// 1 3 6 7 9	// 1 0 0 1 0 
		
		// 기본 배열 매핑 
		for(int i=1; i<num1; i++) {
			A[i] = Integer.parseInt(st2.nextToken());
		}
		
		// 합 배열의 원소 매핑 
		for(int i=1; i<num1; i++) {			
				S[i] = S[i-1]+ A[i];
		}
		
		// 변수 주의!! 생각해보기!!
		int remain = 0;
		int answer = 0;
		
		// 나머지가 같은 수 별로 count 더하기
		for(int j=0; j<num1; j++) {
			remain = S[j]%num2;
			
			if(remain == 0) {
				C[remain]++;
				answer++;
			}
			else if(remain == 1) {
				C[remain]++;
			}
		}	
		
		// 2개를 뽑는 모든 경우의 수 : 순열/조합에서 조합 공식(Combination)
		for(int j=0; j<num2; j++) {
			answer += (C[j]*(C[j] -1 ) / 2);
		}	
		
		sb.append(answer).append('\n');	
		System.out.println(sb);

	}
}

```

---

<br>
### 2) 투포인터 1 : 2018변

- 2개의 포인터로알고리즘의 시간복잡도를 최적화한다.
- ex) 어떠한자연수 N은 몇 개의 연속된 자연수의 합 문제

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Day1TestArray2018_1_230309 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		// 2018번
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		// StringTokenizer st1 = new StringTokenizer(br.readLine());	// 15
		
		int num1 = Integer.parseInt(br.readLine());	// 15
		
		int count = 1;
		int sum = 1;
		int start = 1;
		int end = 1;
		
		while(end != num1 ) {
			if(sum == num1) {
				count++;
				end++;
				sum = sum + end;
			}
			
			// sum 값을 변동시키고 인자 변동 
			else if(sum>num1) {
				sum = sum-start;
				start++;
			}
			else if(sum< num1) {
				sum=sum+end;
				end++;
			}
		}
		
		sb.append(count).append('\n');	
		System.out.println(sb);

	}
}

```


---

<br>
### 3) 투포인터 2 : 1940변

```java


```


---

<br><br>

# 4. 그리디, DFS : 230315

### 1) 그리디 알고리즘 

```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class TestGreedy11047_1_230315 {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
	// 11047번
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	StringBuilder sb = new StringBuilder();
	
	
	
	StringTokenizer st1 = new StringTokenizer(br.readLine());	// 5 3
	
	int num1 = Integer.parseInt(st1.nextToken());	// 10
	int num2 = Integer.parseInt(st1.nextToken());	// 4200 
	
	
	int[] A = new int[num1];
	int count = 0;
	
	for(int i=0; i<num1; i++) {
		// 10개 입력
		A[i] = Integer.parseInt(br.readLine());
	
	}
	
	for(int i=num1-1; i>=0; i--) {
		// 10개 입력
		// 여기 조건식 중요!! 생각 다시!! 
		if(A[i] <= num2) {	
			count += num2 / A[i];
			num2 = num2 % A[i];
		}
	}
	
	sb.append(count);
	
	System.out.println(sb);
	
	}
}

``` 

---

<br><br>
### 2) DFS(다시 풀기)



```java
package com.wogjs0911.codetest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class TestDFS11724_1_230315 {
	
	// 선언 중요! 
	static ArrayList<Integer>[] A;
	static boolean visited[];

	public static void main(String[] args) throws IOException {
		// 11724번
		
		// DFS 좀 어렵다.
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st1.nextToken()); 
		int m = Integer.parseInt(st1.nextToken());
		
		// 초기화 : 노드의 개수로 배열 초기화! 
		A = new ArrayList[n+1];	
		visited = new boolean[n+1];
		
		// ArrayList에 초기화하기 
		for(int i=0; i < n; i++) {
			A[i] = new ArrayList<Integer>();
		}
		
		for(int i=0; i < m; i++) {
			StringTokenizer st2 = new StringTokenizer(br.readLine());
			int num1 = Integer.parseInt(st2.nextToken()); 
			int num2 = Integer.parseInt(st2.nextToken());
			
			// 노드와 에지의 관계라서 List를 이용해서 인접 값을 add로 저장만 할 것 
			A[num1].add(num2);
			A[num2].add(num1);
		}
		
		int count = 0;
		
		// 한 번도 방문을 안 했으면, count 해줄 것 
		for(int i=0; i < n; i++) {
			if(!visited[i]) {
				count++;
				DFS(i);
			}
		}
	}
	
	// 방문하는 것을 체크해주는 DFS!! 중요!!
	private static void DFS(int v) {
		
		// 한 번이라도 방문했으면 return; 위의 코드와 상반된다.
		if(visited[v])
			return;
		
		
		// 처음으로 False 였다면, true로 바꿔 주기 !! 
		visited[v] = true;
		
		
		// 그래도 false라면 DFS 다시 실행!! true 될때까지 무한 반복 
 		for(int i : A[v]) {
			if(visited[i] == false)
			DFS(i);
		}
		
	}

}


```





