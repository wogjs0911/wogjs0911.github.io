---
key: /2023/04/10/Week20-Day.html
title: TIL - 20주차 코드
tags: springboot RESTAPI Vue.js NodeJS npm component 
---

# 1. 인증과 권한 1 : 230410


### 1) Session 개념

#### a. Session 로직 

##### a) 조건 1 

- 세션 / 쿠키를 이용해서 사용자가 인증되었던 적이 있는지를 확인함.
- if 너 로그인 했니? 
- 아니요 -> 로그인하고 와

<br>

##### b)  조건 2

- if 너 로그인 햇니? 
- 네 -> if(그럼 너 어드민 이니?)
- 아니요 -> 권한이 없다~ 얘.

<br>

#### b. Session-Id 개념 

- 세션아이디는 서버자원을 사용하는 것이기 때문에 인증을 하면 그때 키(세션아이디, 세션키)가 부여받게 된다.**


```java
package kr.co.rland.web.controller.admin;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import jakarta.servlet.http.HttpServletRequest;

@Controller("adminHomeController")
@RequestMapping("/admin")
public class HomeController {
	
	@GetMapping("index")
	public String index(HttpServletRequest request) {

		// **session id 부여**
		// 아직 테스트만 했다. 중요하지 않다. sessionkey가 언제만들어지는지 확인!!
 		request.getSession().setAttribute("test", "hehe");

		return "admin/index";
	}

}

```

---

<br><br>

### 2) 로그인 기본 방식 


#### a. 기능 


- Member.java

```java

@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Member {

    private Long id;
    private String userName;
    private String pwd;
    private String email;
    private Long roleId;
    
}

```


<br>
- UserController.java

```java

@Controller
@RequestMapping("/user")
public class UserController {
    
    @Autowired
    private MemberService memberService;


    // 회원이 탈되되어도 사용자 이름이랑 식별자는 남긴다.
    @GetMapping("login")
    public String login(String uid, String pwd){

        // Member member= memberService.getByUseName(uid);
        
        // 우리는 컨트롤러에서 입력만 받으면 된다. 
        // 컨트롤러에서 모든 것을 업무하면 안 된다. 그래서 위의 서비스는 사용하지 않는다. 
        // id를 가져와서 컨트롤러에서 처리하기 때문이다.
        boolean isValid = memberService.isValidMember(uid, pwd);

        return "user/login";
    }

}

```


<br>
- MemberService.java

```java
package kr.co.rland.web.service;

public interface MemberService {

    // Member getByUseName(String uid);

    boolean isValidMember(String uid, String pwd);
    
}

```



<br>
- DefaultMemberService.java

```java

@Service
public class DefaultMemberService implements MemberService {
   
    @Autowired
    private MemberRepository repository;

    @Override
    public boolean isValidMember(String uid, String pwd) {
        
        Member member = repository.findByUserName(uid);
        
        return false;
    }
}

```


<br>
- MemberRepository.java

```java

@Mapper
public interface MemberRepository {
    Member findByUserName(String uid);
}

```


---

<br><br>

# 2. 인증과 권한 2 : 230411


### 1) 로그인 방식 1 : 바닥부터 만들기



- UserController.java

```java
package kr.co.rland.web.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import kr.co.rland.web.service.MemberService;

@Controller
@RequestMapping("/user")
public class UserController {
    
    @Autowired
    private MemberService memberService;


    // 회원이 탈되되어도 사용자 이름이랑 식별자는 남긴다.
    @GetMapping("login")
    public String login(){
        return "user/login";
    }


    // 회원이 탈되되어도 사용자 이름이랑 식별자는 남긴다.
    @PostMapping("login")
    public String login(String uid, String pwd){

        // Member member= memberService.getByUseName(uid);
        
        // 우리는 컨트롤러에서 입력만 받으면 된다. 
        // 컨트롤러에서 모든 것을 업무하면 안 된다. 그래서 위의 서비스는 사용하지 않는다. 
        // id를 가져와서 컨트롤러에서 처리하기 때문이다.
        boolean isValid = memberService.isValidMember(uid, pwd);

        System.out.println(isValid);
        
        if(isValid)
            return "redirect:index";
        
        return "redirect:login";
    }

}

```




- MemberService.java

```java
package kr.co.rland.web.service;

public interface MemberService {

    // Member getByUseName(String uid);

    boolean isValidMember(String uid, String pwd);
    
}

```


- DefaultMemberService.java

```java
package kr.co.rland.web.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import kr.co.rland.web.entity.Member;
import kr.co.rland.web.repository.MemberRepository;

@Service
public class DefaultMemberService implements MemberService {
   
    @Autowired
    private MemberRepository repository;

    @Override
    public boolean isValidMember(String uid, String pwd) {
        
        Member member = repository.findByUserName(uid);
        
        if(member == null)
            return false;

        // '=='가 아니라 '.getPwd().equals' 이다.
        else if(!member.getPwd().equals(pwd))
            return false;

        return true;
    }


}

```


- MemberRepository.java

```java
package kr.co.rland.web.repository;

import org.apache.ibatis.annotations.Mapper;

import kr.co.rland.web.entity.Member;

@Mapper
public interface MemberRepository {
    Member findByUserName(String uid);
}

```





- MemberRepositoryMapper.xml

```java
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="kr.co.rland.web.repository.MemberRepository">
	
	<select id="findByUserName" resultType="Member">
		select * 
		from member
		where username=#{uid}
	</select>
	
</mapper>
```


---

<br><br>

### 2) 로그인 실패 시, 에러 추가

- `${param.data}`로 값 넘겨주기
	- 타임리프의 편의 객체 이용


<br>

#### a. 실습 코드 :

<br>
- UserController.java

```java

@Controller
@RequestMapping("/user")
public class UserController {
    
    @Autowired
    private MemberService memberService;


    // 회원이 탈되되어도 사용자 이름이랑 식별자는 남긴다.
    @GetMapping("login")
    public String login(){
        return "user/login";
    }


    // 회원이 탈되되어도 사용자 이름이랑 식별자는 남긴다.
    @PostMapping("login")
    public String login(String uid, 
                        String pwd,
                        HttpSession session){

        // Member member= memberService.getByUseName(uid);
        
        // 우리는 컨트롤러에서 입력만 받으면 된다. 
        // 컨트롤러에서 모든 것을 업무하면 안 된다. 그래서 위의 서비스는 사용하지 않는다. 
        // id를 가져와서 컨트롤러에서 처리하기 때문이다.
        boolean isValid = memberService.isValidMember(uid, pwd);

        System.out.println(isValid);
        
        if(isValid) {
            
            // session 케비넷을 사용하고 있는 User가 많다면,
            // 과부하가 생긴다.
            session.setAttribute("username", uid);
            
            return "redirect:/index";
        }
        
        return "redirect:login?error=sdfsdfsdf";
    }

}

```

<br>
- login.html

```java

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <link href="/css/reset.css" type="text/css" rel="stylesheet" >
        <link href="/css/style.css" type="text/css" rel="stylesheet" >
        <link href="/css/layout.css" type="text/css" rel="stylesheet" >
        <link href="/css/header.css" type="text/css" rel="stylesheet" >
        <link href="/css/footer.css" type="text/css" rel="stylesheet" >
        
        <link href="/css/buttons.css" type="text/css" rel="stylesheet" >
        <link href="/css/icon.css" type="text/css" rel="stylesheet" >
        <link href="/css/deco.css" type="text/css" rel="stylesheet" >
        <link href="/css/index.css" type="text/css" rel="stylesheet">
        <link href="/css/utils.css" type="text/css" rel="stylesheet" >    
        <style>
            .btn{
                color:black;
            }
        </style>
    </head>
    
    <body>
        <header class="header">
            <div>
                <h1 class="header-title"><a href="/index.html"><img class="logo" src="../image/logo-w.png" alt="알랜드"></a></h1>
                
                <ul class="main-menu d-none d-inline-flex-sm">
                    <li><a class="" href="/menu/list.html">카페메뉴</a></li>
                    <li><a class="" href="/notice/list.html">공지사항</a></li>
                    <li><a class="" href="/user/login.html">로그인</a></li>
                </ul>
                <div class="d-none-sm"><a class="icon icon-menu icon-white" href="?m=on">메뉴버튼</a></div>
            </div>
        </header>

    <main>
        <section>
            <header class="header-default">
                <h1 class="text-title1-h1">로그인</h1>
            </header>
            <section class="login">
                <h1 class="d-none" th:text="${param.error}">일반 로그인</h1>
                <div class="d-none" 
                th:class="${param.error} ? '' : 'd-none'";
                        style="color:red;
                        font-weight: bold;
                        text-align: center;
                        margin-bottom: 20px;">
                    아이디 또는 비밀번호가 일치하지 않습니다.
                </div>
                <form method="post">
                    <div class="d-flex align-items-center">
                        <label class="d-none">아이디</label><input name="uid" class="btn btn-cancel" type="text" placeholder="로그인 아이디를 입력하세요">
                    </div>
                    <div class="d-flex align-items-center">
                        <label class="d-none">비밀번호</label><input name="pwd" class="btn btn-cancel" type="password" placeholder="비밀번호">
                    </div>

                    <div class="d-flex align-items-center justify-content-center">
                        <input type="checkbox">
                        <label>로그인 저장</label>
                    </div>

                    <div class="d-flex align-items-center justify-content-center">
                        <input class="btn btn-default" type="submit" value="로그인">
                        <a class="btn btn-cancel" href="">취소하기</a>
                    </div>
                </form>
            </section>

            <section class="register">
                <h1 class="d-none">회원가입</h1>
                <a href="signup.html">회원가입</a>
                <a href="">아이디 찾기</a>
                <a href="">비밀번호 찾기</a>
            </section>

            <section class="social-login">
                <h1 class="d-none">소셜 로그인</h1>
                <span>또는 다음으로 로그인</span>
                <div>
                    <a class="icon icon-naver mx-2" href="">네이버 로그인</a>
                    <a class="icon icon-kakao mx-2" href="">카카오 로그인</a>
                    <a class="icon icon-youtube mx-2" href="http://localhost/login/oauth2/code/google">구글 로그인</a>
                </div>
            </section>
        </section>
    </main>

    <footer class="footer">
        <h2>알랜드(Rland)</h2>
        <div>
            copyright @ rland.co.kr 2022-2022 All Right Reservved. Contact admin@rland.co.kr for more information
        </div>
    </footer>
</body>
</html>

```

---

<br><br>

### 3) session 값 넘겨서 로그인 유지하기

- 쇼핑몰 예시처럼 로그인 안되면 index 페이지로 보내줄 것

---

<br><br>

#### a. 실습 코드 :

- admin/UserController.java

```java

@Controller
@RequestMapping("/user")
public class UserController {
    
    @Autowired
    private MemberService memberService;


    // 회원이 탈되되어도 사용자 이름이랑 식별자는 남긴다.
    @GetMapping("login")
    public String login(){
        return "user/login";
    }


    // 회원이 탈되되어도 사용자 이름이랑 식별자는 남긴다.
    @PostMapping("login")
    public String login(String uid, 
                        String pwd,
                        String returnURL,
                        HttpSession session){

        // Member member= memberService.getByUseName(uid);
        
        // 우리는 컨트롤러에서 입력만 받으면 된다. 
        // 컨트롤러에서 모든 것을 업무하면 안 된다. 그래서 위의 서비스는 사용하지 않는다. 
        // id를 가져와서 컨트롤러에서 처리하기 때문이다.
        boolean isValid = memberService.isValidMember(uid, pwd);

        System.out.println(isValid);
        
        if(isValid) {
            
            // session 케비넷을 사용하고 있는 User가 많다면,
            // 과부하가 생긴다.
            // 하지만, 로그인하면 이렇게 세션키를 발급!
            session.setAttribute("username", uid);
            
            // 
            if(returnURL != null)
                return "redirect:"+returnURL;

            return "redirect:/index";
        }

        return "redirect:login?error=sdfsdfsdf";
    }

}

```


- admin/MenuController.java

```java

@Controller("adminMenuController")
@RequestMapping("/admin/menu/")
public class MenuController {
	
	// 콩자루를 가져온다. 결합을 의미한다! 빈 객체 사용! 
	// 결합은 setInjection과 CompositionInjection이 있다.
	
	// 이것을 실행하려면 Application.java에서 실행해주자!
	// 객체가 같은 것이 2개가 있다면, DI하는데 문제가 있는 것이다. 그래서 @Qualifier로 구분해준다.
	// setter injection은 실행하거나 실행되는 영역이 생긴다. 바인딩 되기 전에 다른 작업을 처리할 수 있다.
	// 하지만, 코드 라인수가 가장 적은 '필드'에 @Autowired를 하여 DI를 한다. 

	@Autowired
	private MenuService service;
	
	// 400 에러는 데이터가 파라미터 인자가 없는 경우이다.
	// 403 에러는 권한 관련 에러이다. 
	// 405 에러는 처리메서드가 post요청인데 get요청만 있는 경우

	
	@RequestMapping("list")
	public String list(
			@RequestParam(name = "p", defaultValue = "1") int page, 
			@RequestParam(name = "c", required = false) Integer categoryId,
			@RequestParam(name = "q", required = false) String query,
			Model model,
			HttpSession session
			) throws UnsupportedEncodingException
	{
		// 세션 / 쿠키를 이용해서 사용자가 인증되었던 적이 있는지를 확인함.
		// if 너 로그인 했니?(인증한 적이 없으면 로그인을 다시 하러 가야 한다.)
		if(session.getAttribute("username")==null)
			return "redirect:/user/login?returnURL=/admin/menu/list";

		// 아니요 -> 로그인하고 와
		
		// if 너 로그인 햇니? 
		// 네 -> if(그럼 너 어드민 이니?)
		// 아니요 -> 권한이 없다~ 얘~
		
		// **세션아이디는 서버자원을 사용하는 것이기 때문에 인증을 하면 그때 키(세션아이디, 세션키)가 부여받게 된다.**

		List<MenuView> list = service.getViewList(page, categoryId, query);
		
		model.addAttribute("list", list);
		return "admin/menu/list";
	}
	
	@GetMapping("detail")
	public String detail(int id, Model model) {
		
		Menu menu = service.getById(id);
		
		model.addAttribute("menu", menu);

		
		return "admin/menu/detail";
	}
	
	// 등록폼을 주세요.
	// @RequestMapping("reg") 
	// -> service() 함수와 같다. : Get/Post를 내가 다 처리하는 매핑 
	
	@GetMapping("reg")
	public String reg() {
		return "/WEB-INF/view/admin/menu/reg.jsp";
	}
	
	// 폼입력해서 제출이요.
	@PostMapping("reg")
	public String reg(String title) {
		// 등록하고나서!
		System.out.println("메뉴 등록 완료");
		return "redirect:list";		
		// @Controller는 view단을 찾으므로 url을 입력해줘야한다. 
		// redirection은 reg라는 페이지에서 클라이언트가 list라는 url로 가라고 한다.
		// 경로가 더 이상 없다면 현재 경로에서 찾는다. 
		// 그 요청은 jsp파일의 form 태그에서 method post를 설정해줘야 한다. Post 요청이라서! 
	}
	
}

```



---

<br><br>

#### 4) 초기의 필터 만들기 

```java
package kr.co.rland.web.config;

import java.io.IOException;

import org.springframework.stereotype.Component;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;

@Component
public class AuthFilter implements Filter {
    
    // 인증을 위한 필터 만들기!
    // 따로 설정을 안 하면, 수문장이라서 해당 서비스 내부로 들여보내질 않는다.
    
    // 예전에는 이런 방식으로 필터를 만들었었다.
    private static final String[] authUrls = {
        "/admin/**","/member/**"
    };

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        

        // 사용자가 입력하는 uri와 url을 체킹한다. 에러가 발생했는지 알 수 있다.(로그인 실패 등등)
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String uri = httpRequest.getRequestURI();
        System.out.println(uri);
        
        String url = httpRequest.getRequestURI().toString();
        System.out.println(url);



        // FilterChain은 여러개 쓸 수 있어서 다음 Chain도 설정 해준다!
        
        System.out.println("입구 필터가 실행되었습니다.");
        
        chain.doFilter(request, response);

        System.out.println("출구 필터가 실행되었습니다.");  
        // 이렇게 하면, 여러번 필터가 발생하는데 모든 파일들에 대해 필터 처리를 해준다.

    }
}

```





---

<br><br>

#### 5) Spring Security 


- pom.xml 에 아래 라이브러리를 깔면, 

```xml

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>

```

```java
package kr.co.rland.web.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class RlandSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{

        http
        .authorizeHttpRequests()            // 권한 요청 
        .requestMatchers("/admin/**")    // url에 대한 패턴 권한 부여 
        .hasAnyRole("ADMIN")           // 어떤 사용자에 대한 권한 부여
        // **가 재귀 경로이다. 하부 구조 전부를 말한다.
        .requestMatchers("/member/**").hasAnyRole("ADMIN,MEMBER")
        .anyRequest().permitAll();  // 권한 부여주기

        // .hasAnyAutnullhority()  : Role_""가 기본 권한 방식,   
        // .hasAnyRole(null) : 앞에 Role_를 붙여줘서 역할만 바로 쓰면 된다.
        return null;
    }

}

```





















