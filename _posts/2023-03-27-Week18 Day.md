---
key: /2023/03/27/Week18-Day.html
title: TIL - 18주차 코드
tags: springboot thymeleaf lombok querystring REST RESTAPI JS event AJAX XHR callback Fetch JSON dataset Node PreviousSibling Promise
---

# 1. AJAX, REST API : 230327

<br>

### 1) View단에서 심어놓은 데이터를 JS에서 사용하기 최종 정리 :

- JS에서 자식 노드에서 부모 노드는 1개라서 부모 노드 찾기는 쉽다. 반대로 자식 노드는 여러 개이므로 한 번에 찾기가 힘들다.(여러 조건이 필요) 

<br>
- View단에서 심어놓은 데이터를 심기 위해서 html dataset을 이용한다. 하지만, 우리는 thymeleaf를 사용하기 때문에 타임리프에서 사용하는 dataset을 이용하게 된다.

<br>
- 위의 코드에서 `let categoryId =1;`로 데이터를 상수로 지정했지만, 우리가 원하는 형태는 사용자 입력에 의해서 데이터를 심어 놓고 JS에서는 그 심어놓은 데이터를 사용해야 한다.
	- html에서 `data-cid=${c.id}`로 `-`로 구분지어 dataset에 의해 데이터를 심었었다.
	- 이것을 JS에서는 el라는 변수에 담아서 사용하는데 el.dataset.cid 로 꺼내서 쓰며 html에서 심은 `-`로 구분된 dataset의 뒷부분 값으로 식별하여 사용한다.

<br>
- URL에 백틱을 사용하는데 이 백틱이 매우 중요하다!! (JSON 데이터를 꽂기 위해서!!) 그리고 이것은 비동기 처리 요청에서 사용된다.


<br>

#### a. HTML의 dataset 개념

- 아래 예시 코드처럼 html에서 `-`라는 구분자를 이용하여 dataset을 심고 JS에서 `.`라는 구분자를 이용하여 dataset을 꺼낸다.

```html
<div id="user" data-id="1234567890" data-user="carinaanand" data-date-of-birth>
  Carina Anand
</div>
```

```javascript
const el = document.querySelector("#user");

// el.id === 'user'
// el.dataset.id === '1234567890'
// el.dataset.user === 'carinaanand'
// el.dataset.dateOfBirth === ''
```


<br>

#### b. 타임리프의 dataset 사용법

- 타임리프에서는 th:attr 속성을 이용해서 `th:attr="data-cid=${c.id}"` 이렇게 dataset을 심는다. 
- dataset 심는 방법 : `<li th:attr="data-cid=${c.id}" class="" th:class="${#strings.equals(param.c, c.id)}?'menu-selected'" th:each="c: ${categoryList}" >`
			

<br>

#### c. dataset 최종 실습 코드** :

```html
<nav class="menu-category">
	<div>
		<h1 class="text-normal-bold">메뉴분류</h1>
	</div>
	<ul>
		<li class="" th:class="${param.c} ==null ? 'menu-selected'">
			<a href="list">전체</a>
		</li>
		
		<li th:attr="data-cid=${c.id}" class="" th:class="${#strings.equals(param.c, c.id)}?'menu-selected'" 
			th:each="c: ${categoryList}" >
			<a href="?c=1" th:href="@{list(c=${c.id})}" th:text="${c.name}">커피음료</a>
		</li>
	</ul>
</nav>

```

```javascript
window.addEventListener("load", function() {
	let ul = document.querySelector(".menu-category>ul");
	
	// 클릭 시 이벤트 요청 :
	// 1) AJAX에서 addEventListener 하지마 : 여러 함수를 쓸 때 사용한다.(함수 누적 시, 사용한다.)**
	// 2) AJAX에서 람다도 쓰지 : 람다는 지역화를 쓸 수가 없어서!!**
	// 3) 위의 2개는 css의 연장선에서 사용가능
	ul.onclick = function(e){
		
		// a태그는 기본 행위가 있어서 그것을 없애준다.
		e.preventDefault(); 
		
		// 이벤트 객체의 요소로서 target이 tagName이며 대문자이다.**
		let tagName = e.target.tagName;
		
		if(tagName != 'LI' && tagName != 'A'){	// li가 아니면 return;(종료)
			return;				// tagName은 반환값이 대문자인 경우가 많다. 
			
		}
	
		// JSON 데이터 사용하기 위해 우리는 데이터 수집을 해야 한다. 타겟이 없으면 부모노드로 올라가서 전체에서 찾는다!!
		let elLi = (tagName === 'LI')? e.target: e.target.parentNode;
		console.log(elLi.dataset.cid);
		// e.target.parentNode를 이해하기 위해서는 PreviousSibling(노드 순회) 개념 필요!!
		// Element(태그들이 객체화 모든 것들), Attr, Document 등등의 집중화된 것이 'Node' 객체이다.
		
		
		
		// 우리는 url에서 데이터를 심어줘야 한다. 이것은 html에서 'dataset'으로 심어준다! 
		// 구글 'mdn dataset' 검색하고 'thymeleaf dataset' 검색 -> th:attr로 심는다.
		let categoryId = elLi.dataset.cid;
		
		
		// 자바스크립트 코드를 외부에서 이용하기 위해서 XMLHttpRequest 객체 이용!!
		const request = new XMLHttpRequest();
		// open은 브라우저에서 url을 입력하는 것과 같다.
		
		// 메인 스레드는 잠궈버리면 안된다! 그래서 콜백함수를 사용한다. 
		// 콜백함수는 이벤트를 위임하는 것이다. 미리 설정해놓고 나중에 호출한다. 
		// 비동기 작업이 완료되면 호출한다.**
		// 비동기를 처리해서 따로 빠져버린다!!
		request.onload = function() {  
			
			// 이렇게 쓰면 JSON 객체에서 출력된다.
			let menus = JSON.parse(request.responseText);
			
			console.log(menus[0]);			// 같은 메뉴 1개만 출력한다. 
			// menus.forEach(e => console.log(e));	// 이렇게 하면, 클릭 시, 그 카테고리 Id를 가진 모든 리스트 출력 
		}
		
		// 이렇게 하면 JSON으로 심어진 데이터를 확인할 수 있다.	// 백틱 중요하다!! (JSON 데이터를 꽂기 위해서!!)
		request.open("GET", `http://localhost:8080/menus?c=${categoryId}`, true); 	// 동기 처리를 하면 문제가 많다. 그래서 비동기 처리를 하자!
		request.send();
		
	}
});
```

---

<br><br>

### 2) AJAX 정리 :

- 동기형 처리에서는 IO 작업이 대부분 이렇게 이루어지고 내부에서는 이미 매우 느려진다고 판단한다.

---

<br><br>

### 3) JS Node, Element 정리 :

#### a. Node

- `firstChild`, `lastChild` : 
	- 주석이나 공백도 포함하여 가리킨다.

<br>
- `parentNode`, `parentElement` : 
	- parentElement는 Element 객체에 있을 것 같지만 부모 객체인 Node에 있어서 이들은 DOM이 아니다.

<br>

#### b. Element

- `firstElementChild`, `lastElementChild` : 
	- firstChild와 다르게 Element용이다. 이것은 HTML Element에 있지 않고 Element 객체에서 가리킨다.  

<br>

#### c. children

- Element 객체를 의미한다.
- Element 기능이 훨씬더 효과적이다.
- childrenNode는 Node 객체에서 쓰는 children이다.
detail 페이지 목록 조회, reg 페이지 Date 날짜 db 연동, list-search 페이지 조회
<br>

#### d. previousSibling의 사용 이유

- 모든 Node를 대상으로 할건지, Element를 대상으로 할건지 판단가능!
- 그래서, previousSibling인지 previousElementSibling인지 상황에 따라 사용하자.


---

<br><br>

### 4) JS Node, Element 객체 공부 방법 :

- a. `mdn document` 검색

<br>
- b. `mdn`의 검색 내용에서 아래의 '명세서' 클릭 

<br>
- c. `WHATWG`에서 스펙 확인

<br>

#### 5) 최종 실습 코드 :

```javascript
window.addEventListener("load", function() {
	let ul = document.querySelector(".menu-category>ul");

	const menuList = document.querySelector(".menu-list");
	// 클릭 시 이벤트 요청 :
	// 1) AJAX에서 addEventListener 하지마 : 여러 함수를 쓸 때 사용한다.(함수 누적 시, 사용한다.)**
	// 2) AJAX에서 람다도 쓰지 : 람다는 지역화를 쓸 수가 없어서!!**
	// 3) 위의 2개는 css의 연장선에서 사용가능
	ul.onclick = function(e){
		
		// a태그는 기본 행위가 있어서 그것을 없애준다.
		e.preventDefault(); 
		
		// 이벤트 객체의 요소로서 target이 tagName이며 대문자이다.**
		let tagName = e.target.tagName;
		
		// if(!(tagName == 'LI' || tagName == 'A'))
		if(tagName != 'LI' && tagName != 'A'){	// li가 아니면 return;(종료)
			return;				// tagName은 반환값이 대문자인 경우가 많다. 
			
		}
	
		// JSON 데이터 사용하기 위해 우리는 데이터 수집을 해야 한다. 타겟이 없으면 부모노드로 올라가서 전체에서 찾는다!!
		let elLi = (tagName === 'LI')? e.target: e.target.parentNode;
		console.log(elLi.dataset.cid);
		// e.target.parentNode를 이해하기 위해서는 PreviousSibling(노드 순회) 개념 필요!!
		// Element(태그들이 객체화 모든 것들), Attr, Document 등등의 집중화된 것이 'Node' 객체이다.
		
		
		
		// 우리는 url에서 데이터를 심어줘야 한다. 이것은 html에서 'dataset'으로 심어준다! 
		// 구글 'mdn dataset' 검색하고 'thymeleaf dataset' 검색 -> th:attr로 심는다.
		let categoryId = elLi.dataset.cid;
		
		
		// 자바스크립트 코드를 외부에서 이용하기 위해서 XMLHttpRequest 객체 이용!!
		const request = new XMLHttpRequest();
		// open은 브라우저에서 url을 입력하는 것과 같다.
		
		// 메인 스레드는 잠궈버리면 안된다! 그래서 콜백함수를 사용한다. 
		// 콜백함수는 이벤트를 위임하는 것이다. 미리 설정해놓고 나중에 호출한다. 
		// 비동기 작업이 완료되면 호출한다.**
		// 비동기를 처리해서 따로 빠져버린다!!
		request.onload = function() {  
			
			// 이렇게 쓰면 JSON 객체에서 출력된다.
			let menus = JSON.parse(request.responseText);
			
			// console.log(menus[0]);			// 같은 메뉴 1개만 출력한다. 
			// menus.forEach(e => console.log(e));	// 이렇게 하면, 클릭 시, 그 카테고리 Id를 가진 모든 리스트 출력 
			
			// menuList.removeChild(menuList.firstElementChild);
			// menuList.children[0].remove();
			
			// a) while 문 이용해서 메뉴 1개 없애기!
//			while(menuList.firstElementChild){
//				
//				menuList.firstElementChild.remove();
//			}
			
			// b) for-in 문 이용해서 메뉴 1개 없애기!
			for(let i in menuList.firstElementChild){
				console.log(i);
				if(menuList.firstElementChild){
					menuList.firstElementChild.remove();
				}
			}
		}
		
		// 백틱은 템플릿이 가능한 문자이다. 데이터를 여기에 꽂을 것이라서.. 그래서 백틱이 필요하다!!
		// request.open("GET", `http://localhost:8080/menus?c=${el.dataset.cid}`, true); 	// 이렇게 하면 JSON으로 심어진 데이터를 확인할 수 있다.
		request.open("GET", `http://localhost:8080/menus?c=${categoryId}`, true); 	// 동기 처리를 하면 문제가 많다. 그래서 비동기 처리를 하자!
		request.send();
		// console.log(request.responseText);	// 아직은 콜백함수가 필요가 없다.(동기형이라서) 하지만, 비동기 처리를 하려면 콜백함수가 필요하다! 
	
	
		// ================== Fetch API ======================
		
		/*
		var requestOptions = {
			method: 'GET', 
			redirect: 'follow'
		};
		
		fetch ("http://localhost:8080/menus/617", requestOptions)
			.then (response => response.text () )
			.then (result => console.log (result))
			•catch (error => console.log('error', error));
		//======================================================
		
		//========= XHR (XmlHttpRequest) =======================
		var xhr = new XMLHttpRequest () ;
		xhr.withCredentials = true;
		
		xhr.addEventListener ("readystatechange", function () {
		if (this.readyState === 4) {
			console.log (this.responseText);
		
		}):
		
		xhr.open("GET", "http://localhost:8080/menus/617");
		
		xhr.send();
	
		*/
	}
});
```


