---
key: /2023/03/27/Week18-Day.html
title: TIL - 18주차 코드
tags: springboot thymeleaf lombok RESTAPI JS AJAX DOM Vue.js
---

# 1. AJAX, REST API : 230327

<br>

### 1) View단에서 심어놓은 데이터를 JS에서 사용하기 최종 정리 :

- JS에서 자식 노드에서 부모 노드는 1개라서 부모 노드 찾기는 쉽다. 반대로 자식 노드는 여러 개이므로 한 번에 찾기가 힘들다.(여러 조건이 필요) 

<br>
- View단에서 심어놓은 데이터를 심기 위해서 html dataset을 이용한다. 하지만, 우리는 thymeleaf를 사용하기 때문에 타임리프에서 사용하는 dataset을 이용하게 된다.

<br>
- 위의 코드에서 `let categoryId =1;`로 데이터를 상수로 지정했지만, 우리가 원하는 형태는 사용자 입력에 의해서 데이터를 심어 놓고 JS에서는 그 심어놓은 데이터를 사용해야 한다.
	- html에서 `data-cid=${c.id}`로 `-`로 구분지어 dataset에 의해 데이터를 심었었다.
	- 이것을 JS에서는 el라는 변수에 담아서 사용하는데 el.dataset.cid 로 꺼내서 쓰며 html에서 심은 `-`로 구분된 dataset의 뒷부분 값으로 식별하여 사용한다.

<br>
- URL에 백틱을 사용하는데 이 백틱이 매우 중요하다!! (JSON 데이터를 꽂기 위해서!!) 그리고 이것은 비동기 처리 요청에서 사용된다.


<br>

#### a. HTML의 dataset 개념

- 아래 예시 코드처럼 html에서 `-`라는 구분자를 이용하여 dataset을 심고 JS에서 `.`라는 구분자를 이용하여 dataset을 꺼낸다.

```html
<div id="user" data-id="1234567890" data-user="carinaanand" data-date-of-birth>
  Carina Anand
</div>
```

```javascript
const el = document.querySelector("#user");

// el.id === 'user'
// el.dataset.id === '1234567890'
// el.dataset.user === 'carinaanand'
// el.dataset.dateOfBirth === ''
```


<br>

#### b. 타임리프의 dataset 사용법

- 타임리프에서는 th:attr 속성을 이용해서 `th:attr="data-cid=${c.id}"` 이렇게 dataset을 심는다. 
- dataset 심는 방법 : `<li th:attr="data-cid=${c.id}" class="" th:class="${#strings.equals(param.c, c.id)}?'menu-selected'" th:each="c: ${categoryList}" >`
			

<br>

#### c. dataset 최종 실습 코드** :

```html
<nav class="menu-category">
	<div>
		<h1 class="text-normal-bold">메뉴분류</h1>
	</div>
	<ul>
		<li class="" th:class="${param.c} ==null ? 'menu-selected'">
			<a href="list">전체</a>
		</li>
		
		<li th:attr="data-cid=${c.id}" class="" th:class="${#strings.equals(param.c, c.id)}?'menu-selected'" 
			th:each="c: ${categoryList}" >
			<a href="?c=1" th:href="@{list(c=${c.id})}" th:text="${c.name}">커피음료</a>
		</li>
	</ul>
</nav>

```

```javascript
window.addEventListener("load", function() {
	let ul = document.querySelector(".menu-category>ul");
	
	// 클릭 시 이벤트 요청 :
	// 1) AJAX에서 addEventListener 하지마 : 여러 함수를 쓸 때 사용한다.(함수 누적 시, 사용한다.)**
	// 2) AJAX에서 람다도 쓰지 : 람다는 지역화를 쓸 수가 없어서!!**
	// 3) 위의 2개는 css의 연장선에서 사용가능
	ul.onclick = function(e){
		
		// a태그는 기본 행위가 있어서 그것을 없애준다.
		e.preventDefault(); 
		
		// 이벤트 객체의 요소로서 target이 tagName이며 대문자이다.**
		let tagName = e.target.tagName;
		
		if(tagName != 'LI' && tagName != 'A'){	// li가 아니면 return;(종료)
			return;				// tagName은 반환값이 대문자인 경우가 많다. 
			
		}
	
		// JSON 데이터 사용하기 위해 우리는 데이터 수집을 해야 한다. 타겟이 없으면 부모노드로 올라가서 전체에서 찾는다!!
		let elLi = (tagName === 'LI')? e.target: e.target.parentNode;
		console.log(elLi.dataset.cid);
		// e.target.parentNode를 이해하기 위해서는 PreviousSibling(노드 순회) 개념 필요!!
		// Element(태그들이 객체화 모든 것들), Attr, Document 등등의 집중화된 것이 'Node' 객체이다.
		
		
		
		// 우리는 url에서 데이터를 심어줘야 한다. 이것은 html에서 'dataset'으로 심어준다! 
		// 구글 'mdn dataset' 검색하고 'thymeleaf dataset' 검색 -> th:attr로 심는다.
		let categoryId = elLi.dataset.cid;
		
		
		// 자바스크립트 코드를 외부에서 이용하기 위해서 XMLHttpRequest 객체 이용!!
		const request = new XMLHttpRequest();
		// open은 브라우저에서 url을 입력하는 것과 같다.
		
		// 메인 스레드는 잠궈버리면 안된다! 그래서 콜백함수를 사용한다. 
		// 콜백함수는 이벤트를 위임하는 것이다. 미리 설정해놓고 나중에 호출한다. 
		// 비동기 작업이 완료되면 호출한다.**
		// 비동기를 처리해서 따로 빠져버린다!!
		request.onload = function() {  
			
			// 이렇게 쓰면 JSON 객체에서 출력된다.
			let menus = JSON.parse(request.responseText);
			
			console.log(menus[0]);			// 같은 메뉴 1개만 출력한다. 
			// menus.forEach(e => console.log(e));	// 이렇게 하면, 클릭 시, 그 카테고리 Id를 가진 모든 리스트 출력 
		}
		
		// 이렇게 하면 JSON으로 심어진 데이터를 확인할 수 있다.	// 백틱 중요하다!! (JSON 데이터를 꽂기 위해서!!)
		request.open("GET", `http://localhost:8080/menus?c=${categoryId}`, true); 	// 동기 처리를 하면 문제가 많다. 그래서 비동기 처리를 하자!
		request.send();
		
	}
});
```

---

<br><br>

### 2) AJAX 정리 :

- 동기형 처리에서는 IO 작업이 대부분 이렇게 이루어지고 내부에서는 이미 매우 느려진다고 판단한다.

---

<br><br>

### 3) JS Node, Element 정리 :

#### a. Node

- `firstChild`, `lastChild` : 
	- 주석이나 공백도 포함하여 가리킨다.

<br>
- `parentNode`, `parentElement` : 
	- parentElement는 Element 객체에 있을 것 같지만 부모 객체인 Node에 있어서 이들은 DOM이 아니다.

<br>

#### b. Element

- `firstElementChild`, `lastElementChild` : 
	- firstChild와 다르게 Element용이다. 이것은 HTML Element에 있지 않고 Element 객체에서 가리킨다.  

<br>

#### c. children

- Element 객체를 의미한다.
- Element 기능이 훨씬더 효과적이다.
- childrenNode는 Node 객체에서 쓰는 children이다.

<br>

#### d. previousSibling의 사용 이유

- 모든 Node를 대상으로 할건지, Element를 대상으로 할건지 판단가능!
- 그래서, previousSibling인지 previousElementSibling인지 상황에 따라 사용하자.


---

<br><br>

### 4) JS Node, Element 객체 공부 방법 :

- a. `mdn document` 검색

<br>
- b. `mdn`의 검색 내용에서 아래의 '명세서' 클릭 

<br>
- c. `WHATWG`에서 스펙 확인

<br>

#### 5) 최종 실습 코드 :

```javascript
window.addEventListener("load", function() {
	let ul = document.querySelector(".menu-category>ul");

	const menuList = document.querySelector(".menu-list");
	// 클릭 시 이벤트 요청 :
	// 1) AJAX에서 addEventListener 하지마 : 여러 함수를 쓸 때 사용한다.(함수 누적 시, 사용한다.)**
	// 2) AJAX에서 람다도 쓰지 : 람다는 지역화를 쓸 수가 없어서!!**
	// 3) 위의 2개는 css의 연장선에서 사용가능
	ul.onclick = function(e){
		
		// a태그는 기본 행위가 있어서 그것을 없애준다.
		e.preventDefault(); 
		
		// 이벤트 객체의 요소로서 target이 tagName이며 대문자이다.**
		let tagName = e.target.tagName;
		
		// if(!(tagName == 'LI' || tagName == 'A'))
		if(tagName != 'LI' && tagName != 'A'){	// li가 아니면 return;(종료)
			return;				// tagName은 반환값이 대문자인 경우가 많다. 
			
		}
	
		// JSON 데이터 사용하기 위해 우리는 데이터 수집을 해야 한다. 타겟이 없으면 부모노드로 올라가서 전체에서 찾는다!!
		let elLi = (tagName === 'LI')? e.target: e.target.parentNode;
		console.log(elLi.dataset.cid);
		// e.target.parentNode를 이해하기 위해서는 PreviousSibling(노드 순회) 개념 필요!!
		// Element(태그들이 객체화 모든 것들), Attr, Document 등등의 집중화된 것이 'Node' 객체이다.
		
		
		
		// 우리는 url에서 데이터를 심어줘야 한다. 이것은 html에서 'dataset'으로 심어준다! 
		// 구글 'mdn dataset' 검색하고 'thymeleaf dataset' 검색 -> th:attr로 심는다.
		let categoryId = elLi.dataset.cid;
		
		
		// 자바스크립트 코드를 외부에서 이용하기 위해서 XMLHttpRequest 객체 이용!!
		const request = new XMLHttpRequest();
		// open은 브라우저에서 url을 입력하는 것과 같다.
		
		// 메인 스레드는 잠궈버리면 안된다! 그래서 콜백함수를 사용한다. 
		// 콜백함수는 이벤트를 위임하는 것이다. 미리 설정해놓고 나중에 호출한다. 
		// 비동기 작업이 완료되면 호출한다.**
		// 비동기를 처리해서 따로 빠져버린다!!
		request.onload = function() {  
			
			// 이렇게 쓰면 JSON 객체에서 출력된다.
			let menus = JSON.parse(request.responseText);
			
			// console.log(menus[0]);			// 같은 메뉴 1개만 출력한다. 
			// menus.forEach(e => console.log(e));	// 이렇게 하면, 클릭 시, 그 카테고리 Id를 가진 모든 리스트 출력 
			
			// menuList.removeChild(menuList.firstElementChild);
			// menuList.children[0].remove();
			
			// a) while 문 이용해서 메뉴 전부 없애기!
//			while(menuList.firstElementChild){
//				
//				menuList.firstElementChild.remove();
//			}
			
			// b) for-in 문 이용해서 메뉴 전부 없애기!
			for(let i in menuList.firstElementChild){
				console.log(i);
				if(menuList.firstElementChild){
					menuList.firstElementChild.remove();
				}
			}
		}
		
		// 백틱은 템플릿이 가능한 문자이다. 데이터를 여기에 꽂을 것이라서.. 그래서 백틱이 필요하다!!
		// request.open("GET", `http://localhost:8080/menus?c=${el.dataset.cid}`, true); 	// 이렇게 하면 JSON으로 심어진 데이터를 확인할 수 있다.
		request.open("GET", `http://localhost:8080/menus?c=${categoryId}`, true); 	// 동기 처리를 하면 문제가 많다. 그래서 비동기 처리를 하자!
		request.send();
		// console.log(request.responseText);	// 아직은 콜백함수가 필요가 없다.(동기형이라서) 하지만, 비동기 처리를 하려면 콜백함수가 필요하다! 
	
	
		// ================== Fetch API ======================
		
		/*
		var requestOptions = {
			method: 'GET', 
			redirect: 'follow'
		};
		
		fetch ("http://localhost:8080/menus/617", requestOptions)
			.then (response => response.text () )
			.then (result => console.log (result))
			•catch (error => console.log('error', error));
		//======================================================
		
		//========= XHR (XmlHttpRequest) =======================
		var xhr = new XMLHttpRequest () ;
		xhr.withCredentials = true;
		
		xhr.addEventListener ("readystatechange", function () {
		if (this.readyState === 4) {
			console.log (this.responseText);
		
		}):
		
		xhr.open("GET", "http://localhost:8080/menus/617");
		
		xhr.send();
	
		*/
	}
});

```

<br><br>

# 2. 230328

### 1) 멘토 피드백

- 개발에서 정답은 없다.

<br>
- 증권사에서는 유저 정보를 지워달라고 할 때, 레코드를 지울 때, 마지막 레코드부터 지워야해서.. VIEW 테이블을 사용하지 않는다. 그래서, 엔드유저에 따라 달라진다.  

<br>
- 증권사는 경험이 없는 신입은 안 뽑는다.

<br>
- 데이터 타입이 굉장히 중요하다!
	- float형은 요즘에는 잘 안쓰고 증권사에서 double을 사용한다. 경우의 수가 많기 때문이다.

<br>
- String은 클래스..


<br>
- 멘토 피드백 : 
	- 기획서 만들기(피그마 이용해서 스토리 보드 만들기!),
	- 모든 스펙 문서화하기
		- 아키텍처 명세 : 변수명과 메서드명등 정리
		- ERD : 
		- API 명세 : URL 정리
		- WBS
- 


<br>
- 실무에서 물어볼 것 : 
	- 서버를 어떻게 운영하는지? 
	- 실무에서 실제 서버에서 웹서버는 1개만 이용하는지? 
	- 그때 쓰는 플랫폼은 뭐가 있는지? 게이트웨이는 어떻게 사용하는지? 무엇인지? 
	- 팀원들은 몇명이서 사용하는지? 업무는 어떻게 분업하는지? 실무에서 실력자들이 몇명이 분포되는지?
	- 레이어는 각자가 맡아서 진행하는지? 다 만드는지?
	- 한 프로젝트가 DB 1개만 쓰는지?
	- 각 프로젝트마다 DB가 다 다른지? 1개씩만 쓰는지?

<br>
- `파이어 베이스` : 클라우드 데이터 베이스라서 DB가 없는 경우에 클라우드 DB를 사용한다. 앱 개발시, 사용한다.  


---

<br>

### 0) AJAX 정리 :

#### a. 동기형 요청

- 동기형으로 요청하는 방법은 단순히 open 메소드에 마지막 인자를 false로 설정하면 된다.
	- `request.open("GET", url, false);`

- 그러면 데이터를 요청하는 send() 메소드 이후에 그 데이터가 도착하기 전까지 모든 흐름은 멈추고 결과가 올 때까지 기다리게 된다. 이런 동기형은 도착한 데이터를 사용하는 위치를 분명히 알 수 있어서 다음처럼 그 다음 줄에 도착한 결과를 사용하는 코드를 순차적으로 입력하면 된다.

```javascript

request.open(..., false);
request.send();  // 데이터가 도착할 때까지 기다리는 함수 Blocking 함수
request.responseText 를 사용하는 코드

```

- 문제는 이런 방식은 순차적으로 실행되는 방식을 따르기 때문에 코드를 이해하는 난이도는 낮아지지만 네트워크 상태가 좋지 않거나 서버의 응답이 느린 경우는 …. 화면이 멈추는 일이 발생한다.

- 이런 방식의 문제를 해결하려면 요청 방식을 비동기로 처리해야 한다.


<br>

#### b. 비동기형 요청

- 비동기형으로 요청하는 방법은 앞에서 언급했던 것처럼 open 메소드에서 마지막 인자를 true로 설정하거나 아예 그 인자를 설정하지 않으면 기본값이 비동기처리가 된다.

```javascript

request.open("GET", url, true);  또는 request.open("GET", url);

```

- 이렇게 비동기로 요청을 설정하게 되면 흐름은 순서와 달라지게 된다.

```javascript

request.send() // 비동기로 요청했으므로 데이터가 도착할 때까지 흐름은 새로 만들어지고 메인 흐름은 막지 않고 바로 패스 시킨다.
request.responseText 를 사용하는 코드

```

- 따라서 responseText는 데이터를 받지 못한 상태에서 사용될 수 있기 때문에 이 부분에서 오류가 발생할 수 있다.

<br>

#### c. Callback 함수를 이용한 데이터 처리

- 앞서 언급했던 것처럼 비동기로 요청하게 되면 요청 이후의 데이터는 별도의 다른 흐름에서 처리되므로 그 별도의 흐름에서 내가 처리할 로직을 실행할 수 있도록 함수를 위임하는 방법을 사용한다.

- 위임된 함수는 바로 실행되는 것이 아니라 나중에 load가 완료되면 실행되는 또는 호출되는 함수라고 해서 붙여진 이름이 CallBack이다.

- 이 함수는 메인 흐름에서 호출되지 않으며 request가 가지는 별도의 흐름에서 로드가 완료되는 순간 실행되는 함수이기 때문에 이벤트 함수라고도 불리기도 한다.

- 따라서 이벤트는 대부분 비동기로 실행되며 그 때 위임되는 함수를 위임함수, 이벤트 함수, 콜백함수 등으로 다양하게 불린다.

---

<br><br>

### 1) AJAX : innerHTML 이용해서 메뉴 전부 없애기

- innerHTML 이용

```javascript
			// c) menuList.innerHTML 이용해서 메뉴 전부 없애기!
			
//			// a. 값을 그냥 텍스트형태로 넘긴다!
//			menuList.innerText = "<span style='color:blue'>test hello</span>";	
//			
//			// b. HTML 태그 자체를 인코딩하여 넘겨버린다. 
//			menuList.innerHTML = "<span style='color:blue'>test hello</span>";	
//			
//			// c. 다 지우기 위해서 가장 간단히 이것도 가능한다. 
			menuList.innerHTML = ""; 
```


---

<br><br>

### 2) AJAX : 목록 만들어서 다시 채우기!

- JS 템플릿 문자열 이용하기 : ``, ${}
- insertAdjacentHTML 이용(vs insertAdjacentElement)

```javascript
			// ** 문제 2 :
			 
			// ** 목록을 만들어서 다시 채우기!
			// 방법 1 : DOM 객체를 직접 생성해서 채우기 
				
			// ** 엘리먼트는 본래의 다큐먼트의 기능을 이용하여 create 한다. **
			
			// a. 엘리먼트는 다큐먼트의 create 기능을 이용하여 섹션 만들기!
			// ** 노드 2개를 만들어서 직접 만드는 방법 : document 객체를 만들고 append해서 데이터만 바꿔준다.(AJAX)
			// - 위에서 기존 메뉴를 지우고 새로 html을 다시 만드는 과정이다!!**
//			let menuSection = document.createElement("section");
//			
//			// css의 class 이름인데 예약어라서 className을 사용. 
//			// 이렇게 class는 조금 다르게 처리해준다.
//			menuSection.className = "menu";
//			
//			let form = document.createElement("form");
//			form.className = "";
//			
//			//menuSection.appendChild(form);	// Node interface의 기능 
//			menuSection.append(form);	// Element interface의 기능 
//			
//			menuList.append(menuSection);
			
			
			// 방법 2 : 템플릿 문자열(``) 이용하기! -> 이게 정답!!
			// ${menus[0].name}는 자바스크립트 ES6 템플릿 문자열 ``안의 
			// 데이터를 꽂을 수 있는 방법이다. 
			
//      		let template = `<section class="menu">
//		                <form class="">
//		                    <h1><span>${menus[0].name}</h1> 
//		                    <div class="menu-img-box">
//		                        <a href="detail.html"><img class="menu-img" src="/image/product/12.png"></a>
//		                    </div>    
//		                    <div class="menu-price">4500 원</div>
//		                    <div class="menu-option-list">
//		                        <span class="menu-option">
//		                            <input class="menu-option-input" type="checkbox">
//		                            <label>ICED</label>
//		                        </span>            
//		                        <span class="menu-option ml-2">
//		                            <input class="menu-option-input" type="checkbox">
//		                            <label>Large</label>
//		                        </span>
//		                    </div>
//		                    <div class="menu-button-list">
//		                        <input class="btn btn-fill btn-size-1 btn-size-1-lg" type="submit" value="담기">
//		                        <input class="btn btn-line btn-size-1 btn-size-1-lg ml-1" type="submit" value="주문하기">
//		                    </div>
//		                </form>
//		            </section>`;
//	        
//	        menuList.innerHTML = template;

			
			// 방법 2-1 : 문제점 있는 템플릿 문자열(``) 이용 방법 : for of 이용!
			// 이 방법은 문제점이 많다....
			for(let m of menus) {
				
				let template = `<section class="menu">
		                <form class="">
		                    <h1><span>${m.name}</span>/<span style="font-size:11px;">${m.categoryName}<span></h1> 
		                    <div class="menu-img-box">
		                        <a href="detail?id=${m.id}"><img class="menu-img" src="/image/product/12.png"></a>
		                    </div>    
		                    <div class="menu-price">${m.price}</div>
		                    <div class="menu-option-list">
		                        <span class="menu-option">
		                            <input class="menu-option-input" type="checkbox">
		                            <label>ICED</label>
		                        </span>            
		                        <span class="menu-option ml-2">
		                            <input class="menu-option-input" type="checkbox">
		                            <label>Large</label>
		                        </span>
		                    </div>
		                    <div class="menu-button-list">
		                        <input class="btn btn-fill btn-size-1 btn-size-1-lg" type="submit" value="담기">
		                        <input class="btn btn-line btn-size-1 btn-size-1-lg ml-1" type="submit" value="주문하기">
		                    </div>
		                </form>
		            </section>`;
	        
	        // menuList.innerHTML += template; 
	        // '+='의 문자열을 누적하는 것이 오버헤드가 발생
	        // 누적할 때마다 새로 HTML 문서를 계속 새로 만든다.
	        // 부하가 제곱수 만큼 늘어나서 성능이 안 좋다!!
	        
	        // 그래서 사용하는 방법이 insertAdjacentElement를 사용한다.
	        // ** insertAdjacentElement가 아니라 insertAdjacentHTML을 이용한다!
	        // ** 차이점 : 
	        menuList.insertAdjacentHTML("beforeend",template);
	        
	        // 그 위치에서 그 다음 위치에 새로 들어간다. 그래서 afterend 기능을 사용한다.

```


---

<br><br>

### 3) AJAX : elLi가 선택되면 버튼 색깔 바꿔주기

- className, classList의 toggle이나 add 이용

```javascript
	// 클릭 시 이벤트 요청 :
	// 1) AJAX에서 addEventListener 하지마 : 여러 함수를 쓸 때 사용한다.(함수 누적 시, 사용한다.)**
	// 2) AJAX에서 람다도 쓰지 : 람다는 지역화를 쓸 수가 없어서!!**
	// 3) 위의 2개는 css의 연장선에서 사용가능
	ul.onclick = function(e){
		
		// a태그는 기본 행위가 있어서 그것을 없애준다.
		e.preventDefault(); 
		
		// 이벤트 객체의 요소로서 target이 tagName이며 대문자이다.**
		let tagName = e.target.tagName;
		
		// if(!(tagName == 'LI' || tagName == 'A'))
		if(tagName != 'LI' && tagName != 'A'){	// li가 아니면 return;(종료)
			return;				// tagName은 반환값이 대문자인 경우가 많다. 
			
		}
	
		// JSON 데이터 사용하기 위해 우리는 데이터 수집을 해야 한다. 타겟이 없으면 부모노드로 올라가서 전체에서 찾는다!!
		let elLi = (tagName === 'LI')? e.target: e.target.parentNode;
		
		// ** 문제 3 : elLi가 선택되면 버튼 색깔 바꿔주기!!
		
		// ** className을 마구잡이로 사용하면 안 된다! 같은 className을 쓰는 모든 태그에 스타일이 다 겹치기 때문이다.
		// elLi.className = "menu-selected";
		// 그래서, classList의 toggle을 이용하거나 add를 이용한다.
		// elLi.classList.toggle("menu-selected");
		// elLi.classList.add("menu-selected");
		
		// 1) 기존의 것을 찾기 위해서 반복문을 쓰지 말고 if문으로 해결!
		let curLi = ul.querySelector("li.menu-selected");
		
//		이건 내가 한 방식
//		if(curLi === elLi){
//			elLi.classList.add("menu-selected");
//		}
//		else if(curLi !== elLi){
//			elLi.classList.add("menu-selected");
//			curLi.classList.remove("menu-selected");
//		}

		// ** 2) 다를 때만 비교하면 된다! 같을 때는 비교 안해도 된다!!
		if(curLi !== elLi){
			elLi.classList.add("menu-selected");
			curLi.classList.remove("menu-selected");
		}
		
		// ** 3) 같으면 이벤트를 끝내버리고 다를 때만 데이터를 요청하면 된다!(이게 정답!!)
		if(curLi === elLi)
		 	return;
	
		elLi.classList.add("menu-selected");
		curLi.classList.remove("menu-selected");
	}

```

---

<br><br>

### 4) AJAX : 검색 기능 만들기

- 검색 기능 만들기 

- 이렇게 만들면 url이 깔끔해진다. 

- 쿼리스트링은 페이지의 상태값을 말한다.


```javascript
window.addEventListener("load", function() {
	
	let ul = document.querySelector(".menu-category>ul");
	const menuList = document.querySelector(".menu-list");
	
	// ** 문제 4 : 검색 기능 만들기 
	
	// ** 항상 버튼을 1개 만들면 테스트 해보기!
	const form = document.querySelector('.search-header form');
	const findButton = document.querySelector('.icon-find');
	// console.log(findButton);
	
	// **검색 기능 : 돋보기 누르면 검색 기능이 구현!**
	// 카테고리 별 검색도 가능하다..?
	findButton.onclick = function(e){
		
		// 본래 HTML 태그의 기능(default 행위)이 있어서 기본 행위를 막아내는 함수이다.**
		// 이것은 이미지의 기본 기능으로 드래그 기능이 있어서 기능 중 드래그 드랍 기능을 사용할 때도 기본 기능을 막아 줘야 한다.
		e.preventDefault();
		
		// input 태그의 값은 여기서 뽑아낸다.**
		const queryInput = form.querySelector("input[name=q]");
		let query = queryInput.value;
		
		console.log(queryInput.value);	
		
		// 이제는 전체 검색인지, 카테고리 검색인지 구별해서 검색 구현을 해야 한다.**
		
// ** 이 부분은 계속 반복적이라서 추후에 함수로 따로 만들어서 사용하자!
//		const request = new XMLHttpRequest();
//		
//		request.onload = function() {  
//			let menus = JSON.parse(request.responseText);
//		}
//		
//		request.open("GET", `http://localhost:8080/menus?c=${categoryId}`, true); 	// 동기 처리를 하면 문제가 많다. 그래서 비동기 처리를 하자!
//		request.send();
		
		const request = new XMLHttpRequest();
		
		request.onload = function() {  
			let menus = JSON.parse(request.responseText);
			console.log(menus);
			
			bind(menus);
		}
		
		request.open("GET", `http://localhost:8080/menus?q=${query}`, true); 	// 동기 처리를 하면 문제가 많다. 그래서 비동기 처리를 하자!
		request.send();
		
	}

```

```javascript

// binding되면서 request까지 기능이되어서 load라고 하자!
function bind(menus){

		menuList.innerHTML = ""; 
		
		// 방법 2-1 : 문제점 있는 템플릿 문자열(``) 이용 방법 : for of 이용!
		// 이 방법은 문제점이 많다....
		for(let m of menus) {
			
			let template = `<section class="menu">
	                <form class="">
	                    <h1><span>${m.name}</span>/<span style="font-size:11px;">${m.categoryName}<span></h1> 
	                    <div class="menu-img-box">
	                        <a href="detail?id=${m.id}"><img class="menu-img" src="/image/product/12.png"></a>
	                    </div>    
	                    <div class="menu-price">${m.price}</div>
	                    <div class="menu-option-list">
	                        <span class="menu-option">
	                            <input class="menu-option-input" type="checkbox">
	                            <label>ICED</label>
	                        </span>            
	                        <span class="menu-option ml-2">
	                            <input class="menu-option-input" type="checkbox">
	                            <label>Large</label>
	                        </span>
	                    </div>
	                    <div class="menu-button-list">
	                        <input class="btn btn-fill btn-size-1 btn-size-1-lg" type="submit" value="담기">
	                        <input class="btn btn-line btn-size-1 btn-size-1-lg ml-1" type="submit" value="주문하기">
	                    </div>
	                </form>
	            </section>`;
        
        // menuList.innerHTML += template; 
        // '+='의 문자열을 누적하는 것이 오버헤드가 발생
        // 누적할 때마다 새로 HTML 문서를 계속 새로 만든다.
        // 부하가 제곱수 만큼 늘어나서 성능이 안 좋다!!
        
        // 그래서 사용하는 방법이 insertAdjacentElement를 사용한다.
        // ** insertAdjacentElement가 아니라 insertAdjacentHTML을 이용한다!
        // ** 차이점 : 
        menuList.insertAdjacentHTML("beforeend",template);
        
        // 그 위치에서 그 다음 위치에 새로 들어간다. 그래서 afterend 기능을 사용한다.
        }
}
```

---

<br><br>

### 5) DOM, JQuery 흐름

- DOM은 브라우저 사이에 움직이는 객체들이다. 사용자 입력(입출력)을 DOM을 통해 입력받거나 수반한다. Javascript가 실제로 움직이게 해주는 것이며 기반이 되는 것이다. 

<br>
- JQuery는 DOM을 대신해주는 친구이다. DOM을 안쓰려고 JQuery를 사용한다. 하지만 이것은 IE를 쓰려고 했었는데 IE가 망해버림..
	- DDD 공법으로 깔끔하게 만드는 것이 아니라 DOM을 대신해서 사용했던 것이다. 하지만 IE가 망해버림.(MS의 브라우저가 사라짐.)
	
<br>
- 그 다음에 등장한 것이 MVC 프레임워크인데 DOM을 대신해주는 MVC 프레임워크를 써라!! 그것은 Angular나 React나 Vue.js를 이용한다.

<br>
- DOM을 이용하는 방법 : 
	- 노드를 얻기 위해서 querySelector를 쓸 수 있는지 
	- 노드 수정, 삭제, 등록을 할 수 있는지 
	- 이벤트를 다뤄 봤는지? 드래그 앤 드랍 이벤트, 필 이벤트, 페이지로드 이벤트, 키보드 이벤트
	- 이제는 DOM의 기능을 쓰면 안 된다. 프레임워크를 쓰는 것이 맞다.



---

<br><br>

### 6) Vue.js 시작!**

- DOM을 직접 사용하기 보다는 MVC 프레임워크를 이용하자!

- DOM 개발에서 라이브러리가 대신 해준다. 

- DOM 입/출력에 관한 코드가 가장 길기 때문이다.

- MVW 방식이다. DOM 프로그래밍과 차이





---

<br><br>

# 3. 230329

- Vue.js MVC가 진짜다. 백엔드 MVC는 단방향

- 현장에서 모르겠으면 Vue.js를 사용해라!!

### 1) Vue.js 사용하는 방법 :

- 먼저 ,html에 아래의 script 태그를 적어주면 된다. 그리고 .js 파일에서 스크립트 코드를 적어주자

```javascript
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```

<br>
- 보통은 global vue.js를 사용하고 여러 페이지를 만들면, layout에서 위의 태그를 쓰거나 한 페이지만 만들면, 그 페이지에서만 사용한다!

---

<br>

### 2) Vue.js 기초 실습 

- 계산기에서 적용

<br>
#### a. 실습 코드 : 
- calc.html

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Insert title here</title>
</head>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script src="./calc2.js" defer="defer"></script>

<body>
	<section id="calc">
	    <h1>덧셈 계산기</h1>
	    <form>
	        <fieldset>
				<!-- {{x}}는 innerTxt에서 사용한다. -->
	            <legend>계산기 입력폼</legend>
	            <div>
	                <label>x:</label>
				<!-- 	v-bind:value 이렇게 하는 것은 원웨이 방식인데 문제가 많다. -->
	                <!-- :value="x" 이렇게도 사용 가능하다! -->
					<!-- 이전까지는 원웨이 방식인데 이제 사용자 입력도 가능한 투웨이 방식인 v-model을 이용하자! -->
<!-- 					@input은 oninput과 같아서 값이 변경되면 다 바뀐다. -->
					<input dir="rtl" name="x" v-model.trim.number="x" @input="this.z-this.x;">
	                <label>y:</label>
	                <input dir="rtl" name="y" v-model.number="y">
	                <span>=</span>
<!-- 					v-text의 오버라이드 에러가 발생해서 기본 텍스트 지우기! -->
	                <span v-text="z"></span>
	            </div>
	            <hr>
	            <div>	<!-- v-on:click.prevent=""과 @.click.prevent=""가 가능하다 --> 
	                <!-- @click.prevent.once는 1번만 사용된다! 이렇게하면 사용하고 나서 prevent는 다 사라진다! --> 
					<input type="submit" value="초기화" @click.prevent="resetHandler">
	                <input type="submit" value="계산하기" @click.prevent="calcHandler">
	            </div>
	        </fieldset>
	    </form>
	</section>

</html>
</body>
```

---

<br>
- DOM만 사용한 원래 코드 : 

```javascript
window.addEventListener("load", function () {
    const inputs = document.querySelectorAll("input");
    const xInput = inputs[0];
    const yInput = inputs[1];
    const resetButton = inputs[2];
    const submitButton = inputs[3];
    const resultSpan = document.querySelector("form span:last-child");
    resetButton.onclick = (e) => {
        e.preventDefault();
        xInput.value = 0;
        yInput.value = 0;
        console.log(e);
    };
    // 1way binding
    submitButton.onclick = (e) => {
        e.preventDefault();
        let x = parseInt(xInput.value);
        let y = parseInt(yInput.value);
        let result = x + y;
        resultSpan.innerText = result;
        console.log(e);
    };
    // 2way binding
    xInput.oninput = (e) => {
        let x = parseInt(xInput.value);
        let y = parseInt(yInput.value);
        let result = x + y;
        resultSpan.innerText = result;
    };
    yInput.oninput = (e) => {
        let x = parseInt(xInput.value);
        let y = parseInt(yInput.value);
        let result = x + y;
        resultSpan.innerText = result;
    };
});

```

---

<br>

- Vue.js를 사용한 JS 코드 : 

```javascript
Vue
.createApp({
	data(){		// 데이터를 반환하는 것이 모델을 반환한다.
//		return {	// 이렇게 쓰는 것이 JSON 형태이다. 
//			x:20,
//			y:30 
//		};
			let x = 0;
			let y = 0;
			let z = 0;
				
//			html에서 v-text="z"를 쓰기 위해서는 model이 필요하다!
			return {x,y,z};	// {}로 이렇게 쓰면, 모델(Vue의 모델)이다. 이것은 1way방식이다.
							// 2way 방식으로 고치자!! 입력 컨트롤에서 사용된다.
			
		// 이제 이벤트 함수를 사용하기!!
			
	},
	
	// 객체 안에 함수를 정의한다.
	methods: {
		calcHandler(e){
			
			// model을 return만 하면 바로 꽂힌다.
			// let z = parsetInt(this.x) + parseInt(this.y);
			// v-text="z"를 쓰기 위해서는 model이 필요하다!
			// 모델이 input, select, textarea에 사용된다!!
			// JS의 parseInt말고도 html에서 vue.js의 number도 가능하다!
			// this.z = parseInt(this.x)+parseInt(this.y);
			this.z = this.x+this.y;
			
			// console.log(z);
			// console.log("hello");
		},
		resetHandler(e){
			this.z = 0;
			// console.log("reset");	
		}		
	}
	
})
.mount("#calc");		// mount는 vue 영역을 의미한다. 갹체나 함수를 담는 그릇을 의미한다. 
// css의 id를 참조할 수 있다.


```
<br>
#### b. 결론 :

- Vue.js는 DOM을 대신해서 사용하기에 코드량이 적어지고 성능도 좋기 때문에 대신해서 사용할만 하다!
- Vue 이용하기 


---


<br>

### 3) Vue.js 응용 실습

- Vue를 이용하기 위한 script 태그는 html 태그와 헤드 태그가 있는 곳에서 사용한다.**

- rland에서 적용하는 실습이다.

- Fetch API를 사용하기 위해서 JS ES6의 Promise 개념이 필요하다.

- 추후에는 콜백함수가 없어진 비동기 처리 방식을 이용할 예정이다.(Fetch API, 프로미스 이용)


---

<br>

#### a. 테스트 코드 :

```javascript
Vue
.createApp({
	data(){
		return{
			test:"hello"	
		};
	}	
})
.mount("#main-section");

```			

```html
<!DOCTYPE html>
<html 	
	xmlns=th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	layout:decorate="inc/layout"
>
 	
   <main layout:fragment="adminmain" class="main-padding-none">
   
<!--   문서 안에 포함되어야 해서 스크립트 위치 주의! 그리고 defer 설정 중요!!-->
   <script src="/js/admin/menu/list.js" defer="defer"></script>
      <section id="main-section">
         <header class="search-header">
            <h1 class="text-title1-h1">알랜드 메뉴<span v-text="test"></span></h1>
            <form>
               <input type="text">
               <input type="submit" class="icon icon-find">
            </form>
         </header>

```


---

<br><br>

# 4. 230330

### 1) 코드 -


