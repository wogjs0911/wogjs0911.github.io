---
key: /2023/05/31/CodeTest2.html
title: Test - Programmers
tags: java
---

# 1. Lv.1 

<br>

### 1) [x만큼 간격이 있는 n개의 숫자](https://school.programmers.co.kr/learn/courses/30/lessons/12954) : 230530

- long 자료형 사용하기!
	- Why? 유효 범위 때문에 이러한 문제가 발생했다.

```java
class Solution {
    public long[] solution(int x, int n) {
        long[] answer = new long[n];
        long y = (long) x;
        
        for(int i=0; i<n; i++){
            answer[i] += y;
            y += (long) x;
        }
        
        return answer;
    }
}
```

---

<br><br>

### 2) [서울에서 김서방 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/12919)

- String 객체에서 문자열 더하기에서 무조건 String 형만 더하기 할 수 있다. 그렇지 않고는 printf를 이용해야 한다.

```java
class Solution {
    public String solution(String[] seoul) {
        
        String answer = "";
        
        for(int i = 0; i<seoul.length; i++)
            if(seoul[i].equals("Kim"))
                 answer = "김서방은 " +i+"에 있다";
        
       
        return answer;
    }
}
```

---

<br><br>

### 3) [하샤드 수](https://school.programmers.co.kr/learn/courses/30/lessons/12947)

- 각 자리수마다 나누는 방법 어렵다 : Math.log10() 이용!

- 나머지 연산을 이용하기 나머지 값 계산이 즉시 가능하다!(빠르다.)

- 나누기 숫자가 0인 것도 체크해서 넘겨야 한다.(범위 중요!)

```java
class Solution {
    public boolean solution(int x) {
        
        boolean answer = false;
        int div = 0;
        int sum = 0;
        
        int firstx = x;
        
        for(int i = (int) Math.log10(x); i>=0; i--){
            div = (int) Math.pow(10, i);
            sum += x / div;
            x %= div;   // 그냥 '나머지 연산'으로 전체에서 빼는 로직을 해결!!
            
            if(div <= 0)
                break;
        }
        
        answer = ((firstx >= 1) && (firstx <= 10000)) && (firstx % sum == 0);
    
        return answer;
    }
}
```

---

<br><br>

### 4) [음양 더하기](https://school.programmers.co.kr/learn/courses/30/lessons/76501)

- 문제를 빠르게 이해하기!

```java
class Solution {
    public int solution(int[] absolutes, boolean[] signs) {
         int answer = 0;
        
        for(int i = 0; i<absolutes.length; i++){
            if(signs[i] == true){
                absolutes[i] = 1 * absolutes[i];
            }
            else{
                absolutes[i] = (-1) * absolutes[i];
            }
            answer += absolutes[i];
        }
        
        
        return answer;
    }
}
```


---

<br><br>

### 5) [부족한 금액 계산하기](https://school.programmers.co.kr/learn/courses/30/lessons/82612)

- long 자료형 사용하기!
	- Why? 유효 범위 때문에 이러한 문제가 발생했다.

```java
class Solution {
    public long solution(int price, int money, int count) {
        long answer = -1;
        long result = 0;
        long y = 0;
        long sum = 0;
        
        for(int i = 0; i<count; i++){
            y += (long) price;
            sum += y;
            System.out.println(y);
        }
        
        result = money - sum;
        
        if(result >= 0){
            answer = 0;
        }
        else{
            answer = ((long) result) * (-1);
        }

        return answer;
    }
}
```



---

<br><br>

### 6) [같은 숫자는 싫어](https://school.programmers.co.kr/learn/courses/30/lessons/12906) : 230531

- Stack 자료 구조를 사용해야하며, Stack 콜렉션 클래스를 사용하는 방법 복습하기!

- Push(). Pop(). Peek(), inEmpty() 사용 주의!

```java
import java.util.*;

public class Solution {
    public int[] solution(int []arr) {

        Stack<Integer> stack = new Stack<>();
        

        for(int num : arr){
            if(stack.isEmpty() || stack.peek() != num){
                stack.push(num);
            }        
        }

        int[] answer = new int[stack.size()];
        
        for(int i = answer.length-1; i >= 0 ; i--){
             answer[i] = (int) stack.pop();
        }

        return answer;
    }
}
```

---

<br><br>

### 7) [이상한 문자 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12930)

- StringBuilder를 사용하여 append를 이용해서 더하면, 아직도 StringBuilder 타입이라서 결과를 도출할 땐, toString()으로 String로 변환하여 결과 출력하기!! 

- 자리수가 홀수인지 짝수인지에 따라 바뀌는 것이 아니라 공백인 “ ”에 의해 값이 결정되어야 한다. 

- String 타입의 데이터를 비교할 때는 `==`가 아니라 무조건 `equals()`를 이용할 것!
	- String은 자료형이 아니라 클래스이므로 객체이다. 그래서 객체 비교를 해줘야 한다. 


```java
class Solution {
    public String solution(String s) {
        
        StringBuilder st = new StringBuilder();
        String[] trims = s.split("");
        boolean check = true;
        
        for(String c : trims){
            if(check){
                st.append(c.toUpperCase());
            }
            else{
                st.append(c.toLowerCase()); 
            }
            
            check = !check;
            if(c.equals(" ")){
                check = true;
            }
        }
        return st.toString();
        
    }

}
```


---

<br><br>

### 8) [예산](https://school.programmers.co.kr/learn/courses/30/lessons/12982?language=java)


- 처음 푼 방식 : 테케 2개 중 1개만 통과

```java
import java.util.*;

class Solution {
    public int solution(int[] d, int budget) {
        
        // 정렬 후 작은 수부터 더하기
        int sum = 0;
        int count =0;
        int answer = 0;
        
        Arrays.sort(d);
        
        for(int i = 1; i < d.length-1; i++){
            if(d[i-1] <= d[i]){
                sum += d[i-1] + d[i];
                count++;
            }
            if(sum >= budget){
                answer = count;
                return answer;
            }
        }
        
        return answer;
    }
}
```

<br>

- 수정 된 방식 : 빼는 방향으로 


```java
import java.util.*;

class Solution {
    public int solution(int[] d, int budget) {
        
        // 정렬 후 작은 수부터 더하기
        int answer = 0;
        
        Arrays.sort(d);
        
        for(int i = 0; i < d.length; i++){
            if(d[i] <= budget){
                budget -= d[i];
                answer++;
            }
            else{
                break;
            }
        }
        
        return answer;
    }
}
```


---

<br><br>

### 9) [시저암호](https://school.programmers.co.kr/learn/courses/30/lessons/12926) : 230601


- Java에서 아스키코드 이용하는 방법 익혀두기

- toCharArray(), String.valueOf(), matches(), equals() 사용법!
	- 'Z'에서 'A'로 넘기는 방식 구현에서 까다로웠다.

<br>
- 첫 번째 풀이 방법 :
	- 이 방식은 아스키코드를 알아야지 풀 수 있다. 

```java
import java.util.*;

class Solution {
    public String solution(String s, int n) {
        
        char[] trims = s.toCharArray();   // 배열에 바로 담기 
        String Up = "^[A-Z]*$";
        String Low = "^[a-z]*$";
        
        StringBuilder sb = new StringBuilder();
        
        for(int i = 0; i<trims.length; i++){
            int ascii = (int) trims[i];
            
            if(String.valueOf(trims[i]).equals(" ")){
                sb.append(String.valueOf(trims[i]));
                continue;
            }
            
            if(String.valueOf(trims[i]).matches(Up)){
                
                if(ascii + n > 90){
                    trims[i] = (char)(ascii+n-90+64);
                }
                else{
                    trims[i] = (char) (ascii + n);
                }
                sb.append(trims[i]);
            }
            else if(String.valueOf(trims[i]).matches(Low)){
                if(ascii + n > 122){
                    trims[i] = (char)(ascii+n-122+96);
                }
                else{
                    trims[i] = (char) (ascii + n);
                }
                sb.append(trims[i]);
                
            }
            
        }
        
        String answer = "";
        return sb.toString();
    }
}
```

<br>

- 두 번째 풀이 방법 :
	- 나름의 직관적인 풀이!

```java
import java.util.*;

class Solution {
    public String solution(String s, int n) {
        
        char[] trims = s.toCharArray();   // 배열에 바로 담기 
        String Up = "^[A-Z]*$";
        String Low = "^[a-z]*$";
        
        StringBuilder sb = new StringBuilder();
        
        for(int i = 0; i<trims.length; i++){
            int ascii = (int) trims[i];
            
            if(String.valueOf(trims[i]).equals(" ")){
                sb.append(String.valueOf(trims[i]));
                continue;
            }
            
            if(String.valueOf(trims[i]).matches(Up)){
                
                if(ascii + n > 'Z'){
                    trims[i] = (char) ('A' + (ascii + n - 'Z' - 1) % 26);
                }
                else{
                    trims[i] = (char) (ascii + n);
                }
                sb.append(trims[i]);
            }
            else if(String.valueOf(trims[i]).matches(Low)){
                if(ascii + n > 'z'){
                    trims[i] = (char) ('a' + (ascii + n - 'z' - 1) % 26);
                }
                else{
                    trims[i] = (char) (ascii + n);
                }
                sb.append(trims[i]);
                
            }
            
        }
        
        String answer = "";
        return sb.toString();
    }
}

```



---

<br><br>

### 10) [비밀지도K](https://school.programmers.co.kr/learn/courses/30/lessons/17681) : 230602

<br>
 
- 주의 할 사항 : 
	- `String.format("%0"+n+"d", data)` : %0은 자리수에 n자리 수만큼 숫자가 안채워지면 '0'이 채워진다. 원래 채워지는 숫자는 d이며 자세한 내용은 ','뒤에 나열된다. 
	- 'String.format()'에서 원래는 %d에서 '%0d'가 되었고 '%03d' 이런 식이지만 몇자리 수까지 채워질지 모르기 때문에 `%0 + n + d`로 정해졌다. 
	- 유효범위 때문에 int가 아니라 Long으로 형변환(실제로도 런타임 에러가 발생한다!) 

<br>
- 핵심 내용** :
	- String 문자열을 각각 비교할 때는 제발 equals()를 쓰자!
	- 2진수라서 '+' 대신해서 비트연산자인 '|'를 사용하자!

---

<br>

- 코드 :

```java

class Solution {
    public String[] solution(int n, int[] arr1, int[] arr2) {
        
        String[] answer = new String[n];
        String[] arr3 = new String[n];
        
        for(int i = 0; i < n; i++){
            arr3[i] = String.format("%0"+n+"d", Long.parseLong(Long.toBinaryString(arr1[i]|arr2[i]))); 
        }
        
        for(int i = 0; i < n; i++){
            
            String[] result = arr3[i].split("");
            String res = "";
            
            for(int j = 0; j < result.length; j++){

                if(result[j].equals("1")){
                    res += '#';
                }
                else if(result[j].equals("0")){
                    res += ' ';
                }
            }
             answer[i] = res; 
        }
        return answer;
    }
}
```

---

<br>

- 다른 사람들의 풀이 :

```java
class Solution {
    public String[] solution(int n, int[] arr1, int[] arr2) {
        String[] answer = new String[n];       
        for(int i = 0; i < n; i++) {
            String binary1 = Integer.toBinaryString(arr1[i]);
            String binary2 = Integer.toBinaryString(arr2[i]);
            binary1 = "0".repeat(n - binary1.length()) + binary1;
            binary2 = "0".repeat(n - binary2.length()) + binary2;;
            String[] biArr1 = binary1.split("");
            String[] biArr2 = binary2.split("");
            StringBuilder sb = new StringBuilder();           
            for(int j = 0; j < n; j++) {
                if(biArr1[j].equals("1") || biArr2[j].equals("1")) {
                    sb.append("#");
                } else {
                    sb.append(" ");
                }    
            }   
            answer[i] = sb.toString();
        }
        return answer;
    }
}
```


---

<br><br>

### 11) [숫자 문자열과 영단어K](https://school.programmers.co.kr/learn/courses/30/lessons/81301)

- 패턴이 같다... String 객체는 값 비교시, 무조건 equals로 비교!

```java
class Solution {
    public int solution(String s) {
        
        String[] number = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
        char[] arr1 = new char[s.length()];
        int answer = 0;
        String result = "";
        
        for(int i = 0; i < s.length(); i++){
            arr1 = s.toCharArray();
        }
        
        String st1 = "";
        
        for(int i = 0; i < arr1.length; i++){
            if((int) arr1[i] > 58){
                st1 += arr1[i];
            }
            else{
                result += arr1[i];
            }
            
            for(int j = 0; j < number.length; j++){
                if(st1.equals(number[j])){    
                    result += String.valueOf(j);
                    st1 = "";
                }
            }
        }
        
        System.out.println(result);
        System.out.println(st1);
        
        answer = Integer.parseInt(result);
        // 패턴이 같다... String 객체는 값 비교시, 무조건 equals로 비교!
        
        return Integer.parseInt(result);
    }
}
```

---

<br><br>

### 12) [문자열 내 마음대로 정렬하기](https://school.programmers.co.kr/learn/courses/30/lessons/12915)

- String 객체처럼, 객체 정렬에는 Comparator 사용!

- 문제 11) 처럼 String 값 비교는 equals 이용!  

```java
import java.util.*;

class Solution {
    public String[] solution(String[] strings, int n) {
        
        // String 객체처럼, 객체 정렬에는 Comparator 사용!
        Arrays.sort(strings, new Comparator<String>(){
            
            @Override
            public int compare(String o1, String o2){
                
                if(o1.charAt(n) > o2.charAt(n)){
                    return 50;  // 정방향 정렬(양수)
                }
                else if(o1.charAt(n) < o2.charAt(n)){
                    return -50; // 역방향 정렬(음수)
                }
                else if(o1.charAt(n) == o2.charAt(n)){
                    return o1.compareTo(o2);   
                    // 'o1'라는 기준값에 'o2'값이 포함되었는지 차이로 비교하여 정렬
                }
                return 0;   // 종료
            } 
        });
        
        String[] answer = {};
        
        return strings;
    }
}
```
