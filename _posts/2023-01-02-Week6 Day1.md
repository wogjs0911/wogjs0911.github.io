---
key: /2023/01/02/Week6-Day1.html
title: Week6-Day1
tags: javascript canvas
---

# 1. [23.01.02] 


<br>
### 0) 들어가기 전

 - 플랫폼보다는 객체지향을 더 공부하기!!
 - 우리조 1조임
 - 1조 발표 : 파란 사각형이 객체, 방향키가 사용자 입력, Exit 
 - 꾸준함이 가장 중요하다.
 
<br>
### 1) 이미지 크롭하기(일부분을 잘라내기)

```javascript

ctx.drawImage(img,106,296.5,106,148.25, 0, 0, 106, 148.25); 
// sx는 source(원본의 x크기), dx(display x크기,실제로 보여지는 크기)

```

- 전체 화면에서 다른 부분을 크롭하면, 화면이 넘어가는 장면을 만들 수 있다.
- 하지만, 이렇게 화면에 2개가 이미지가 나오면 머리가 아프다.(좌표 등등)
 
 
 
### 2) 이미지 크롭의 좌표 문제 해결 방법
 
- 해결 방법: 이미지를 배열로 구성한다. 2차원 배열을 1차원 배열처럼 사용해서 좌표를 넣어주기! 
 
 
 
```javascript
 window.addEventListener("load", function(){

    // ===================  [1] [Boy 예제] ==========================


    // ---------------------- 8-2. window의 의미 ---------------------------------
    // 8-2. window의 적당한 위치 찾기!! 커다란 윈도우는 처음 pop이되고 영역이 되는 것을 브라우저라고 한다.

    // window라는 객체가 있다.
    // 브라우저는 플랫폼이다. api는 윈도우 객체이다.
    // api는 플랫폼이 없으면 의미가 없다.
    // window의 기생같은 자식 window를 embeded window라고 부른다.
    // window는 출력 영역이 있으며, 입력이 가능한 영역이 존재하다.(입출력이 가능하다!!) - 클릭이 가능하거나, 
    // 문서에서 보여주고 있는 모든 것들은 window이다.따라서 canvas도 window이다!!!(개념적!!)

    // window.onclick = function(){            // **** window 부분은 window만 클릭된다.
    //     console.log("window clicked");      // 실행 결과 후 따라서, window와 canvas는 부모와 자식간의 관계 느낌이다!!
    // }    


    // ---------------------- 1. 이미지가 한 개인 경우 ---------------------------------

    // 이것을 붙여줘야지 canvas의 메서드가 자동완성 한다.
    /** @type {CanvasRenderingContext2D} */ 
    
    var canvas = document.querySelector(".game-canvas");
    // document.querySelector는 css에서 style을 부여할 때, 이름을 명시해줄때, id명을 주거나 태그를 줄 수 있다.  
    

    //  ========== ========== 9. window 버블링 시스템  ==========  ==========  ========== 
    // **** 따라서, window에선 버블링이라는 기능이 있다.(계산기 성질과 같은 의미 - 버튼이 여러 개인 경우, 문제점 해결 )        
    // 자식에서부터 부모까지 다 실행한다.
    // 따라서, 각각의 이벤트 함수를 최대한 적게 사용해야 한다.

    canvas.onclick = function(){            // **** canvas는 window와 canvas가 동시에 클릭된다.
        console.log("canvas clicked");

        boy2.draw(ctx);
        boy2.move(2);
        boy2.clear();
    }
    
    

    var ctx = canvas.getContext('2d');          // 처음에 왜 안 읽혀졌지?
    
    // ---------------------- 2. 이미지가 여러개 인 경우 ---------------------------------

    // 이미지를 여러 개면, 각각의 이미지는 개별적으로 움직여야하고 각자 속성을 가지고 있어야 한다.
    // 따라서, 구조화 시켜야한다.

    // 3. 정면을 바라보고 있는 boy의 기본 형태(생성자 함수) 만들기!!
    // 하지만, 스크립트 언어 특성상 내가 속성이 없는 경우에 속성이 붙어버려서 에러가 난다.
    //

    function Boy(x, y) {         // *******
        this.x = x || 200;      // 6. 오버로드 생성자로 사용자가 넘겨줄 값이 있을 때, 가능하게 하려고 이렇게도 가능하다.
        this.y = y || 100;      // 사용자 입력이 없을 때는, x와 y는 || 뒤의 기본값이 들어간다.
        this.ix = 1;
        this.iy = 2;

        this.sw = 106;
        this.sh = 148.25;
        this.sx = this.sw * this.ix;
        this.sy = this.sh * this.iy;   
    }


    // 내가 처음에 만든것!!(이젠 이렇게 만들지 말자, 개념적으로 아래 코드와 비교!!)
    // boy1.prototype.draw = function(){
    //     var img = new Image();	
    //     this.drawImage(img, this.sx, this.sy, this.sw, this.sh,   
    //         200, 100, 106, 148.25); // sx는 source(원본의 x크기), dx(display의 x크기) 
    // }

    // *******
    Boy.prototype = {               // 4. prototype으로 객체로 만들기!!(캡슐화!!!!********)

        draw : function(ctx){
            var img = new Image();	
            img.src = './image/boy.png';

            //var o = this;                 // 굳이 이렇게 해야 하나?

            img.onload = function(){        //이렇게 만들면 에러가 나는 이유?

                // ctx.drawImage(img, this.sx, this.sy, this.sw, this.sh,   
                //     200, 100, 106, 148.25); // sx는 source(원본의 x크기), dx(display의 x크기)

                // 7. x 값을 초기화해서 10px로 이동시켜보기!!!!
                ctx.drawImage(img, this.sx, this.sy, this.sw, this.sh,   
                this.x, this.y, 106, 148.25);                           // sx는 source(원본의 x크기), dx(display의 x크기)
                

                //console.log(o);       // 5. function 안의 function이며 이미지가 실행 다 되어서 
                                        // img가 this가 되어 실행해준다. 원래는 Boy의 sx여야한다. 그래서, 뭘해야 하지?
            }.bind(this);               // 여기서는 Boy에서 img로 이벤트가 위임 되었다!!(중요)
                                        
                                        // 개념적인 부분 : 위임? 다시 이벤트 위임 공부, Function.prototype.call()은 모든 함수에서 call이 있어야 한다.
            
                                        // 중요!! 함수가 호출한 주체가 this가 된다. apply, call
            console.log(this);
        },

        
        // ========================  7. 캐릭터를 다른곳에 이동시키기 ========================== 
        // 추가적으로 boy2를 만들려면 어떻게 해야하는지?
        // 캐릭터를 이동시키려면 방향 코드가 필요하다.
        // 시계 방향!!
        move : function(dir){

            switch(dir){
                case 1: // 북쪽
                    this.y -= 10;       // 브라우저 기준으로 시작을 생각해보면 된다.
                break;

                case 2: // 동쪽
                    this.x += 10;
                break;
                
                case 3: // 남쪽
                    this.y += 10;
                break;
                
                case 4: // 서쪽
                    this.x -= 10;
                break;
                
            }
        },

        clear : function(){
            
            ctx.clear;
        }
        
    }
        
    var boy1 = new Boy();
    boy1.draw(ctx);



    // 브라우저의 렌더링 처리는 그림을 그리고 이동하는 것은 효율성을 위해서 한번에 처리된다.
    var boy2 = new Boy();
    
   // boy2.draw(ctx);

    // 이전에 for문으로 이동시키는 것과 onclick으로 이동시키는 것의 차이는?
    
    
    

    // ========================  8-1. 사용자 입력 받기 ========================== 
    // 사용자 입력이 있으면, window가 다운되지 않고 백그라운드가 돌아갈 수 있게 해야 한다.
    // window에서는 사용자의 입력(event)을 수신하는 능력이 있다. 이벤트를 확인해서 처리하는 능력도 있다.




    // ======================  [2] [Box 예제] ============================
    // Box??

    function Box() {

    }

    Box.prototype = {
        test: function(x,y) {         // x와 y를 var로 선언안해줘도 된다.
            console.log(this);        // 함수에서 바로 가져온다.
            console.log(x);
            console.log(y);
        }
    };

    var box1 = new Box();
    box1.test();

    var f1 = box1.test;

    // // f1();                  // 여기서 앞에 window가 생략되어 있다. 

    // // var t = 3;             // 에러가 안난다. 여기서, t가 window이다.
    // // console.log(window.t); 

    // // // var obj = {kor:2};
    // // // obj.f1();               // 에러가 난다.

    // var obj = {kor:2};
    // obj.f1 = box1.test;     // box1의 test함수를 obj의 f1속성에 대입해준다.
    // obj.f1();               // 그 obj의 f1을 바로 호출해서 에러가 안 난다.

    var obj = {kor:2};
    obj.onload = box1.test; // box1의 test함수를 obj의 onload속성에 대입해준다.
    obj.onload();           // 그 obj의 onload를 바로 호출해서 에러가 안 난다.





    // **** 중요 내용 정리!!! (call, apply, bind)
    // // ====================================================================
    // // (1) 중요!! 함수가 호출한 주체가 this가 된다. call

    // var n1 = {id:1, title:'hello'};

    // // 여기서 전달하는 객체가 저 안의 객체가 된다.

    // obj.onload();
    // obj.onload.call(n1);

    // // console.log(n1);





    // // ====================================================================
    // // (2) apply는 argument를 배열로 집어 넣어준다.

    var n1 = {id:1, title:'hello'};

    // // 여기서 전달하는 객체가 저 안의 객체가 된다.(n1이 this가 된다.)

    obj.onload();
    obj.onload.apply(n1,['hi','okay']);







    // ====================================================================
    // (3) bind 중요!! 함수를 호출할 때, 바꿔치기를 해준다. 위임할 때, 나중에 호출
    // 함수를 호출하면서, 나중에 밖에 있는 this를 Boy객체가 되도록 해준다
    // ** bind 정리 : 밖에 있는 this(Boy)를 load에 bind 시켜줘서 안에 있는 this(img)에 위임시켜준다.



    // Box.prototype = {
    //     test: function(){
    //         console.log(this);
    //         console.log(x);
    //         console.log(y);
    //     }
    // };



    // //var img = document.createElement('image');	// 이런 방식도 가능하다!!
    // var img = new Image();			    // image 객체 만들기
    // img.src = './image/boy.png';		// image를 해당 경로로 가져오기 

    // //img.addEventListener("load", function(){  // 이렇게도 load 가능!! 
    // img.onload = function(){

    //     //ctx.drawImage(img,80,80);			// 바로 실행하기!

    //     //ctx.drawImage(img,100,100,106,148.25);	
                                                    
    //     //ctx.drawImage(img,106,296.5,106,148.25, 0, 0, 106, 148.25); // sx는 source(원본의 x크기), dx(display의 x크기) 
        
    //     var ix = 1;
    //     var iy = 2;

    //     var sw = 106;
    //     var sh = 148.25;
    //     var sx = sw*ix;
    //     var sy = sh*iy;
        
    //     ctx.drawImage(img,sx,sy,sw,sh, 
    //         200, 100, 106, 148.25); // sx는 source(원본의 x크기), dx(display의 x크기) 
        
    //     // dx나 dy를 키우면 이미지를 키울 수 있다.

    //     ctx.drawImage(img,sx+sw,sy+sh,sw,sh, 
    //         300, 200, 106, 148.25); // sx는 source(원본의 x크기), dx(display의 x크기) 
        
       
    //     var moveImage = function(ix, iy){
    //         ctx.drawImage(img,sx+sw*ix,sy+sh*iy,sw,sh, 
    //             100*iy, 200, 106, 148.25); // sx는 source(원본의 x크기), dx(display의 x크기) 
            
    //     }  

    //     moveImage(2,3);
    // }

    // ---------------------- 3. 이미지가 여러개 인 경우 ---------------------------------

    // 이미지를 여러 개면, 각각의 이미지는 개별적으로 움직여야하고 각자 속성을 가지고 있어야 한다.
    // 따라서, 구조화 시켜야한다.

});

```
 
 
