---
key: /2023/04/17/Week21-Day.html
title: TIL - 21주차 코드
tags: springboot Session Filter SpringSecurity
---

# 1. JS : 230417


### 1) ES2015

- ES2015는 ES6를 의미한다.

- 클래스와 모듈화가 ES6의 가장 큰 특징이다.

<br>

### 2) ORM

- JPA : 원래는 SQL문을 안 써야 하는데, JPA가 JPQL로 SQL문을 써야 할 수도 있어서 별로 좋지 않은 프레임워크일 수도 있다.
	- Entity에 어노테이션이 너무 많이 붙어버린다.
	
	
	
 



### 3) ES6 개념 

- shape.js

```javascript
let canvas = document.createElement("canvas");

canvas.width=500;
canvas.height=400;

// 1. canvas.style="border:1px solid black";

// 이게 맞다.
canvas.style.border="1px solid black";


// 2. 둘 다 사용하다!
// canvas.style.borderColor="blue";
canvas.style["border-color"]="blue";

document.body.append(canvas);   
// 3. 기본적으로 로드가 된 후 에러 발생 안 하려면, defer 설정을 해줘야 한다.
// defer를 안 쓰려면 window.onload()를 이용해야 한다!

// DOM은 사용자가 이용하기 위해 차별화를 둘 수 있다.

// 4. 상자를 가로로 4개 그리기(반복문 이용 )

let ctx = canvas.getContext("2d");

color = ["yellow", "blue", "green", "red"];

for(let i = 0; i<4; i++){
    ctx.fillStyle= color[i];
    ctx.fillRect(10+60*i, 10, 50, 50);
}

// 5. 박스 반복문 이용하기!!(모듈 넘기기!)
// function Box(x,y,w,h,color) {
//     this.x = x || 0;    // 초기화!
//     this.y = y || 0;
//     this.width = w || 50;
//     this.height = h || 50;
//     this.color = color || "black";
// }

// let boxes =  [
//     new Box(10,10,50,50,"yellow");
//     new Box(10,10,50,50,"green");
//     new Box(10,10,50,50,"blue");
//     new Box(10,10,50,50,"red");
// ]


// 6. 박스를 가로로 4개 그리기

let boxSize = 50;
let gap = 20;
let colors = ["yellow","green","blue","red"];
let boxes = [];

for(let i = 0; i<4; i++)
    boxes.push(new Box(i*(50 + gap), 0, 50, 50, colors[i]));

// 7-1. 박스 그리기!
for(let box of boxes)
    box.draw(ctx);
    

// 이렇게만 하면 prototype의 Box인지 기본 Box 함수 인지 알 수 없다. 
console.log(boxes[0].kor);  

console.log(Object.hasOwn(boxes[0],'x'));
console.log(Object.hasOwn(boxes[0],'draw'));    // false

console.log(typeof Box.prototype);  // object
console.log(typeof Box);  // function

// 8-1. function 이름으로 prototype 얻기
let proto = Box.prototype;

// 8-2. 물려받은 'proto'에서는 'draw' 함수가 있는지?
// 히지만, 우리는 Box라는 클래스를 만들었는데, 역시나 Box 함수와 같다.
// 객체 모델은 과거의 function 모델과 같다.****
console.log(Object.hasOwn(proto,'draw')); // true!

// 9. funtion object로 prototype 얻기
Object.getPrototypeOf(boxes[0]);


// ===============================================

// 10. Object 다루기!!

let box = new Box();
box.x++;

// console.log(`x:${box.getX()}`);
console.log(`x:${box.x}`); // 새로운 방식의 getter!!

let obj = {x:10, y:20};

// let obj1 = Object.create(obj);
// console.log(obj1);

Object.defineProperty(obj, 'z', {
    value:30,
    writable:false  // 값을 사용하게 할 수 있는지 boolean
});

obj.y = 50;
obj.z = 60; // z는 writable가 false라서 값이 바뀌지 않음!

console.log(obj);


// 11. Object 다루기!! : 이터러블

// 11-1. Object.create는 객체를 만든다.
// Object.defineProperty는 속성을 값으로 설정한다.
// Object.entries는 값이 배열로 나온다.

// 11-2. ***** writable를 설정해주면, Object에서는 index로 뽑아서 쓸 수 없다. *****
Object.defineProperty(obj, 'z', {
    value:30,
    writable:false,
    enumerable:false
});


// 11-3. *** Object.preventExtensions는 객체 속성을 잠궈버린다! *** 
Object.preventExtensions(obj);

// 11-4. entries는 Object의 값을 배열로 만들어준다.
for(let p of Object.entries(obj)){
    console.log(`key:${p[0]}, value:${p[1]}`);
}

// 11-5. ***** Object에서는 index로 뽑아서 쓸 수 없다. ***** 
// for(let p of obj)
//     console.log(p);


// 7. 박스 그리기! : ***이게 올바른 방식이다!!**(어렵다!!)
// for(let box of boxes){
//     // let x = box.x;
//     // let y = box.y;
//     // let w = box.w;
//     // let h = box.h;
//     // let color = box.color;

//     // let box = {x,y,w,h,color};
//     let {x,y,w,h,color} = box;  // 8. 디스트럭처링!*******
//     // [디스트럭쳐링 개념]
//     // 1) 배열 :
//     // 2) 중첩 :

//     ctx.fillStyle = color;
//     ctx.fillRect(x,y,w,h,color);
// }



// 9. 디스트럭처링 응용
let kors = [30,20,30,40];

let [kor1, kor2, kor3] = kors;

console.log(kor1);


// 10. 순서 바꾸기 
console.log(`kor1:${kor1}, kor2:${kor2}`);

[kor1,kor2] = [kor2,kor1];

console.log(`kor1:${kor1}, kor2:${kor2}`);

let both = [
    new Box(),
    new Box(10,40,50,50,"red")
];

{
    // 첫번째 Box의 color과 width를 얻기
    // let [b1,b2] = both;
    //console.log(b1);
    
    let [{color,width}, b2] = both;
    console.log(color);
    
}
```

- box.js

```javascript
// 8. class 등장!!

class Box{

    #x; // 은닉화를 지켜주기 위해서 private처럼 사용!

    constructor(x=0, y=0, w=50, h=50, color="black"){

        this.#x = x;    // 이제는 초기화를 위에서 한다.
        this.y = y;
        this.width = w;
        this.height = h;
        this.color = color;
    
    }

    // ** 기존 getter, setter *****
    // getX(){
    //     return this.#x;
    // }

    // setX(x){
    //     this.#x = x;
    // }

    // ** 새로운 getter, setter : 은닉화 기능 업! *****
    get x(){
        return this.#x;
    }

    set x(x){
        this.#x = x;
    }

    draw(){
        let {y,width:w,height:h,color} = this; 
        let x = this.#x;    // 추가!!

        ctx.fillStyle = color;
        ctx.fillRect(x,y,w,h,color);
    }

}



// // 캡슐화는 그 캡슐에 책임을 넘겨주는 것이다.
// // 5. 박스 반복문 이용하기!!

// // 7-1. 생성자 함수!!
// function Box(x,y,w,h,color) {

//     this.x = x || 0;    // 초기화!
//     this.y = y || 0;
//     this.width = w || 50;
//     this.height = h || 50;
//     this.color = color || "black";

//     // 하지만 지금 이런 코드는 문제가 많다.
//     // 함수가 100번 호출되면 함수가 100개 만들어져서, 문제가 생긴다!
//     // 그래서 우리는 prototype을 이용한다!
//     this.draw = function(ctx){
//         let {x,y,width:w,height:h,color} = this; 
//         ctx.fillStyle = color;
//         ctx.fillRect(x,y,w,h,color);
//     }

//     // this.draw = new function("","");

//     // ** 6-1. 프로토타입은 모든 박스 객체가 공유하는 함수이다.
//     // 즉, 프로토타입은 다른 스타일의 박스를 여러개 만들 수 있게 해준다.

//     // let proto = {
//     //     kor: 10,

//     //     draw:function(){
//     //         let {x,y,width:w,height:h,color} = this; 
            
//     //         ctx.fillStyle = color;
//     //         ctx.fillRect(x,y,w,h,color);
//     //     }
//     // };
//     // Box.prototype = proto;
//     // Box.prototype = proto1;
//     // Box.prototype = proto2;

//     // ** 6-2. 프로토타입은 모든 박스 객체가 공유하는 함수이다.

// 7-2. 구현하는 함수!!
//     Box.prototype = {
//         kor: 10,

//         draw:function(){
//             let {x,y,width:w,height:h,color} = this; 
            
//             ctx.fillStyle = color;
//             ctx.fillRect(x,y,w,h,color);
//         }
//     };
// }

``` 









