---
key: /2023/04/03/Week19-Day.html
title: TIL - 19주차 코드
tags: springboot RESTAPI Vue.js AJAX 
---

# 1. Vue.js : 230403


### 1) Vue.js의 API 정리

- 함수에게 전달되는 옵션이라서 'Options API'이다. 

<br>
- Global API : create를 통해서 전달되는 인자를 API를 통해서 전달된다.

<br>
- Built-ins API 사용은 지시자 사용이다. 

<br>
- 1차 프로젝트에서 Vue에서 Options API, Global API, Built-ins API만 사용한다. 이 3가지가 Vue에서 제공해주는 기본 API이다.

<br>
- Fetch API, XHR의 AJAX 방법론은 JS의 브라우저(플랫폼)에서 제공해주는 것이다.


---

<br><br>

### 2) insert한 메뉴를 다시 View 단에서 보여주는 방법!

- 1) 전체 목록을 다시 받아와서 로딩하기 
- 2) id만 반환해서 하나만 다시 요청해서 그것만 로딩하기.
- 3) lastMenu를 Menu 객체로 얻어와서 사용해서 얻어온다.

<br>
- 일관적인 방법 : 1페이지, 2페이지 구분이 제대로 안되어서 목록을 다시 받아오는 방법이 맞다.
	- 성능사항이나 사용자의 요구사항이 있다면 2)나 3)을 이용한다. 

<br>
- 이클립스 코드 자동 정렬 : `cmd + a` 후 `cmd + shift + f`

<br>
- JSON으로 데이터를 보냈으면 insert의 반환 타입도 JSON 타입으로 바꿔줘야 한다.

<br>
- 실습 코드 : 

```javascript
	methods: {
		// e 가 없어도 되네?
		menuSaveHandler() {

			var myHeaders = new Headers();
			myHeaders.append("Content-Type", "application/json");

			// 여기만 바꿔주기!!**
			var raw = JSON.stringify(this.menu);

			var requestOptions = {
				method: 'POST',
				headers: myHeaders,
				body: raw,
				redirect: 'follow'
			};
			
			// 목록 다시 갱신!!
			fetch("http://localhost:8080/menus", requestOptions)
				.then(response => response.text())
				.then(result => {
					if(result ==="ok"); 
						this.load();
				})
				.catch(error => console.log('error', error));
		},
		menuAddHandler() {
			// toggle on / off 
			this.isShowRegForm = !this.isShowRegForm;
		},
		categoryClickHandler() {

			// this.load(2);

			// 화면을 바꾸려면 연관되어 있는 모델을 찾아라!
			this.list.push({ id: 4, name: "디카페인 아메리카노", price: 5500 });
			console.log(this);
			// 하지만 데이터를 언제 가져와야하는지?
			// 페이지가 처음 실행되는 블럭?

		},
		load() {
			// ========================================================================================
			// XHR(XmlHttpRequest)
			// - Callback(나중에 호출한다 =  delegation 함수 = 나중에 호출하므로 '위임함수'라고도 부름.)을
			//  이용한 비동기처리

			// Fetch API 
			// - Promise를 이용한 비동기 처리

			// ========================================================================================
			// ****** '.'을 써서 바로 위의 코드의 중첩의 중첩으로 미들웨어 시스템으로 가져갈 수 있다. *****

			let promise = fetch("/menus");

			promise
				.then(response => {
					// console.log("도착 했냐?");
					// console.log(response.json());
					return response.json();	// 반환을 하면 아래 코드처럼 계속 이어가서 또 반환 할 수 있다. 
				})
				.then(list => {
					this.list = list;	// 기존의 데이터를 대치하는 것이라서 추가하는 것이 아니다.
					console.log(this);
					// 데이터를 추가하려면 이렇게 하면 안된다. 
					// this.list는 모델에 담는 것이다. list는 넘겨 받은 데이터이다.
				})
				.catch(error => {
					console.log("error"); // 중간에 url의 요청한 데이터가 반환 에러가 발생하면 점프해서 에러 반환!! 
				});						  // then은 이전의 내용을 중첩해서 사용한다.

			// ========================================================================================

			// *** 이게 제일 편하고 간단해서 아래의 코드처럼 사용한다!! ***
			//			let response = await fetch("/menus"); // fetch가 Promise를 대신 해준다! 되게 간단해졌다!!
			//			let list = await response.json();	// 동기형인 비동기형이다. 화면은 안 바뀌고 데이터만 바뀌므로!!
			//			console.log(list);		

			// ========================================================================================


			// ========================================================================================

		}
	},


	beforeCreate() { console.log("beforeCreate") },
	created() { console.log("created") },
	beforeMount() { console.log("beforeMount") },
	mounted() {
		console.log("mounted")
		this.load();
		console.log(this);
	},
	beforeUpdate() { console.log("beforeUpdate") },
	updated() { console.log("updated") },
	beforeUnmount() { console.log("beforeUnmount") },
	unmounted() { console.log("unmounted") }


})
.mount("#main-section");
```


---

<br><br>

#### 2) detail 페이지도 Vue.js 로 만들기

- 데이터를 가져올 때는 한번에 가져오는 것이 아니라 작은 데이터를 가져와서 여러 번 만들어야한다. 

- 데이터를 가져올 때, 한번에 가져오면 서로 다른 것에서 영향을 받아서 코드가 매우 복잡해진다.

- 그래서 각부분을 위해서 고립화가 필요하다!


---

<br><br>

### 3) 그래서 고립화가 필요해서 고립화해서 만드는 방법 : 

- 코드의 단순화 : 

- 코드의 집중화 : 코드의 재사용과는 의미가 다르다. 동시대의 만들어지는 코드들이다. 한 번에 수정이 일어나야 하는 것들이다.
	- 코드의 집중화는 다음 시대에 사용한다. 
	
- 협업에서 가능하다 : 코드를 나눠서 만들수 있다.

- 코드의 재사용이 가능하다. : 다음 버전에서 사용하면 코드의 재사용성이 가능하다.

- 결론** : 서로 영향을 주면 안되는 고립화가 완전히 일어나야 한다.

---

<br><br>

### 4) 고립화해서 만드는 방법 : '컴포넌트' 개념!

- admin 폴더만 static 폴더로 옮긴다.

- 서버에서 페이지를 만들 일이 없다.

- 그래서 index.html로 서버를 키자 그리고 더이상 서버를 요청하지 않는다!!

- 그래서 SPA(Single Page Application)로 만들자!

- Node.js를 써야 한다.

---

<br><br>

### 5) 이전의 SSR 정리

- 서버를 만들어주는, 데이터를 만들어주는 'Front-Controller'로 만들었다. 
	- JSP, Thymeleaf

<br>
- html만 가지고 요청하는 경우만 했었다.

<br>
- 추가로 JS 코드로 요청하는 경우, JS 코드로 화면을 조작하는 작업이 불가능했었다. 그래서 DOM을 직접 사용하지 않고 Vue MVC를 이용한다. 

<br>
- 앞으로, 빌드된 것만 이용해서 Node에 도구를 얹혀서 만들어가는 방법을 할 것이다. 


---

<br><br>

### 6) Node.js 시작!!**

- node.js는 브라우저에서가 아니라 이제는 ui로 결과를 확인할 수 있다.(콘솔창) 

<br>
- Read eval Print Loop : 1줄 단위로 코드를 읽어 들여서 실행한다, 렛풀 방식의 코드 실행 

<br>
- CLI : Command Line Interface(Interpreter)라고도 부른다. 

<br>
- 배치 형태로 실행할 수 없을까? : NodeJS에서는 자바처럼 파일 입출력이나 네트워크(웹 개발을 위한 HTTP 모듈), 프로세서 관리만 사용할 수 있다. 브라우저가 아니라 DOM을 사용할 수 없다.


<br>
- 메모장에 실습코드 :
	- first.js

```javascript

let x=30;
let y=30;
let y= x+y;
console(z);

```

<br>
- CLI에서 실행 명령어 :

```

node first

```


---

<br><br>

### 6) npm 사이트 이용하기.

- 모듈을 언제든지 올릴 수도 있고 다른 개발자들에 의해 만들어진 도구인 라이브러리를 다운 받을 수 있다.

<br>
- npm 명령어로 모듈(라이브러리)을 가져올 수 있다. 
	- 명령어 : `npm i "다운받을 모듈명";`

<br>
- 하나의 JS 코드에서 다른 JS 코드를 사용할 수 없었다가 모듈을 통해 사용할 수 있게 되었다. 모듈은 ES5부터 있었었다.
 
<br>
- 기본은 `CommonJS`를 사용한다. 우리가 앞으로 사용할 것은 ES6에서 추가된 모듈을 사용한다.

<br>

#### a. 기본 실행 실습 코드 : 

- 'require'를 통해서 남이 만든 라이브러리를 사용할 수 있다. require를 사용한 것을 새로운 변수인 객체에 담아서 사용하는데 그 객체는 기존에 만들어진 라이브러리에서 exports를 통해 사용하게 된다. exports는 라이브러리 내부 객체의 속성을 사용할 수 있게 해준다.

```javascript

// modules 객체에 담아서 그 속성을 사용할 수 있다. 'module'이라는 이름은 예약어라서 바꾸자

const modules = require("newlec-hello");    
modules.hello();

```

<br>
- 정리** :노드는 단순히 실행환경이다. Vue를 이용하는 플랫폼을 이용할 예정이다. 다양한 도구를 Node에 다운받아서 사용할 수 있다.



<br>

#### b. npm 제대로 이용하기 : 

- npm 사이트에서 '라이브러리'를 받는지 '툴'을 받는 건지 알고 있어야 한다.

<br>
- 라이브러리를 다운받으면 그 파일에서 package.json 파일을 확인해보자. 이 파일이 pom.xml 파일과 같은 역할의 설정 파일이다.

<br>
- 해당 라이브러리 파일의 폴더를 지우고나서 package.json이 있다면, `npm i` 명령어를 통해서 다시 다운 받을 수 있다.



<br>

#### c. 리눅스 환경의 장점 : 

- 리눅스에서는 개발용에서 모든 프로그램이 개발이 가능하다. 해킹이나 모니터링을 체킹할 수 있는 개발환경이 가능하다.

<br>
- 프로젝트를 서버에서 돌리기 위해서는 리눅스에서 사용해야한다. 왜냐하면, 윈도우즈는 리소스가 차기 때문에 1년에 한번 없애줘야 한다. 또한, 윈도우즈 업데이트 때문에 서버를 돌릴 수가 없다.

<br>
- 로드 밸런싱, 클러스터링 등 기능이 전부 리눅스에 있다. 그래서, 배포 운영에는 리눅스를 사용한다. 서버를 돌리기 위해서 다른 OS에서는 에뮬레이터를 써야한다.

<br>
- 그래서, 리눅스도 공부하자!


---

<br><br>

### 7) Vue를 npm 이용하기!!

- 유닉스 명령어 
	- 'pwd' : 현재 폴더 경로 
	- `clear` : 
	
<br>
- 타입스크립트 : 실행어를 자바스크립트로 바꿔준다. 나중에 사용하자. 쓸만 한듯?

- JSX : 리액트에서 쓰는 뷰단 엔진, 엉망이라서 버리자!

- vite : 개발용 서버 도구이다. 라이브서버 같은 느낌이다.

<br>

### a) 실행 명령어

- npm init vue@latest : npm에서 Vue를 라이브러리로 다운 받을 수 있다. 모듈로 사용할 수 있다.
- npm i : pom.xml 파일과 같은 파일인 package.json 파일을 실행해서 해당 라이브러리를 업데이트 시키자
- npm run dev : node 서버 실행

<br>
- package.json 파일에서 scripts 객체를 만들어서 속성으로 start(npm 예악어)로 만들면 npm으로 실행할 수 있다.
- 내가 만든 것으로 실행하기 위해서 'npm run dev'로 서버를 실행해서 포트번호 '5173'를 이용한다! 

<br>
- 이제는 컴포넌트가 교체되는 방식이라서 페이지가 다시 로딩이 없다. 


---

<br><br>

# 2. 230403




