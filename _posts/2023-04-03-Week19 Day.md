---
key: /2023/04/03/Week19-Day.html
title: TIL - 19주차 코드
tags: springboot RESTAPI Vue.js NodeJS npm component 
---

# 1. Vue.js : 230403


### 1) Vue.js의 API 정리

- 함수에게 전달되는 옵션이라서 'Options API'라고 부른다. 

<br>
- Global API : Global API은 create를 통해서 전달되는 인자를 API를 통해서 전달된다.

<br>
- Built-ins API는 지시자를 사용하는 API이다.

<br>
- 1차 프로젝트는 원래, Vue.js에서 Options API, Global API, Built-ins API만 사용하려고 했다. 이 3가지 API가 Vue.js에서 제공해주는 기본 API이다. 공식 레퍼런스에 있는 나머지 API는 Vue에서 기본적으로 제공해주는 API가 아니다.

<br>
- Fetch API, XHR에 관한 AJAX 방법론은 JS의 브라우저(플랫폼)에서 기본으로 제공해주는 것이다.


---

<br><br>

### 2) insert한 메뉴를 업데이트하여 View 단에서 다시 보여주기

- 첫 번째 방법: 전체 목록을 다시 받아와서 로딩하기 

- 두 번째 방법: id만 반환해서 하나만 다시 요청해서 그것만 로딩하기.

- 세 번째 방법: lastMenu를 Menu 객체로 얻어와서 사용해서 얻어온다.

<br>
- 결론 : 일관적인 방법은 페이저 방식에서 1페이지와 2페이지 구분이 제대로 안 되어서 목록 전체를 다시 받아오는 방법이 맞는 방법이다.
	- 하지만, 성능적 이슈나 사용자의 요구사항이 있다면 두 번째 방법이나 세 번째 방법을 이용한다. 

<br>
- 만약에, JSON 타입으로 요청 데이터를 보냈으면 insert하는 AJAX의 반환 타입도 JSON 타입으로 바꿔줘야 한다. 하지만, 이번엔 text 타입으로 요청 데이터를 보냈다.
- 추가로 이클립스에서 코드를 자동 정렬하는 방법 : `cmd + a` 후 `cmd + shift + f`

<br>

#### a. 실습 코드 : 

- MenuController.java

```java
troller.api;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.databind.ObjectMapper;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.entity.MenuView;
import kr.co.rland.web.service.MenuService;

// API 이용하기 = AJAX


@RestController("apiMenuController")
@RequestMapping("menus")	// 예전에는 절대경로로 썼지만 지금은 "/"를 안써도 된다. 
public class MenuController {
	
	// REST API에서는 반환값이 문서를 전달하는 것이 아니라 사용자가 받는 데이터이다. 
	// List<MenuView>
//	public List<MenuView> getList(){
//		
//	}
	
	@Autowired
	private MenuService service;
	
	// insert는 아직 넣어줄 데이터가 없어서 문제가 많다.
	// 요청한 데이터를 @RequestBody로 매핑하면, 헤더를 정해줘야 한다.(타입!!정해주기 )
	@PostMapping
	public String insert(@RequestBody Menu menu) {
		
		menu.setCategoryId(1);
		
		int addCount = service.add(menu);
		System.out.println(addCount);
		
		System.out.println(menu.getName());
		
		return "ok";	// 다양한 방법의 반환 방법!도 있다.
	}
	
	
}

```

- list.js

```javascript
	methods: {
		load() {
			// ========================================================================================
			// XHR(XmlHttpRequest)
			// - Callback(나중에 호출한다 =  delegation 함수 = 나중에 호출하므로 '위임함수'라고도 부름.)을
			//  이용한 비동기처리

			// Fetch API 
			// - Promise를 이용한 비동기 처리

			// ========================================================================================
			// ****** '.'을 써서 바로 위의 코드의 중첩의 중첩으로 미들웨어 시스템으로 가져갈 수 있다. *****

			let promise = fetch("/menus");

			promise
				.then(response => {
					// console.log("도착 했냐?");
					// console.log(response.json());
					return response.json();	// 반환을 하면 아래 코드처럼 계속 이어가서 또 반환 할 수 있다. 
				})
				.then(list => {
					this.list = list;	// 기존의 데이터를 대치하는 것이라서 추가하는 것이 아니다.
					console.log(this);
					// 데이터를 추가하려면 이렇게 하면 안된다. 
					// this.list는 모델에 담는 것이다. list는 넘겨 받은 데이터이다.
				})
				.catch(error => {
					console.log("error"); // 중간에 url의 요청한 데이터가 반환 에러가 발생하면 점프해서 에러 반환!! 
				});						  // then은 이전의 내용을 중첩해서 사용한다.

			// ========================================================================================

			// *** 이게 제일 편하고 간단해서 아래의 코드처럼 사용한다!! ***
			//			let response = await fetch("/menus"); // fetch가 Promise를 대신 해준다! 되게 간단해졌다!!
			//			let list = await response.json();	// 동기형인 비동기형이다. 화면은 안 바뀌고 데이터만 바뀌므로!!
			//			console.log(list);		

			// ========================================================================================


			// ========================================================================================

		}
	},


	beforeCreate() { console.log("beforeCreate") },
	created() { console.log("created") },
	beforeMount() { console.log("beforeMount") },
	mounted() {
		console.log("mounted")
		this.load();
		console.log(this);
	},
	beforeUpdate() { console.log("beforeUpdate") },
	updated() { console.log("updated") },
	beforeUnmount() { console.log("beforeUnmount") },
	unmounted() { console.log("unmounted") }


})
.mount("#main-section");
```


---

<br><br>

#### 2) detail 페이지도 Vue.js로 만들 때, 주의할 사항 

- 데이터를 가져올 때는 한번에 가져오는 것이 아니라 작은 데이터를 가져와서 여러 번 만들어야한다. 

- 데이터를 가져올 때, 한번에 가져오면 서로 다른 것에서 영향을 받아서 코드가 매우 복잡해진다.

- 그래서 각부분을 위해서 `고립화`가 필요하다!


---

<br><br>

### 3) 고립화로 Vue.js 코드를 만들 때, 장점 : 

- a. 코드의 단순화 : 코드 구조가 단순해진다.

- b. 코드의 집중화 : 코드의 재사용과는 의미가 다르다. 동시대의 만들어지는 코드들이다. 한 번에 수정이 일어나야 하는 것들이다.
	
- c. 협업에서 가능하다 : 코드를 나눠서 만들수 있다.

- d. 코드의 재사용이 가능하다. : 다음 버전에서 사용하면 코드의 재사용성이 가능하다.
	- 코드의 재사용은 다음 시대(다음 계층)에서 사용한다. 

- 결론** : Vue에서는 view단의 각각의 부분들이 서로 영향을 주면 안되는 고립화가 완전히 일어나야 한다.

---

<br><br>

### 4) 고립화해서 만드는 방법 : '컴포넌트' 개념!

#### a. 기존 rland 프로젝트 변경 

- admin 폴더만 static 폴더로 옮긴다.

<br>

#### b. '컴포넌트' 개념!

- 이제는 서버에서 페이지를 만들 일이 없다.

- 먼저, index.html 페이지에서 NodeJS 실행환경에서 npm으로 서버를 실행하여 브라우저에서 웹을 동작시킨다. 이제는 서버를 키고 더 이상 서버를 요청하지 않는다!!

- 그래서, 모든 페이지를 SPA(Single Page Application) 프로젝트로 만들자!

- 그래서 우리는 NodeJS를 써야 한다.

---

<br><br>

### 5) 이전의 SSR 정리

- 우리는 이전까지 서버를 만들어주고 데이터를 만들어주는 'Front-Controller'를 만들었다. 
	- JSP, Thymeleaf 등으로 출력을 위해서 view단을 이용했다.

<br>
- 또한, 기존에 Thymeleaf를 통해 html만 가지고 요청하는 경우만 했었다.

<br>
- 이제는 JS 코드로 서버를 요청한다. 하지만, 이렇게 하면 JS 코드로 화면을 조작하는 작업이 불가능했었다. 그래서 DOM을 이용했었는데 앞으로는 DOM을 직접 사용하지 않고 Vue MVC를 이용한다. 

<br>
- 앞으로는 Vue MVC에서 컴포넌트 개녕을 도입해서 Vue로 빌드된 것만 이용해서 Node에 도구를 얹혀서 웹 view단을 만들어가는 방법을 할 것이다. 코드가 편해진다.


---

<br><br>

### 6) Node.js 시작!!**

- node.js는 JS 코드의 결과를 브라우저에서가 아니라 이제는 UI로서 결과를 확인할 수 있다.(콘솔창을 이용한 실행환경) 

<br>
- `Read Eval Print Loop` : Node.JS를 이렇게 부르고 1줄 단위로 코드를 읽어 들여서 실행한다, 렛풀 방식의 코드 실행 

<br>
- `CLI` :  Node.JS를 'Command Line Interface(Interpreter)'라고도 부른다.

<br>
- 추가로 Node.JS를 배치 형태로 실행할 수 없을까? : 
	- NodeJS에서는 자바와 같아 보이지만 파일 입출력이나 네트워크(웹 개발을 위한 HTTP 모듈), 프로세서 관리에서만 사용할 수 있다. 
	- 또한, NodeJS는 브라우저가 아니라서 DOM을 사용할 수 없다.

<br>
- 메모장에 실습코드 :
	- first.js

```javascript

let x=30;
let y=30;
let y= x+y;
console(z);

```

<br>
- CLI에서 실행 명령어 :

```

node first

```


---

<br><br>

### 7) npm 사이트 이용하기.

- npm 사이트에는 모듈을 언제든지 올릴 수 있다. 또한, 다른 개발자들에 의해 만들어진 도구인 라이브러리를 다운받을 수 있다. 

<br>
- npm 명령어로 모듈(라이브러리)을 가져올 수 있다. 
	- 명령어 : `npm i "다운받을 모듈명";`

<br>
- 하나의 JS 코드에서 다른 JS 코드를 사용할 수 없었다가 모듈을 통해 사용할 수 있게 되었다. 모듈은 ES5부터 있었다.
 
<br>
- 기본은 `CommonJS`를 사용한다. 우리가 앞으로 사용할 것은 ES6에서 추가된 모듈을 사용한다.

<br>

#### a. 다운받은 기본 라이브러리 실행에 관한 실습 코드 : 

- JS에서는 'require()'라는 함수를 통해서 남이 만든 npm 라이브러리를 사용할 수 있다. require() 함수 사용한 것을 새로운 변수인 객체에 담아서 사용하는데 그 객체는 기존에 만들어진 라이브러리에서 exports를 통해 배포된 라이브러이다. exports는 공유된 라이브러리 객체의 내부 속성을 사용할 수 있게 해준다.

```javascript

// modules 객체에 담아서 그 속성을 사용할 수 있다. 'module'이라는 이름은 예약어라서 바꾸자

const modules = require("newlec-hello");    
modules.hello();	// 해당 모듈의 속성을 이용할 수 있다.(해당 라이브러리 내부 객체의 함수 사용 가능)

```

<br>
- 정리** : NodeJS는 단순히 실행환경이다. 그래서, 앞으로는 Vue를 이용하는 플랫폼을 이용할 예정이다. 다양한 도구를 NodeJS에 다운받아서 사용할 수 있다.(npm 사이트 이용)



<br>

#### b. npm 사이트 제대로 이용하기 : 

- 우리는 npm 사이트에서 '라이브러리'를 받는지 '툴'을 받는 건지 알고 있어야 한다.

<br>
- 라이브러리를 다운받으면 그 파일에서 `package.json` 파일을 확인해보자. 이 파일이 스프링부트의 pom.xml 파일과 같은 역할을 하는 '라이브러리 버전 관리 파일'이다.

<br>
- 해당 라이브러리 파일의 폴더를 지우고나서 `package.json`이 있다면, `npm i` 명령어를 통해서 다시 다운 받을 수 있다. package.json 파일에서 그 라이브러리 내용을 지우고 저장해도 그 모듈이 워크스페이스에서 저절로 사라진다. 



<br>

#### c. 리눅스 환경의 장점 : 

- 리눅스에서는 개발용에서 모든 프로그램이 개발이 가능하다. 해킹이나 모니터링을 체킹할 수 있는 프로그램도 해당 개발환경에서 실행할 수 있다.

<br>
- 프로젝트를 서버에서 돌리기 위해서는 리눅스에서 사용해야 한다. 왜냐하면, 윈도우즈는 리소스가 차기 때문에 1년에 한번 없애줘야 한다. 또한, 윈도우즈 업데이트 때문에 서버를 돌릴 수가 없다.

<br>
- 로드 밸런싱, 클러스터링 등 기능이 전부 리눅스에 있다. 그래서, 배포 운영에는 리눅스를 사용한다. 서버를 돌리기 위해서 다른 OS에서는 에뮬레이터로 개발 환경 관련 프로그램을 써야한다.

<br>
- 그래서, 앞으로 다양한 개발 환경을 위해 리눅스도 공부하자!


---

<br><br>

### 8) Vue를 npm 이용하기!!

- 유닉스 명령어 
	- 'pwd' : 현재 폴더 경로 
	- `clear` : 현재 터미널 내부의 명령어 지우기
	
<br>
- `npm init vue@latest`와 같은 해당 명령어를 이용하면 다음과 같은 파일을 다운 받을 건지 물어본다.
	- 타입스크립트 : 실행어를 자바스크립트로 바꿔준다. 나중에 사용하자. 쓸만 한듯?
	- JSX : 리액트에서 쓰는 뷰단 엔진, 엉망이라서 버리자!
	- vite : 개발용 서버 도구이다. 라이브서버 같은 느낌이다.

<br>

#### a) 실행 명령어

- `npm init vue@latest` : npm에서 Vue를 라이브러리로 다운 받을 수 있다. 모듈로 사용할 수 있다.
- `npm i` : pom.xml 파일과 같은 파일인 package.json 파일을 실행해서 해당 라이브러리를 업데이트 시키자
- `npm run dev` : node 서버 실행

<br>
- `package.json` 파일에서 "scripts"라는 객체를 만들어서 속성으로 starts(npm 예악어에 해당하는 starts)로 만들면 npm 명령어로 실행할 수 있다.
- 내가 만든 객체로 실행하기 위해서 'npm run "라이브러리 이름"'으로 서버를 실행해서 포트번호 '5173'를 이용한다! 

<br>
- 이제는 컴포넌트가 교체되는 방식(라우팅? 방식)이라서 페이지가 다시 로딩이 되는 것이 없다. src 폴더에서 components 폴더를 만들어서 프로젝트 디렉토리 구조로 사용한다.

---

<br><br>

### 9) 정리**

- npm은 'mvn repository'과 같은 앱스토어이며 JS 코드가 NodeJS 실행 환경에서 동작할 수 있도록 서버를 켜주는 것과 같다. 여러가지 도구를 붙여서 사용할 수 있다. 
- NodeJS는 jdk와 같다. 실행 환경 그 자체이다.
- NodeJS는 단순히 실행환경이다. 그래서, 앞으로는 Vue를 이용하는 플랫폼을 이용할 예정이다. 다양한 도구를 NodeJS에 다운받아서 사용할 수 있다.(npm 사이트 이용)


---

<br><br>

# 2. 230403




