---
key: /2023/03/13/Week16-Day.html
title: TIL - 16주차 코드
tags: springboot transaction aop
---

# 1. SpringBoot 방법론 : 230313


<br>
## 1) 트랜잭션 방법론

<br>
### 1) 트랜잭션 개념 : 

- ACID(Automicity, Consistency, Isolation, Durability) 
- 원자성, 일관성, 고립성, 지속성

---

<br><br>
### 2) 트랜잭션 실습 : 

#### a. 첫 번째 실습 :

- 업데이트를 2번 실행했는데 1번만 처리한다. 

- 실습 코드 1 :


<br>

<details>
<summary>DefaultMenuService.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.ui.Model;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

// @Component 어노테이션 설정해서 IOC에서 빈객체를 만들 수 있다. 
@Service
public class DefaultMenuService implements MenuService {
	
	@Autowired
	private MenuRepository repository;
	

	// 객체를 만들어서 결합해준다! 
	// setter가 있어야 xml에서 bean 태그에서 property 속성을 이용할 수 있다. 
	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	@Override
	public List<Menu> getList() {
		return repository.findAll(0,10,"",1,3000,"regDate","desc");
	}

	@Override
	public void pointUp() {
		Menu menu = new Menu();
		
		menu.setId(785L);
		menu.setPrice(1111);
		repository.update(menu);

		menu.setId(785L);
		menu.setPrice(2222);
		repository.update(menu);
	
		
	}

}

```

</div>
</details>


<br>

<details>
<summary>DefaultMenuServiceTest.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.service;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DefaultMenuServiceTest {

	@Autowired
	private MenuService service;
	
	@Test
	void test() {
		service.pointUp();
		System.out.println("작업 완료");
	}

}



```

</div>
</details>


<br>

<details>
<summary>MenuRepository.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.repository;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;

import kr.co.rland.web.entity.Menu;

// ibatis가 원래 이름인데 버전이 업되면서 mybatis로 바뀌었다. mapper로 매핑
// @Mapper가 구현체를 알아서 repository에 붙여준다.

@Mapper
public interface MenuRepository {
	
//	List<Menu> findAll();
//	List<Menu> findAll(Integer offset, Integer size);
	List<Menu> findAll(Integer offset,
					Integer size, 
					String query,
					Integer categoryId,
					Integer price,
					String orderField,
					String orderDir
					);
	
	Menu findById(long id);
	
	// 타입 주의!! 리스트들을 모두 출력하기 때문이다. 
	List<Menu> findAllByIds(List<Long> ids);
	
	// 마지막으로 필요한 count 함수로 마지막 페이지를 구분할 수 있다!!
	int count(
			String query,
			Integer categoryId,
			Integer price);
	
	// 반환 값 수정하기!! 원래 반환 타입이 Menu이다. 
	int insert(Menu menu);
	
	int update(Menu menu);
	
	void delete(long id);
}

```

</div>
</details>

---

<br>
#### b. 두 번째 실습 : 트랜잭션

- 제약 조건을 걸어주고 그 조건에 맞지 않으면 업무가 롤백 처리가 된다. 

- ex) 제약 조건 : "30000" 미만인 Price 조건에서 "30000"으로 업데이트 시키면 어떻게 될까? 

<br>
- 실습 코드 : 

- DefaultMenuService.java

```java
package kr.co.rland.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

// @Component 어노테이션 설정해서 IOC에서 빈객체를 만들 수 있다. 
@Service
public class DefaultMenuService implements MenuService {
	
	@Autowired
	private MenuRepository repository;
	

	// 객체를 만들어서 결합해준다! 
	// setter가 있어야 xml에서 bean 태그에서 property 속성을 이용할 수 있다. 
	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	@Override
	public List<Menu> getList() {
		return repository.findAll(0,10,"",1,3000,"regDate","desc");
	}
	
	// 트랜잭션 추가해서 하나의 업무만 진행되게 할 수 있다.
	@Transactional
	@Override
	public void pointUp() {
		Menu menu = new Menu();
		
		menu.setId(785L);
		menu.setPrice(1111);
		repository.update(menu);

		menu.setId(785L);
		menu.setPrice(30000);
		repository.update(menu);
	
		
	}

}


```

<br>
- 테스트 코드 :
	- DefaultMenuServiceTest.java

```java
package kr.co.rland.web.service;

import org.junit.jupiter.api.Test;
import org.mybatis.spring.boot.test.autoconfigure.AutoConfigureMybatis;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
@AutoConfigureMybatis
class DefaultMenuServiceTest {

	@Autowired
	private MenuService service;
	
	@Test
	void test() {
		service.pointUp();
		System.out.println("작업 완료");
	}

}

```


---

<br><br>
## 2) AOP 방법론


### 1) AOP 개념 

- Aspect Oriented Programming라고 부른다.
- 사용자가 요구하는 코드가 아니라 다양한 사람이 원하는(Aspect) 코딩 
- 실제 업무는 아니고 곁다리 업무와 같다. 
- 수 없이 반복되는 횟수, 수 없이 변경되는 횟수 때문에 나온 방법론이다.

<br>
- 사용 용도 : 
	- Log 출력, 보안 처리, 트랜잭션 처리  

<br>
- 동작 과정 : 
	- Core concern나 Primary concern(주업무)를 위, 아래에 AOP 방법론을 적용한다. AOP 방법론에서는 위, 아래를 포함한 내부에 있는 코어를 Proxy로 이용한다. 
	- proxy(대리자) 개념 : 원본의 이름과 같은 형태이고 실제로 원본은 완전 다른 곳에 있거나 원격에 있는 친구이다.
	- proxy는 기본의 원래 속성 + 다양한 속성들을 곁들일 수 있다. 


<br>
- 실습 코드 :
	- 첫번째 실습 기능 : "calc"로 이용

```java
package kr.co.rland.web.aop;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Program {

	public static void main(String[] args) {
		Calculator calc = new DefaultCalculator(3,4);
		
		// Proxy 테스트 : Calculator와 진짜 같은 가짜 만들기**
		// 인자 설명 : (실제 어떤 기능을 가지고 있는지, 하나의 클래스에 여러개의 인터페이스를 가지고 있는지, 자바에서 제공해주는 AOP)
		// new Class[] {Calculator.class}의 중괄호에서 여러 개의 클래스를 가지고 있다. 
		Calculator 가짜 = (Calculator) Proxy.newProxyInstance(
				DefaultCalculator.class.getClassLoader()
											// invoke() 람다식으로 사용하는법 : 함수 모양만 남기면 된다. args는 ags로 바꾸기(예약어?)
				, new Class[] {Calculator.class}, (Object proxy, Method method, Object[] ags) -> {
						
					// return 5; // 이렇게 쓰면 전부 5만 출력 된다.
					System.out.printf("호출되고 있는 메소드 이름 : %s \n", method.getName()); 
					System.out.printf ("%s 메소드 호출 전 n", method.getName());
					Object result = method.invoke(calc, ags);
					System.out.printf("결과값: %d\n", result);
					System.out.printf("%s 메소드 호출 후 \n", method.getName());
										
					return result;
				}); 
		
		
      int result = 0;
      
		// Proxy에서 진짜를 불러내고 싶으면 proxy 코드를 다 바꿔야 한다. 
		// 이것은 엄청 많이 바꿔줘야해서 이때 Proxy에서 스프링의 DI 기능을 이용한다.
      	// 이것은 원본 객체를 숨길 수 있다. 
      
      result = 가짜.plus();
	  System.out.printf("plus result : %d\n", result);
	  result = 가짜.sub();
	  System.out.printf("sub result : %d\n", result);
	  result = 가짜.multi();
	  System.out.printf("multi result : %d\n", result);
      
//      result = calc.plus();
//      System.out.printf("plus result : %d\n", result);
//      result = calc.sub();
//      System.out.printf("sub result : %d\n", result);
//      result = calc.multi();
//      System.out.printf("multi result : %d\n", result);
	}

}

```


- DefaultCalculator.java

```java
package kr.co.rland.web.aop;

public class DefaultCalculator implements Calculator {
	
	private int x;
	private int y;
	
	public DefaultCalculator() {

	
	}
	
	
	public DefaultCalculator(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}


	public int getX() {
		return x;
	}



	public void setX(int x) {
		this.x = x;
	}



	public int getY() {
		return y;
	}



	public void setY(int y) {
		this.y = y;
	}



	@Override
	public int plus() {
		
		int result = x+y;
		return result;
	}

	@Override
	public int sub() {
		int result = x-y;
		return result;
	}

	@Override
	public int multi() {
		int result = x*y;
		return result;
	}
	
}

```


- Calculator.java

```java

package kr.co.rland.web.aop;

public interface Calculator {
	int plus();
	int sub();
	int multi();
}

```

---

<br><br>
- 두번째 실습 기능 : "진짜"로 이용


```java
package kr.co.rland.web.aop;

import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Program {

	public static void main(String[] args) {
		Calculator 진짜 = new DefaultCalculator(3,4);
		
		// Proxy 테스트 : Calculator와 진짜 같은 가짜 만들기**
		// 인자 설명 : (실제 어떤 기능을 가지고 있는지, 하나의 클래스에 여러개의 인터페이스를 가지고 있는지, 자바에서 제공해주는 AOP)
		// new Class[] {Calculator.class}의 중괄호에서 여러 개의 클래스를 가지고 있다. 
		Calculator 가짜 = (Calculator) Proxy.newProxyInstance(
				DefaultCalculator.class.getClassLoader()
											// invoke() 람다식으로 사용하는법 : 함수 모양만 남기면 된다. args는 ags로 바꾸기(예약어?)
				, new Class[] {Calculator.class}, (Object proxy, Method method, Object[] ags) -> {
						
					// return 5; // 이렇게 쓰면 전부 5만 출력 된다.
					System.out.printf("호출되고 있는 메소드 이름 : %s \n", method.getName()); 
					System.out.printf ("%s 메소드 호출 전 n", method.getName());
					Object result = method.invoke(진짜, ags);
					System.out.printf("결과값: %d\n", result);
					System.out.printf("%s 메소드 호출 후 \n", method.getName());
										
					return result;
				}); 
		
		
      int result = 진짜;
      
		// Proxy에서 진짜를 불러내고 싶으면 proxy 코드를 다 바꿔야 한다. 
		// 이것은 엄청 많이 바꿔줘야해서 이때 Proxy에서 스프링의 DI 기능을 이용한다.
      	// 이것은 원본 객체를 숨길 수 있다. 
      
      result = 가짜.plus();
	  System.out.printf("plus result : %d\n", result);
	  result = 가짜.sub();
	  System.out.printf("sub result : %d\n", result);
	  result = 가짜.multi();
	  System.out.printf("multi result : %d\n", result);
      
//      result = calc.plus();
//      System.out.printf("plus result : %d\n", result);
//      result = calc.sub();
//      System.out.printf("sub result : %d\n", result);
//      result = calc.multi();
//      System.out.printf("multi result : %d\n", result);
	}

}

```

- 위의 두 실습으로 뭐가 "진짜"인지 "calc"인지 알 수가 없다.

<br>
- 스프링은 포인트 컷하는 기능이 있다. 원하는 부분만 넣어서 사용할 수 있다. 하지만 Aspect J에는 그러한 기능이 불필요하게 많다. 


---

<br><br>

### 2) 포인트 컷 개념

- 모든 메서드가 아니라 일부분만 변경하고 싶을 때, 사용한다.

<br>
- `target` : 모든 메서드를 의미한다. 
	- ex) target 1개에 join-point가 3개가 있을 수 있다. 

<br>
- `join-point` : core에 해당하는 부분 

<br>
- `weaving` : proxy가 가지고 있는 부분(앞과 뒤 처리 부분)과 `joint-point`가 가지고 있는 부분을 붙여주는 `weaving`이라고 한다.

<br>
- `point cut` : weaving이 되는 부분을 원하는 범위에서만 한정한다. 자바에는 없고 스프링에서는 point-cut 기능이 어느정도 있다. Aspect J는 point-cut이 있지만 해당 관련 불필요한 기능들도 많다. 

<br>
- 정리 : 무조건 AOP는 원본 코드가 실행되기 전에 실행된다. 사전 작업이나 사후 작업에 사용된다. 그래서 나중에 라이브러리나 프레임워크를 만들 때 사용한다.


---

<br><br>

### 3) Transaction

- 우리는 프로그램밍에서 트랜잭션의 특성 4가지 중에서 원자성, 고립화만 다룬다.

<br>
- 스프링이 제공해주는 고립화는 전파 옵션, 고립도 옵션이 있다.

<br>
- 전파 개념 : 일단 먼저 데이터를 보내는 과정!

<br>
- 문제점 : 같은 자원들을 가지고 2개의 스레드들이 동시에 사용할 때, 처리하는 방법? 


---

<br><br>

# 2. DB 정규화 개념 : 230314

<br>

### 1) 제 1 정규화 : 

- 정의 : 모든 도메인이 원자값으로만 이루어져야만 한다. 

<br>

#### a. 도메인이란? : 

- 값을 이야기한다.
- 유효한 범위의 값이다.

<br>
- 간단히 말하면, "column"이다. 변수이자 변량이자 도메인이자 필드이다.  

<br>

#### b. 제 1 정규화 분석 : 

- 하나의 칼럼에는 같은 데이터가 들어가면 안 된다.?

<br>
- 정리** : 중복을 제거한다. 하나의 속성이 하나의 값을 갖도록 한다.**

<br>
- 이렇게 하지 않으면, 하나의 칼럼에 여러 값이 들어간다. 이것은 제 1 정규화 위반!
- ex) 제 1 정규화 위반 목록 : 전화번호, 팩스 번호, 이메일, 핸드폰 번호, 형태, 세금계산서용 이메일!!

<br>

#### c. 제 1 정규화 적용 : 

- 중요! : 예를 들어, 사진 같은 것은 프로필 사진이 여러 개가 필요해서 "구분자"나 따로 잘라내야 한다. 같이 넣을 수 없다.
- 그래서, 제 1 정규형에 위반되면, 따로 테이블을 떼어 내야 한다. 그래서 "카테고리" 테이블을 잘라냈구나..

<br>
- 예를 들어, 은행명, 예금주명, 계좌번호 등이 있다.

<br>
- 만약에, 정규화로 잘라내지 않고 구분자(",")로 구분해서 사용한다면 java나 쿼리문으로 잘라내어야 한다.


---

<br>

### 2) 제 2 정규화 : 

#### a. 제 2 정규화 정의 :

- 부분 함수 종속성을 없앤다.

<br>

#### b. 제 2 정규화 분석 :

- 여기서 "함수"는 "외래키"를 말한다.
- 참조하는 것이 연산식에 참조한다.

<br>
- 정리 : 외래키가 참고하는 외래키가 있으면 안된다. 그냥 있지 말고 왜래로 가야한다.** 
- 부분함수에 대한 부분이 외래키에 있다.

<br>
- 제 2 정규화는 복합키에서만 쓰이는 개념이고 복합키에서 문제가 발생한 경우이다.
- 복합키가 없으면 제 3 정규화로 넘어가자.

---

<br>

### 3) 제 3 정규화 : 


#### a. 제 3 정규화 정의 : 

- 이행적 함수 종속이 되지 않는 것

<br>
- 이행 : 옮아가는 것
- 이행적 함수 종속 : 함수는 외래키인데 

<br>

#### b. 제 3 정규화 분석 :

- 제 2 정규화는 기본키에서 다시 외래키로 식별하는 것이 문제가 있으며, 제 3정규화는 외래키가 다시 재 참조하는 키가 있으면 문제가 발생한다.
- 외래키가 바로 접근하는 것이 아니라 거쳐서 접근하는 경우가 문제가 있다.

<br>

#### c. 제 3 정규화 정리 :

- 결론 : X->Z를 X->Y와 Y->Z로 쪼개자!! 
- 그래서, 3 정규화가 쪼개지면, 쪼개진 함수는 부모가 된다. "1" : "N"에서 "1" 부분이 부모가 된다.
- 반복될 것 같다고 그러면 거의 대부분 제 3 정규화 위반이다. 


---

<br>

### 4) 제 4 정규화 : 


#### a. 제 4 정규화 정의 :

- "다대다" 관계를 풀어낸 것이다. 


---


<br>

### 5) 프로젝트 DB 관련 정리 

#### a. 피드백

- 참여 테이블에서 채팅 내역으로 정하고 회원마다 채팅 내역을 가지고 있어야 하므로 그래서 참여 테이블을 만들어서 추가하는 것이 맞다.
	- (이렇게 웹소켓 넘겨주기)

- 참여하는 순간 이후부터 채팅 내역이 보이게 된다. 

<br>

#### b. 다른 피드백

- null값이 꽉찰 속성은 할 필요가 없다.(설정창의 속성)

- 공구 상품 테이블에서 따로 뺄 것 : 사진 속성, 모집상태 속성, 관심 속성, 

<br>

#### c. 정리 

- 핵심 : 참여 테이블(액션 엔티티)에 자식의 테이블을 넣을 수 있다!!! 나중에 "메세지" 테이블 넣기!!!!

<br>
- 중요 : 데이터가 중복되는 것과 키가 중복되는 것은 다르다(카테고리 테이블을 따로 뺀 이유!!)

<br>
- 추가 : 제 3 정규화의 데이터 중복은 데이터 중복이 되는 해당 테이블이 생성되기 전에 발생하면 해당 테이블의 부모로 테이블을 따로 빼고, 테이블 생성된 이후의 데이터 중복은 해당 테이블의 자식으로 테이블을 따로 뺀다. 


---

<br><br>

# 3. DB 제약 조건 개념 : 230315

## 1) MySQL 사용법 : 

- SQL문을 사용하기 전에 
	- use "DB명"

<br>

#### a. REVERSE ENGEENEERING :

- EER DIAGRAM 작업 가능
- CREATE를 쓰지 않고 UI에서 툴을 사용하자! 

<br>

#### b. FORWARD ENGEENEERING : 

- DROP하지 말고 진행하기(DROP하면 기존의 테이블들이 다 사라진다!)

- FORWARD ENGEENEERING 작업을 진행해도 EER DIAGRAM에서 계속 작업하고 넘길 수 있다. 

<br>

#### 중요!! : 

- `FORWARD ENGEENEERING`라는 도구가 제대로 동작이 안되면 `use_information`라는 db로 이동하여 데이터 딕셔너리를 이용한다.
	- `use use_information`
	- `show create table comment`
	- 여기서 DDL 명령어를 복사해서 편집키에 붙여놓고 수동적으로 체크 체약 조건을 수정한다.



---


<br>

### 1) MySQL 데이터 타입 종류 : 

<br>
- DATE 타입 :
	- DATETIME vs TIMESTAMP : 
		- MySQL에서 타입을 Date를 길게 쓰고 싶으면 DATETIME을 쓰고 Date를 길게 쓰지 않을 때는 TIMESTAMP를 이용한다. 


---

<br>

### 2) 제약 조건

<br>
#### a. 제약 조건 개념 :
	- 유효한 값의 범위를 말한다.
	- 테이블을 만들기 전에는 SQL문에서 제약조건을 걸어줄 수 있는데 테이블을 생성하고 나서는 테이블의 설정 UI에서 제약조건을 설정할 수 있다.

<br>
#### b. 제약 조건 종류 : 

<br>
- NOT NULL : 
	- 그 칼럼은 데이터가 무조건 NULL이 아니여야 한다.

<br>
- AI(Auto Increamental) 
	- ID를 자동 증가 해준다.(자동 시퀀셜 기능) 

<br>
- 현재 시간 출력 함수 :
	- CURRENT_TIMESTAMP(); : 현재 날짜 + 시간 출력 
	- CURRENT_TIME(); : 현재 시간만 출력 
	- CURRENT_DATE(); : 현재 날짜만 출력


---

<br>

### 3) MySQL 체크 제약 조건 : 

- 보통 패턴을 사용한다. 

<br>
- 이미 만들어진 테이블에서 체크 제약을 하기 위해서 다음 명령어로 추가한다.
	- ALTER TABLE Persons ADD CHECK(AGE>=18);

<br>
- 체크 제약 조건을 위해서 사용하는 변수 명칭 : 
	- chk_menu_price 등등

<br>
- MySQL에서 체크 제약 조건을 위해서 사용 방법이 없어서 명령어로 진행한다.



---

<br>

### 4) MySQL 중복 레코드 제거(키 종류) : 

<br>
- 기본키(Primary Key : PK) : 식별키이며 1개만 존재한다.
	- 하지만, 개인정보는 기본키로 쓸 수 없다. 보통, 비교할 때, 기본키를 사용하고 공개해야하므로 
	- 이메일 주소도 PK로 설정하면 안 된다. 나중에 다시 재가입시, 이메일주소가 식별자라서 그 이메일로 가입할 수 없기 때문이다.
	- 따라서, 기본키는 개인정보를 빼는 것이 좋다.
	- 운영체제(윈도우)에서도 현재 사용자 ID(USER12)를 지우면 별도의 식별자(S11232132)로 변경되어 존재한다.
	
<br>
- 후보키 : 기본키가 될 수 있는 모든 후보들
- 대체키 : 기본키가 아니고 기본키가 아닌 후보키드 

<br>
- 대리키 : 개인정보가 아닌 진짜 식별키이며 일반적으로 번호이다. 예를 들어, 아이디, 번호 등등


<br>
- 외래키 : 
- 수퍼키 : 복합키

<br>
- 각 칼럼들에 동일한 데이터가 들어가면 데이터 결함이 존재한다.

---

<br>

### 5) MySQL 엔티티 제한 조건(중요!!) : 

- 엔티티 제약 조건 : PK 제약 조건, 유닉 제약 조건이 있다.

<br>
- 유닉 제한 조건 : PK가 아니면서 중복이 되지 않아야 경우에 사용된다. 사용 방법은 NULL값도 허용되면 안 된다. 따라서, MySQL에서 UQ와 NN을 동시에 조건으로 넣어줘야 한다. 
	- 예를 들어, 서비스에서 회원이 회원을 탈퇴하면, 회원 아이디는 사라져도 식별자는 남아야 한다. 회원 아이디가 PK가 되면 그 회원아이디명으로 재가입을 할 수 없기 때문이다. 그래서 식별자(PK)는 따로 두고 아이디는 유닉 제한 조건을 걸어둔다. 
	- 따라서, "아이디"는 "유닉 제한 조건"이여야 한다.

<br>	
- UQ : Unique Key

- NN : NOT NULL

---

<br>

### 6) MySQL Foreign Key(FK) 제한 조건 :

- 엔티티와 엔티티의 관계가 끊어지는 경우 방지 

<br>	
- 1:N, N:N 관계에 있을 때, FK로 받으면 그 FK가 NOT NULL일 때, 관계가 끊어지는 것을 막아준다.

<br>	
- FK 제약 조건은 자식에 붙어야 한다.

<br>
- DB를 만들 때, 체크 제약 조건에 에러가 발생하면, DB의 레코드를 다 지우고 처음부터 작성해야 한다.

---


<br><br>

## 2) 트랜잭션 동시성

- 트랜잭션 전파 개념

### a. 트랜잭션의 고립화 종류

<br>
- Dirty Read : 
	- 업데이트가 되고 인서트 하다가 에러가 발생하는 중에 어떤 스레드가 업데이트를 읽어버림, 그것은 원래 되돌가기 전의 값으로 읽어버림. 그래서 문제가 많다.

<br>
- Non-repeatable read : 
	- 다른 스레드가 읽기만 해도 기다린다!

<br>
- Phantom read : 
	- 삭제될 녀석을 읽어 들임. 내가 읽기도 전에 
	- 내가 읽기만해도 내가 건드리는 테이블을 아무도 건드리지말고 기다려야 한다. 
	- 누가 조금이라도 사용하기만 해도 테이블 전체를 잠궈버린다.


---

<br>

### b. 고립화 필요 개념 :

<br>
- DEFAULT : 아래 4개 옵션 중의 1개이다.

<br>
- READ UNCOMMITTED : (가장 느슨한 옵션) 성능은 좋은데 Dirty Read를 읽을 수 있다.(롤백될 내용을 읽을 수 있다. )

<br>
- READ_COMMITTED : 커밋된 것만 읽을 수 있어서 이것은 오라클DB에서 사용된다. MariaDB도 이것을 사용해서 Dirty Read에 문제는 없다.(기본 옵션)
	- 다른 스레드가 수정을 하면 기다린다.

<br>
- REPEATABLE READ : 
	- NON-REPEATABLE READ은 업데이트를 하고 그 값을 다시 읽으려고 하는데 다른 스레드가 없애버리면 그것을 읽을 수 없다. 동시성의 문제이다. 
	- NON-REPEATABLE READ은 다른 스레드가 읽기만 해도 기다린다!(READ_COMMITTED와 차이점) 
	- REPEATABLE READ와는 반대 개념이다.

<br>
- SERIALIZABLE : 제일 세다. 내가 손대는 순간 잠궈 버린다.
	
<br>
- 고립화를 느슨하게 해주는 것이 "성능"이다.
	- 즉, 못 읽게하는 것은 기다리는 것이다.

---

<br>

### c. Spring-Boot 트랜잭션에 고립화 적용 :

#### a) isolation 속성

- 어느 정도 고립화를 시킬지 어노테이션에 설정해주면 된다.

- `@Transaction(isolation = "고립화 레벨 선택")`

- 기본 옵션이 `READ_COMMITTED` 이다. 

<br>

#### b) propagation 개념(더 찾아보기)

- 업데이트하는데 같이 참여하거나 참여하지 않거나 하는 경우 따로 처리해줄 경우가 필요할 때, propagation 속성을 사용한다.
- 원자성에 위배되는 개념이지만 따로 빠질 수 있다.

<br>
- 사용방법 : 
	- 전파옵션은 전파되는 자식이 갖는다. 


<br>
- 실습 코드 : 
	- DefaultMenuService.java

```java

@Service
public class DefaultMenuService implements MenuService {
	
	@Autowired
	private MenuRepository repository;
	

	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	// 트랜잭션 추가해서 하나의 업무만 진행되게 할 수 있다.
	@Transactional(propagation = )
	@Override
	public void pointUp() {
		repository.update([3,2,7,8], 1);
		repository.update(3);
	
		
	}
}

```

<br>
- MenuService.java

```java
package kr.co.rland.web.service;

import java.util.List;

import kr.co.rland.web.entity.Menu;

public interface MenuService {
	
	// 서비스 계층에서는 사용자 요청을 이름 그대로 그대로 만들어라!!
	List<Menu> getList();	
	void pointUp();
}

```

<br>
- MenuRepository.java

```java
package kr.co.rland.web.repository;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;

import kr.co.rland.web.entity.Menu;

// ibatis가 원래 이름인데 버전이 업되면서 mybatis로 바뀌었다. mapper로 매핑
// @Mapper가 구현체를 알아서 repository에 붙여준다.

@Mapper
public interface MenuRepository {
	
//	List<Menu> findAll();
//	List<Menu> findAll(Integer offset, Integer size);
	List<Menu> findAll(Integer offset,
					Integer size, 
					String query,
					Integer categoryId,
					Integer price,
					String orderField,
					String orderDir
					);
	
	Menu findById(long id);
	
	// 타입 주의!! 리스트들을 모두 출력하기 때문이다. 
	List<Menu> findAllByIds(List<Long> ids);
	
	// 마지막으로 필요한 count 함수로 마지막 페이지를 구분할 수 있다!!
	int count(
			String query,
			Integer categoryId,
			Integer price);
	
	// 원래는 Menu가 반환 타입이다.
	int insert(Menu menu);
	
	int update(Menu menu);
	
	void delete(long id);
}

```

<br>

#### c) Propagation 속성 종류(더 찾아보기) : 

- Propagation.mandatory :
	- 서비스에서 내가 트랜잭션을 가지고 있지 않으면 호출자가 트랜잭션을 가지고 있어야 한다.

<br>
- Propagation.nested : 
	- 현재 트랜잭션이 존재하는데 서비스에서 트랜잭션을 가지고 오는데 안쪽에서 트랜잭션을 진행한다. 

<br>
- Propagation.supports : 
	- 서비스에서 트랜잭션을 가지고 오면 지원정도는 해준다.(같이 따라간다.) Non-supports이면 트랜잭션을 하지 않는다. 

<br>
- Propagation.requiresnew : 
	- 무조건 새로운 트랜잭션을 만든다. 나는 부모의 트랜잭션에 나를 엮지 마라, 항상 새 트랜잭션을 만든다.

<br>
- Propagation.requires_new : 
	- 현재 트랜잭션이 있으면 지원해주고, 

<br>
- Propagation.required : 
	- 누군가가 나를 호출하면 나는 트랜잭션도 하지 않고 그냥 지나가라. 내가 실행되면 나 끝나기까지 기다리고 그 다음에 트랜잭션을 진행 suspend(기다려라)   

<br>
- Propagation.never : 
	- 나를 트랜잭션에 실행하면 화낸다.

<br>
- Propagation.nested(추가**) :
	-  현재 트랜잭션이 있으면, 부모의 트랜잭션은 같이 끼지 않고 트랜잭션 안쪽에서 중첩?해서 트랜잭션을 진행한다. 


---

<br>

#### d) 정리** : 

- propagation 속성은 행위가 별도의 트랜잭션 처리를 해주거나 참여하던가 참여하지 않던가하는 처리 방법에 쓰인다. 



---


# 4. 트랜잭션 


### 1) 트랜잭션 


