---
key: /2023/03/13/Week16-Day.html
title: TIL - 16주차 코드
tags: springboot transaction aop
---

# 1. SpringBoot 방법론 : 230313


<br>
## 1) 트랜잭션 방법론

<br>
### 1) 트랜잭션 개념 : 

- ACID(Automicity, Consistency, Isolation, Durability) 
- 원자성, 일관성, 고립성, 지속성

---

<br><br>
### 2) 트랜잭션 실습 : 

#### a. 첫 번째 실습 :

- 업데이트를 2번 실행했는데 1번만 처리한다. 

- 실습 코드 1 :


<br>

<details>
<summary>DefaultMenuService.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.ui.Model;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

// @Component 어노테이션 설정해서 IOC에서 빈객체를 만들 수 있다. 
@Service
public class DefaultMenuService implements MenuService {
	
	@Autowired
	private MenuRepository repository;
	

	// 객체를 만들어서 결합해준다! 
	// setter가 있어야 xml에서 bean 태그에서 property 속성을 이용할 수 있다. 
	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	@Override
	public List<Menu> getList() {
		return repository.findAll(0,10,"",1,3000,"regDate","desc");
	}

	@Override
	public void pointUp() {
		Menu menu = new Menu();
		
		menu.setId(785L);
		menu.setPrice(1111);
		repository.update(menu);

		menu.setId(785L);
		menu.setPrice(2222);
		repository.update(menu);
	
		
	}

}

```

</div>
</details>


<br>

<details>
<summary>DefaultMenuServiceTest.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.service;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DefaultMenuServiceTest {

	@Autowired
	private MenuService service;
	
	@Test
	void test() {
		service.pointUp();
		System.out.println("작업 완료");
	}

}



```

</div>
</details>


<br>

<details>
<summary>MenuRepository.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.repository;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;

import kr.co.rland.web.entity.Menu;

// ibatis가 원래 이름인데 버전이 업되면서 mybatis로 바뀌었다. mapper로 매핑
// @Mapper가 구현체를 알아서 repository에 붙여준다.

@Mapper
public interface MenuRepository {
	
//	List<Menu> findAll();
//	List<Menu> findAll(Integer offset, Integer size);
	List<Menu> findAll(Integer offset,
					Integer size, 
					String query,
					Integer categoryId,
					Integer price,
					String orderField,
					String orderDir
					);
	
	Menu findById(long id);
	
	// 타입 주의!! 리스트들을 모두 출력하기 때문이다. 
	List<Menu> findAllByIds(List<Long> ids);
	
	// 마지막으로 필요한 count 함수로 마지막 페이지를 구분할 수 있다!!
	int count(
			String query,
			Integer categoryId,
			Integer price);
	
	// 반환 값 수정하기!! 원래 반환 타입이 Menu이다. 
	int insert(Menu menu);
	
	int update(Menu menu);
	
	void delete(long id);
}

```

</div>
</details>

---

<br>
#### b. 두 번째 실습 : 트랜잭션

- 제약 조건을 걸어주고 그 조건에 맞지 않으면 업무가 롤백 처리가 된다. 

- ex) 제약 조건 : "30000" 미만인 Price 조건에서 "30000"으로 업데이트 시키면 어떻게 될까? 

<br>
- 실습 코드 : 

- DefaultMenuService.java

```java
package kr.co.rland.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

// @Component 어노테이션 설정해서 IOC에서 빈객체를 만들 수 있다. 
@Service
public class DefaultMenuService implements MenuService {
	
	@Autowired
	private MenuRepository repository;
	

	// 객체를 만들어서 결합해준다! 
	// setter가 있어야 xml에서 bean 태그에서 property 속성을 이용할 수 있다. 
	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	@Override
	public List<Menu> getList() {
		return repository.findAll(0,10,"",1,3000,"regDate","desc");
	}
	
	// 트랜잭션 추가해서 하나의 업무만 진행되게 할 수 있다.
	@Transactional
	@Override
	public void pointUp() {
		Menu menu = new Menu();
		
		menu.setId(785L);
		menu.setPrice(1111);
		repository.update(menu);

		menu.setId(785L);
		menu.setPrice(30000);
		repository.update(menu);
	
		
	}

}


```

<br>
- 테스트 코드 :
	- DefaultMenuServiceTest.java

```java
package kr.co.rland.web.service;

import org.junit.jupiter.api.Test;
import org.mybatis.spring.boot.test.autoconfigure.AutoConfigureMybatis;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
@AutoConfigureMybatis
class DefaultMenuServiceTest {

	@Autowired
	private MenuService service;
	
	@Test
	void test() {
		service.pointUp();
		System.out.println("작업 완료");
	}

}

```


---

<br><br>
## 2) AOP 방법론


### 1) AOP 개념 

- Aspect Oriented Programming라고 부른다.
- 사용자가 요구하는 코드가 아니라 다양한 사람이 원하는(Aspect) 코딩 
- 실제 업무는 아니고 곁다리 업무와 같다. 
- 수 없이 반복되는 횟수, 수 없이 변경되는 횟수 때문에 나온 방법론이다.

<br>
- 사용 용도 : 
	- Log 출력, 보안 처리, 트랜잭션 처리  

<br>
- 동작 과정 : 
	- Core concern나 Primary concern(주업무)를 위, 아래에 AOP 방법론을 적용한다. 위, 아래 말고 내부에 있는 코어는 Proxy를 이용한다. 
	- proxy(대리자) 개념 : 원본의 이름과 같은 형태이고 실제로 원본은 완전 다른 곳에 있거나 원격에 있는 친구이다.
	- proxy는 기본의 원래 속성 + 다양한 속성들을 곁들일 수 있다. 


<br>
- 실습 코드 :
	- 첫번째 실습 기능 : "calc"로 이용

```java
package kr.co.rland.web.aop;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Program {

	public static void main(String[] args) {
		Calculator calc = new DefaultCalculator(3,4);
		
		// Proxy 테스트 : Calculator와 진짜 같은 가짜 만들기**
		// 인자 설명 : (실제 어떤 기능을 가지고 있는지, 하나의 클래스에 여러개의 인터페이스를 가지고 있는지, 자바에서 제공해주는 AOP)
		// new Class[] {Calculator.class}의 중괄호에서 여러 개의 클래스를 가지고 있다. 
		Calculator 가짜 = (Calculator) Proxy.newProxyInstance(
				DefaultCalculator.class.getClassLoader()
											// invoke() 람다식으로 사용하는법 : 함수 모양만 남기면 된다. args는 ags로 바꾸기(예약어?)
				, new Class[] {Calculator.class}, (Object proxy, Method method, Object[] ags) -> {
						
					// return 5; // 이렇게 쓰면 전부 5만 출력 된다.
					System.out.printf("호출되고 있는 메소드 이름 : %s \n", method.getName()); 
					System.out.printf ("%s 메소드 호출 전 n", method.getName());
					Object result = method.invoke(calc, ags);
					System.out.printf("결과값: %d\n", result);
					System.out.printf("%s 메소드 호출 후 \n", method.getName());
										
					return result;
				}); 
		
		
      int result = 0;
      
		// Proxy에서 진짜를 불러내고 싶으면 proxy 코드를 다 바꿔야 한다. 
		// 이것은 엄청 많이 바꿔줘야해서 이때 Proxy에서 스프링의 DI 기능을 이용한다.
      	// 이것은 원본 객체를 숨길 수 있다. 
      
      result = 가짜.plus();
	  System.out.printf("plus result : %d\n", result);
	  result = 가짜.sub();
	  System.out.printf("sub result : %d\n", result);
	  result = 가짜.multi();
	  System.out.printf("multi result : %d\n", result);
      
//      result = calc.plus();
//      System.out.printf("plus result : %d\n", result);
//      result = calc.sub();
//      System.out.printf("sub result : %d\n", result);
//      result = calc.multi();
//      System.out.printf("multi result : %d\n", result);
	}

}

```


- DefaultCalculator.java

```java
package kr.co.rland.web.aop;

public class DefaultCalculator implements Calculator {
	
	private int x;
	private int y;
	
	public DefaultCalculator() {

	
	}
	
	
	public DefaultCalculator(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}


	public int getX() {
		return x;
	}



	public void setX(int x) {
		this.x = x;
	}



	public int getY() {
		return y;
	}



	public void setY(int y) {
		this.y = y;
	}



	@Override
	public int plus() {
		
		int result = x+y;
		return result;
	}

	@Override
	public int sub() {
		int result = x-y;
		return result;
	}

	@Override
	public int multi() {
		int result = x*y;
		return result;
	}
	
}

```


- Calculator.java

```java

package kr.co.rland.web.aop;

public interface Calculator {
	int plus();
	int sub();
	int multi();
}

```

---

<br><br>
- 두번째 실습 기능 : "진짜"로 이용


```java
package kr.co.rland.web.aop;

import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Program {

	public static void main(String[] args) {
		Calculator 진짜 = new DefaultCalculator(3,4);
		
		// Proxy 테스트 : Calculator와 진짜 같은 가짜 만들기**
		// 인자 설명 : (실제 어떤 기능을 가지고 있는지, 하나의 클래스에 여러개의 인터페이스를 가지고 있는지, 자바에서 제공해주는 AOP)
		// new Class[] {Calculator.class}의 중괄호에서 여러 개의 클래스를 가지고 있다. 
		Calculator 가짜 = (Calculator) Proxy.newProxyInstance(
				DefaultCalculator.class.getClassLoader()
											// invoke() 람다식으로 사용하는법 : 함수 모양만 남기면 된다. args는 ags로 바꾸기(예약어?)
				, new Class[] {Calculator.class}, (Object proxy, Method method, Object[] ags) -> {
						
					// return 5; // 이렇게 쓰면 전부 5만 출력 된다.
					System.out.printf("호출되고 있는 메소드 이름 : %s \n", method.getName()); 
					System.out.printf ("%s 메소드 호출 전 n", method.getName());
					Object result = method.invoke(진짜, ags);
					System.out.printf("결과값: %d\n", result);
					System.out.printf("%s 메소드 호출 후 \n", method.getName());
										
					return result;
				}); 
		
		
      int result = 진짜;
      
		// Proxy에서 진짜를 불러내고 싶으면 proxy 코드를 다 바꿔야 한다. 
		// 이것은 엄청 많이 바꿔줘야해서 이때 Proxy에서 스프링의 DI 기능을 이용한다.
      	// 이것은 원본 객체를 숨길 수 있다. 
      
      result = 가짜.plus();
	  System.out.printf("plus result : %d\n", result);
	  result = 가짜.sub();
	  System.out.printf("sub result : %d\n", result);
	  result = 가짜.multi();
	  System.out.printf("multi result : %d\n", result);
      
//      result = calc.plus();
//      System.out.printf("plus result : %d\n", result);
//      result = calc.sub();
//      System.out.printf("sub result : %d\n", result);
//      result = calc.multi();
//      System.out.printf("multi result : %d\n", result);
	}

}

```

- 위의 두 실습으로 뭐가 "진짜"인지 "calc"인지 알 수가 없다.

<br>
- 스프링은 포인트 컷하는 기능이 있다. 원하는 부분만 넣어서 사용할 수 있다. 하지만 Aspect J에는 그러한 기능이 불필요하게 많다. 


---

<br><br>

### 2) 포인트 컷 개념

- 모든 메서드가 아니라 일부분만 변경하고 싶을 때, 사용한다.

<br>
- `target` : 모든 메서드를 의미한다. 
	- ex) target 1개에 join-point가 3개가 있을 수 있다. 

<br>
- `join-point` : core에 해당하는 부분 

<br>
- `weaving` : proxy가 가지고 있는 부분(앞과 뒤 처리 부분)과 `joint-point`가 가지고 있는 부분을 붙여주는 `weaving`이라고 한다.

<br>
- `point cut` : weaving이 되는 부분을 원하는 범위에서만 한정한다. 자바에는 없고 스프링에서는 있다. Aspect J는 불필요한 기능이 많다. 

<br>
- 정리 : 무조건 AOP는 원본 코드가 실행되기 전에 실행된다. 사전 작업이나 사후 작업에 사용된다. 그래서 나중에 라이브러리나 프레임워크를 만들 때 사용한다.


---

<br><br>

### 3) Transaction

- 우리는 프로그램밍에서 트랜잭션의 원자성, 고립화만 다룬다.

<br>
- 스프링이 제공해주는 고립화는 전파 옵션, 고립도 옵션이 있다.

<br>
- 전파 개념 : 일단 먼저 데이터를 보내는 과정!

<br>
- 문제점 : 같은 자원들을 가지고 2개의 스레드들이 동시에 사용할 때, 처리하는 방법? 


---

<br><br>

# 2. DB 정규화 개념 : 230314

<br>

### 1) 제 1 정규화 : 

- 정의 : 모든 도메인이 원자값으로만 이루어져야만 한다. 

<br>

#### a. 도메인이란? : 

- 값을 이야기한다.
- 유효한 범위의 값이다.

<br>
- 간단히 말하면, "column"이다. 변수이자 변량이자 도메인이자 필드이다.  

<br>

#### b. 제 1 정규화 분석 : 

- 하나의 칼럼에는 같은 데이터가 들어가면 안 된다.?

<br>
- 정리** : 중복을 제거한다. 하나의 속성이 하나의 값을 갖도록 한다.**

<br>
- 이렇게 하지 않으면, 하나의 칼럼에 여러 값이 들어간다. 이것은 제 1 정규화 위반!
- ex) 제 1 정규화 위반 목록 : 전화번호, 팩스 번호, 이메일, 핸드폰 번호, 형태, 세금계산서용 이메일!!

<br>

#### c. 제 1 정규화 적용 : 

- 중요! : 예를 들어, 사진 같은 것은 프로필 사진이 여러 개가 필요해서 "구분자"나 따로 잘라내야 한다. 같이 넣을 수 없다.
- 그래서, 제 1 정규형에 위반되면, 따로 테이블을 떼어 내야 한다. 그래서 "카테고리" 테이블을 잘라냈구나..

<br>
- 예를 들어, 은행명, 예금주명, 계좌번호 등이 있다.

<br>
- 만약에, 정규화로 잘라내지 않고 구분자(",")로 구분해서 사용한다면 java나 쿼리문으로 잘라내어야 한다.


---

<br>

### 2) 제 2 정규화 : 

#### a. 제 2 정규화 정의 :

- 부분 함수 종속성을 없앤다.

<br>

#### b. 제 2 정규화 분석 :

- 여기서 "함수"는 "왜래키"를 말한다.
- 참조하는 것이 연산식에 참조한다.

<br>
- 정리 : 왜래키가 참고하는 왜래키가 있으면 안된다. 그냥 있지 말고 왜래로 가야한다.** 
- 부분함수에 대한 부분이 왜래키에 있다.

<br>
- 제 2 정규화는 복합키에서만 쓰이는 개념이고 복합키에서 문제가 발생한 경우이다.
- 복합키가 없으면 제 3 정규화로 넘어가자.

---

<br>

### 3) 제 3 정규화 : 


#### a. 제 3 정규화 정의 : 

- 이행적 함수 종속이 되지 않는 것

<br>
- 이행 : 옮아가는 것
- 이행적 함수 종속 : 함수는 왜래키인데 

<br>

#### b. 제 3 정규화 분석 :

- 제 2 정규화는 기본키에서 다시 왜래키로 식별하는 것이 문제가 있으며, 제 3정규화는 왜래키가 다시 재 참조하는 키가 있으면 문제가 발생한다.
- 왜래키가 바로 접근하는 것이 아니라 거쳐서 접근하는 경우가 문제가 있다.

<br>

#### c. 제 3 정규화 정리 :

- 결론 : X->Z를 X->Y와 Y->Z로 쪼개자!! 
- 그래서, 3 정규화가 쪼개지면, 쪼개진 함수는 부모가 된다. "1" : "N"에서 "1" 부분이 부모가 된다.
- 반복될 것 같다고 그러면 거의 대부분 제 3 정규화 위반이다. 


---

<br>

### 4) 제 4 정규화 : 


#### a. 제 4 정규화 정의 :

- "다대다" 관계를 풀어낸 것이다. 


---


<br>

### 5) 프로젝트 DB 관련 정리 

### a. 피드백

- 참여 테이블에서 채팅 내역으로 정하고 회원마다 채팅 내역을 가지고 있어야 하므로 그래서 참여 테이블을 만들어서 추가하는 것이 맞다.
	- (이렇게 웹소켓 넘겨주기)

- 참여하는 순간 이후부터 채팅 내역이 보이게 된다. 

<br>

### b. 다른 피드백

- null값이 꽉찰 속성은 할 필요가 없다.(설정창의 속성)

- 공구 상품 테이블에서 따로 뺄 것 : 사진 속성, 모집상태 속성, 관심 속성, 

<br>

### c. 정리 

- 핵심 : 참여 테이블(액션 엔티티)에 자식의 테이블을 넣을 수 있다!!! 나중에 "메세지" 테이블 넣기!!!!

<br>
- 중요 : 데이터가 중복되는 것과 키가 중복되는 것은 다르다(카테고리 테이블을 따로 뺀 이유!!)

<br>
- 추가 : 제 3 정규화의 데이터 중복은 데이터 중복이 되는 해당 테이블이 생성되기 전에 발생하면 해당 테이블의 부모로 테이블을 따로 빼고, 테이블 생성된 이후의 데이터 중복은 해당 테이블의 자식으로 테이블을 따로 뺀다. 


