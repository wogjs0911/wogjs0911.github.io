---
key: /2023/03/13/Week16-Day.html
title: TIL - 16주차 코드
tags: springboot transaction aop
---

# 1. SpringBoot 방법론 : 230313


<br>
### 1) 트랜잭션 개념 : 

- ACID(Automicity, Consistency, Isolation, Durability) 
- 원자성, 일관성, 고립성, 지속성

---

<br><br>
### 2) 트랜잭션 실습 : 

#### a. 첫 번째 실습 :

- 업데이트를 2번 실행했는데 1번만 처리한다. 

- 실습 코드 1 :


<br>

<details>
<summary>DefaultMenuService.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.ui.Model;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

// @Component 어노테이션 설정해서 IOC에서 빈객체를 만들 수 있다. 
@Service
public class DefaultMenuService implements MenuService {
	
	@Autowired
	private MenuRepository repository;
	

	// 객체를 만들어서 결합해준다! 
	// setter가 있어야 xml에서 bean 태그에서 property 속성을 이용할 수 있다. 
	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	@Override
	public List<Menu> getList() {
		return repository.findAll(0,10,"",1,3000,"regDate","desc");
	}

	@Override
	public void pointUp() {
		Menu menu = new Menu();
		
		menu.setId(785L);
		menu.setPrice(1111);
		repository.update(menu);

		menu.setId(785L);
		menu.setPrice(2222);
		repository.update(menu);
	
		
	}

}

```

</div>
</details>


<br>

<details>
<summary>DefaultMenuServiceTest.java</summary>
<div markdown="1">


```java
package kr.co.rland.web.service;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DefaultMenuServiceTest {

	@Autowired
	private MenuService service;
	
	@Test
	void test() {
		service.pointUp();
		System.out.println("작업 완료");
	}

}



```

</div>
</details>


<br>

<details>
<summary>MenuRepository.java</summary>
<div markdown="1">

```java
package kr.co.rland.web.repository;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;

import kr.co.rland.web.entity.Menu;

// ibatis가 원래 이름인데 버전이 업되면서 mybatis로 바뀌었다. mapper로 매핑
// @Mapper가 구현체를 알아서 repository에 붙여준다.

@Mapper
public interface MenuRepository {
	
//	List<Menu> findAll();
//	List<Menu> findAll(Integer offset, Integer size);
	List<Menu> findAll(Integer offset,
					Integer size, 
					String query,
					Integer categoryId,
					Integer price,
					String orderField,
					String orderDir
					);
	
	Menu findById(long id);
	
	// 타입 주의!! 리스트들을 모두 출력하기 때문이다. 
	List<Menu> findAllByIds(List<Long> ids);
	
	// 마지막으로 필요한 count 함수로 마지막 페이지를 구분할 수 있다!!
	int count(
			String query,
			Integer categoryId,
			Integer price);
	
	// 반환 값 수정하기!! 원래 반환 타입이 Menu이다. 
	int insert(Menu menu);
	
	int update(Menu menu);
	
	void delete(long id);
}

```

</div>
</details>

---

<br>
#### b. 두 번째 실습 : 트랜잭션

- 제약 조건을 걸어주고 그 조건에 맞지 않으면 업무가 롤백 처리가 된다. 

- ex) 제약 조건 : "30000" 미만인 Price 조건에서 "30000"으로 업데이트 시키면 어떻게 될까? 

<br>
- 실습 코드 : 

- DefaultMenuService.java

```java
package kr.co.rland.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import kr.co.rland.web.entity.Menu;
import kr.co.rland.web.repository.MenuRepository;

// @Component 어노테이션 설정해서 IOC에서 빈객체를 만들 수 있다. 
@Service
public class DefaultMenuService implements MenuService {
	
	@Autowired
	private MenuRepository repository;
	

	// 객체를 만들어서 결합해준다! 
	// setter가 있어야 xml에서 bean 태그에서 property 속성을 이용할 수 있다. 
	public void setRepository(MenuRepository repository) {
		this.repository = repository;
	}

	@Override
	public List<Menu> getList() {
		return repository.findAll(0,10,"",1,3000,"regDate","desc");
	}
	
	// 트랜잭션 추가해서 하나의 업무만 진행되게 할 수 있다.
	@Transactional
	@Override
	public void pointUp() {
		Menu menu = new Menu();
		
		menu.setId(785L);
		menu.setPrice(1111);
		repository.update(menu);

		menu.setId(785L);
		menu.setPrice(30000);
		repository.update(menu);
	
		
	}

}


```

<br>
- 테스트 코드 :
	- DefaultMenuServiceTest.java

```java
package kr.co.rland.web.service;

import org.junit.jupiter.api.Test;
import org.mybatis.spring.boot.test.autoconfigure.AutoConfigureMybatis;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
@AutoConfigureMybatis
class DefaultMenuServiceTest {

	@Autowired
	private MenuService service;
	
	@Test
	void test() {
		service.pointUp();
		System.out.println("작업 완료");
	}

}

```


---

<br><br>
## 2) AOP 방법론


### 1) AOP 개념 

- Aspect Oriented Programming라고 부른다.
- 사용자가 요구하는 코드가 아니라 다양한 사람이 원하는(Aspect) 코딩 
- 실제 업무는 아니고 곁다리 업무와 같다. 
- 수 없이 반복되는 횟수, 수 없이 변경되는 횟수 때문에 나온 방법론이다.

<br>
- 사용 용도 : 
	- Log 출력, 보안 처리, 트랜잭션 처리  

<br>
- 동작 과정 : 
	- Core concern나 Primary concern(주업무)를 위, 아래에 AOP 방법론을 적용한다. 위, 아래 말고 내부에 있는 코어는 Proxy를 이용한다. 
	- proxy(대리자) 개념 : 원본의 이름과 같은 형태이고 실제로 원본은 완전 다른 곳에 있거나 원격에 있는 친구이다.
	- proxy는 기본의 원래 속성 + 다양한 속성들을 곁들일 수 있다. 


<br>
- 실습 코드 :
	- 첫번째 실습 기능 : "calc"로 이용

```java
package kr.co.rland.web.aop;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Program {

	public static void main(String[] args) {
		Calculator calc = new DefaultCalculator(3,4);
		
		// Proxy 테스트 : Calculator와 진짜 같은 가짜 만들기**
		// 인자 설명 : (실제 어떤 기능을 가지고 있는지, 하나의 클래스에 여러개의 인터페이스를 가지고 있는지, 자바에서 제공해주는 AOP)
		// new Class[] {Calculator.class}의 중괄호에서 여러 개의 클래스를 가지고 있다. 
		Calculator 가짜 = (Calculator) Proxy.newProxyInstance(
				DefaultCalculator.class.getClassLoader()
											// invoke() 람다식으로 사용하는법 : 함수 모양만 남기면 된다. args는 ags로 바꾸기(예약어?)
				, new Class[] {Calculator.class}, (Object proxy, Method method, Object[] ags) -> {
						
					// return 5; // 이렇게 쓰면 전부 5만 출력 된다.
					System.out.printf("호출되고 있는 메소드 이름 : %s \n", method.getName()); 
					System.out.printf ("%s 메소드 호출 전 n", method.getName());
					Object result = method.invoke(calc, ags);
					System.out.printf("결과값: %d\n", result);
					System.out.printf("%s 메소드 호출 후 \n", method.getName());
										
					return result;
				}); 
		
		
      int result = 0;
      
		// Proxy에서 진짜를 불러내고 싶으면 proxy 코드를 다 바꿔야 한다. 
		// 이것은 엄청 많이 바꿔줘야해서 이때 Proxy에서 스프링의 DI 기능을 이용한다.
      	// 이것은 원본 객체를 숨길 수 있다. 
      
      result = 가짜.plus();
	  System.out.printf("plus result : %d\n", result);
	  result = 가짜.sub();
	  System.out.printf("sub result : %d\n", result);
	  result = 가짜.multi();
	  System.out.printf("multi result : %d\n", result);
      
//      result = calc.plus();
//      System.out.printf("plus result : %d\n", result);
//      result = calc.sub();
//      System.out.printf("sub result : %d\n", result);
//      result = calc.multi();
//      System.out.printf("multi result : %d\n", result);
	}

}

```


- DefaultCalculator.java

```java
package kr.co.rland.web.aop;

public class DefaultCalculator implements Calculator {
	
	private int x;
	private int y;
	
	public DefaultCalculator() {

	
	}
	
	
	public DefaultCalculator(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}


	public int getX() {
		return x;
	}



	public void setX(int x) {
		this.x = x;
	}



	public int getY() {
		return y;
	}



	public void setY(int y) {
		this.y = y;
	}



	@Override
	public int plus() {
		
		int result = x+y;
		return result;
	}

	@Override
	public int sub() {
		int result = x-y;
		return result;
	}

	@Override
	public int multi() {
		int result = x*y;
		return result;
	}
	
}

```


- Calculator.java

```java

package kr.co.rland.web.aop;

public interface Calculator {
	int plus();
	int sub();
	int multi();
}

```

---

<br><br>
- 두번째 실습 기능 : "진짜"로 이용


```java
package kr.co.rland.web.aop;

import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Program {

	public static void main(String[] args) {
		Calculator 진짜 = new DefaultCalculator(3,4);
		
		// Proxy 테스트 : Calculator와 진짜 같은 가짜 만들기**
		// 인자 설명 : (실제 어떤 기능을 가지고 있는지, 하나의 클래스에 여러개의 인터페이스를 가지고 있는지, 자바에서 제공해주는 AOP)
		// new Class[] {Calculator.class}의 중괄호에서 여러 개의 클래스를 가지고 있다. 
		Calculator 가짜 = (Calculator) Proxy.newProxyInstance(
				DefaultCalculator.class.getClassLoader()
											// invoke() 람다식으로 사용하는법 : 함수 모양만 남기면 된다. args는 ags로 바꾸기(예약어?)
				, new Class[] {Calculator.class}, (Object proxy, Method method, Object[] ags) -> {
						
					// return 5; // 이렇게 쓰면 전부 5만 출력 된다.
					System.out.printf("호출되고 있는 메소드 이름 : %s \n", method.getName()); 
					System.out.printf ("%s 메소드 호출 전 n", method.getName());
					Object result = method.invoke(진짜, ags);
					System.out.printf("결과값: %d\n", result);
					System.out.printf("%s 메소드 호출 후 \n", method.getName());
										
					return result;
				}); 
		
		
      int result = 진짜;
      
		// Proxy에서 진짜를 불러내고 싶으면 proxy 코드를 다 바꿔야 한다. 
		// 이것은 엄청 많이 바꿔줘야해서 이때 Proxy에서 스프링의 DI 기능을 이용한다.
      	// 이것은 원본 객체를 숨길 수 있다. 
      
      result = 가짜.plus();
	  System.out.printf("plus result : %d\n", result);
	  result = 가짜.sub();
	  System.out.printf("sub result : %d\n", result);
	  result = 가짜.multi();
	  System.out.printf("multi result : %d\n", result);
      
//      result = calc.plus();
//      System.out.printf("plus result : %d\n", result);
//      result = calc.sub();
//      System.out.printf("sub result : %d\n", result);
//      result = calc.multi();
//      System.out.printf("multi result : %d\n", result);
	}

}

```

- 위의 두 실습으로 뭐가 "진짜"인지 "calc"인지 알 수가 없다.

<br>
- 스프링은 포인트 컷하는 기능이 있다. 원하는 부분만 넣어서 사용할 수 있다. 하지만 Aspect J에는 그러한 기능이 불필요하게 많다. 


---

<br><br>
### 2) 포인트 컷 개념

- 모든 메서드가 아니라 일부분만 변경하고 싶을 때, 사용한다.

<br>
- `target` : 모든 메서드를 의미한다. 
	- ex) target 1개에 join-point가 3개가 있을 수 있다. 

<br>
- `join-point` : core에 해당하는 부분 

<br>
- `weaving` : proxy가 가지고 있는 부분(앞과 뒤 처리 부분)과 `joint-point`가 가지고 있는 부분을 붙여주는 `weaving`이라고 한다.

<br>
- `point cut` : weaving이 되는 부분을 원하는 범위에서만 한정한다. 자바에는 없고 스프링에서는 있다. Aspect J는 불필요한 기능이 많다. 

<br>
- 정리 : 무조건 AOP는 원본 코드가 실행되기 전에 실행된다. 사전 작업이나 사후 작업에 사용된다. 그래서 나중에 라이브러리나 프레임워크를 만들 때 사용한다.


---

<br><br>
### 3) Transaction

- 우리는 프로그램밍에서 트랜잭션의 원자성, 고립화만 다룬다.

<br>
- 스프링이 제공해주는 고립화는 전파 옵션, 고립도 옵션이 있다.

<br>
- 전파 개념 : 일단 먼저 데이터를 보내는 과정!

<br>
- 문제점 : 같은 자원들을 가지고 2개의 스레드들이 동시에 사용할 때, 처리하는 방법? 








