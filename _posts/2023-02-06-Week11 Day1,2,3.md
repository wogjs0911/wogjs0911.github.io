---
key: /2023/02/06/Week11-Day1,2,3.html
title: TIL-11주차 코드
tags: java oracledb servlet jsp 
---

# 1.  OracleDB, 서브쿼리, join : 230206

### 1) 서브쿼리


- 기존 sql문은 에러가 발생한다.  ORDER BY 의 순서가 중요하다!

```
SELECT * FROM MEMBER ORDER BY REG_DATE DESC
WHERE ROWNUM BETWEEN 1 AND 10;
```

<br>
- 먼저 실행될 것이 있다면, 서브쿼리를 사용한다!

```

SELECT * FROM (
	SELECT * FROM MEMBER ORDER BY REG_DATE DESC
) WHERE ROWNUM BETWEEN 1 AND 10;

```


---

<br>
- 문제점 : 하지만, 2page가 나오지 않는다! ROWNUM을 이용하고 서브쿼리를 여러 번 이용하여 수정하기!
- ROWNUM은 WHERE절이 나오고 SELECT 절이 나오면 등장하기 때문에 가장 마지막에 ROWNUM이 등장한다.
- 따라서, ROWNUM과 ORDER BY는 따로 따로 진행해야하기 때문에 서브쿼리를 2번에 나눠서 사용한다. ORDER BY부터 서브쿼리를 진행하고 ROWNUM는 두번째로 서브쿼리를 진행한다.

<br>
- `SELECT * FROM MEMBER ORDER BY REG_DATE DESC` 
	- 여기에서 새로 생긴 결과집합은 정렬되었기 때문에 원본 'MEMBER'가 아니고 그 새로 생긴 결과 집합에서 별칭을 붙여 'M'으로 이용한다. 
 
```
-- table에 별칭을 쓰는 방법은 결과집합을 괄호로 묶어 괄호 뒤에 별칭을 써준다. 

SELECT * FROM (
    SELECT ROWNUM NUM, M.* FROM (
        SELECT * FROM MEMBER ORDER BY REG_DATE DESC
    )M
)WHERE NUM BETWEEN 11 AND 20;
```

```
-- 별칭을 또 쓰고 싶다면, 이것도 가능 

SELECT X.* FROM (
    SELECT ROWNUM NUM, M.* FROM (
        SELECT * FROM MEMBER ORDER BY REG_DATE DESC
        )M
)X WHERE NUM BETWEEN 11 AND 20;
```

---

<br>
- 새로운 문제 : 조회수가 가장 많은 회원의 정보를 출력해라!

```
SELECT * FROM MEMBER WHERE MEMBER.ID =(
    SELECT N.WRITER_ID FROM(
        SELECT WRITER_ID, COUNT(ID) COUNT FROM NOTICE GROUP BY WRITER_ID ORDER BY COUNT DESC
    )N 
WHERE ROWNUM = 1);
```

---

<br><br>
### 2)  (), ALL, ANY 서브쿼리 연산자? 

- 문제 1: 성별 평균 나이를 조회하시오?

```
SELECT GENDER, AVG(AGE) AGE FROM MEMBER GROUP BY GENDER;
```

<br>
- 문제 2: 성별 평균나이를 상회하는 나이를 가지는 회원 정보를 출력 (ALL, ANY를 이용한다!)
	- 격자형은 비교가 안된다!
	- 단일값은 단일값과 비교해줘야한다. 하지만 여기서는 단일값과 2개값을 비교한다!!
	- 하나의 단일값으로 만들어주는 도구가 필요하다! 
	- ALL을 이용할 때는 모든 것들과 비교했을 때, 등호를 쓰면 이상하다. 이길 때만 고민해야하므로 등호를 넣어줘서 비교해준다!
	
- ALL : 보통은 모든 것들보다 작은 것을 출력하고 할 때, 이용한다. ('<'을 이용)

```
SELECT * FROM MEMBER WHERE AGE < ALL(SELECT AVG(AGE) FROM MEMBER GROUP BY GENDER); 
```

- ANY : ()값이 어떤 것도 이길 수 있는 나이를 뽑아내라('>' 이용) 

```
SELECT * FROM MEMBER WHERE AGE > ANY(SELECT AVG(AGE) FROM MEMBER GROUP BY GENDER); 
```

- 정리 : ALL, ANY는 서브쿼리에서만 사용가능하다!



---

<br><br>
### 3)  Join(조인) : 2개 이상의 테이블을 참조하여 조회하기!

- 데이터 베이스(DB)는 데이터를 한 곳에 모아 놓고 사용하는데 이용한다! 그리고, 무결성을 위해서 사용한다. 무결성은 데이터 중복에 의해서 사용한다. 

- 하지만, 데이터 중복을 없애기 위해서 쪼개서 데이터를 테이블에 저장했는데 이렇게 쪼개진 데이터를 묶어서 사용해야 한다.

- 참조키 개념 :
	- NOTICE의 테이블에서 WRITER_ID는 사용자 정보를 가져오기 위해서 사용하는 참조키이다. 

---

<br>
### 4) INNER JOIN 
	- 칼럼을 늘리는 결합이다.
	- 조인은 주인공에서 만들어진다. 자식 테이블이 주인공이 된다. 참조하는 녀석이 자식이고 참조키를 가지고 있는 것이 자식 테이블이다. 참조키가 먼저 있어야 하므로 먼저 만들어 진다.   
	- 주인공인 자식 테이블이 움직여서 부모 테이블에 붙여진다.
	- 참조하는 수만큼 부모가 복제된다. 복제는 파일에서 하는 것이 아니라 메모리에서 한다. 하지만, 데이터베이스는 통으로 저장하지 않고 부분적으로 가져오기 때문에 더 속도 측면에서 유리하다. 
	- JOIN의 장점 : 성능도 좋게하고 데이터의 결함을 없애준다. 하지만 개발측에서는 어렵다. 

- INNER JOIN  실습 코드 :

```
-- 자식이 참조하고 있는 부모의 레코드만 불러온다!

SELECT * 
FROM MEMBER 
    INNER JOIN NOTICE 
    ON MEMBER.ID = NOTICE.WRITER_ID;
```

- 하지만, INNER JOIN을 하면 NOTICE의 레코드 수 중에서 하나가 빠진다. 
	- 하나가 빠진 이유는 부모 레코드의 ID로 자식 레코드에 없는 경우가 빠진다. 이러한 것을 JOIN 관계에서 같이 결합되지 않은 OUTER가 존재한다. 라고 말한다. 
	

- 2개의 테이블을 사용하면, 애매해서 별칭 써주기!, 또한, 의미를 분명하게 해주기 위해서 칼럼에도 별칭을 붙여준다!
	- 기준(주인공)이 자식 테이블이므로 NOTICE가 기준이 된다.(중요!!)

```
SELECT M.ID MEMBER_ID, M.NAME MEMBER_NAME, N.ID, N.TITLE
FROM MEMBER M
    INNER JOIN NOTICE N 
    ON M.ID = N.WRITER_ID;
```

---

<br>
### 5) OUTER 조인 : 
	- OUTER 조인은 LEFT OUTER, RIGHT OUTER, FULL OUTER의 경우에는 OUTER를 생략할 수 있다.
	- NOTICE에서 아까 빠진 레코드가 있었어서 오른쪽에서 빠진 녀석이었므로 RIGHT OUTER JOIN을 해주자! 그 빠진 레코드를 채워주는 격이다.
	- 자식은 무조건 다 나오게 하고 부모는 그것과 관련된 것에 대해 출력함을 의미한다.  

```
SELECT M.ID MEMBER_ID, M.NAME MEMBER_NAME, N.ID, N.TITLE
FROM MEMBER M
    RIGHT OUTER JOIN NOTICE N
    ON M.ID = N.WRITER_ID;
```


